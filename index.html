<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Behavior Question" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Behavior Question/" class="article-date">
  <time datetime="2018-02-04T05:43:32.284Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="behavior-question"><a href="#behavior-question" class="headerlink" title="behavior question"></a>behavior question</h1><p>** 2017-12-07</p>
<h2 id="Q-Self-Introduce"><a href="#Q-Self-Introduce" class="headerlink" title="Q: Self-Introduce"></a>Q: Self-Introduce</h2><p>Ok, my name is Liyan Chen, and I’m a graduate student from UCSD ECE major. And my interest focus on web application and things like machine learning. Also, I’m good at java and python. As a student who has change one’s major, to better improve my skills, I have spent a lot of time on Coursera to learn different courses like data structure,algorithm and machine learning. In my spare time, I like to read and write blog about technology. I think, with my good understanding of algorithm and data structure, I will be a good fit for this position.</p>
<h2 id="Q-Project-Introduce"><a href="#Q-Project-Introduce" class="headerlink" title="Q: Project Introduce"></a>Q: Project Introduce</h2><p>Ok, I will introduce the project I’m currently working on. It’s a e-commercial website based on mean stack. As you know, as an international student, we move every often, and every time we move, there will be some items we want to sell. And that’s why I want to build such project. The website is used to sell used items. I just deployed on Heroku recently. You can check it <a href="https://mighty-badlands-58522.herokuapp.com/" target="_blank" rel="noopener">here</a>.</p>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h3><p>The backend is based on Node.js and Express. We use mongoose to connect the database. There are three schemas in the application: User, Item and Comment, all the operation on the website is actually operation on the three tables.</p>
<p>In the mean time, passport was used to perform authentication. A user can sign up, login, and logout. According to the different status user in, he can perform different operations.</p>
<p>And as you can see here, the front end is based on Bootstrap, and in the next version, I may use vue.js or react to update the frontend.</p>
<h3 id="what-have-I-learned-from-the-process"><a href="#what-have-I-learned-from-the-process" class="headerlink" title="what have I learned from the process."></a>what have I learned from the process.</h3><p>Through the building process, I have a deeper understanding of how the node.js works, and how it cooperate with the frontend. In the meantime, I’m also more familiar with the frontend. By searching on website, I have solved different problems such as the different strategy the passport should use, and how to design and implement database. In a word, I’m more confident to build a more complicated web application.</p>
<h3 id="Still-need-to-do"><a href="#Still-need-to-do" class="headerlink" title="Still need to do"></a>Still need to do</h3><ol>
<li><p>Add Ajax when user interact with the web page, such as login, logout, add comment.</p>
</li>
<li><p>Updated the frontend using vue.js/react</p>
</li>
<li><p>More function, like sort the item by different categories.</p>
</li>
<li><p>User profile and the message system.</p>
</li>
<li><p>Favorite list and shopping cart.</p>
<p>​</p>
</li>
</ol>
<h2 id="Q-Teamwork"><a href="#Q-Teamwork" class="headerlink" title="Q: Teamwork"></a>Q: Teamwork</h2><p>Well, teamwork is important as student, a good teamwork makes the work tend to be more stable. For example, in the project to predict the price of Airbnb listing , I cooperate with a classmate and he was in charge of the visualization of data and I was in charge of the prediction. In the process, I found that the prediction is not good enough, and have no idea what’s going on, and at that time, he has already finished the visualization of the data, and tell me that the data may be contaminated according to the graph he draw. Knowing this, we have a little discussion and figure out how to filter the data we have. And finally, we solve this problem together. Without teamwork, it’s may be hard to solve problems occur in the process. So you can see that I love teamwork, and it’s important for us as a developer or student.</p>
<h2 id="Q-Why-Intuit"><a href="#Q-Why-Intuit" class="headerlink" title="Q: Why Intuit"></a>Q: Why Intuit</h2><p>Actually I love the product of intuit. Like mint, I used it a lot in daily life. It records everything on my bank account, and shows it in an convenient way. With the help of such software, I can manage my account efficiently. It provides convenience for us. And that’s why I’d like to join you guys and be a developer of such product.</p>
<h2 id="Q-Why-drawbridge"><a href="#Q-Why-drawbridge" class="headerlink" title="Q: Why drawbridge"></a>Q: Why drawbridge</h2><p>Well, during my study in University of California, San Diego, I found that Machine Learning is really interesting and I’d like find job involving both software engineer and machine learning. And I find that drawbridge provides such position. And after spending some time learning about drawbridge, I think drawbridge will be a great choice since what you guys do is really interesting and challenging, and the cross-device thought is really cool. That’s why I’d like to join drawbridge.</p>
<h2 id="Q-Conflict"><a href="#Q-Conflict" class="headerlink" title="Q: Conflict"></a>Q: Conflict</h2><p>How would handle a conflict between two team members?</p>
<p>Ok, I think sometimes conflict happens a lot between team members, especially when working on something difficult. and I think the most important thing to do here is to communicate with your teammates. For example, if I have conflict with my teammate, I will book a private room in the library or somewhere quiet, to have a discussion with him, and figure out where is the disagreement, and listen to his opinion about it, try an reach an agreement with him.</p>
<h2 id="Q-Why-Software-Engineer"><a href="#Q-Why-Software-Engineer" class="headerlink" title="Q: Why Software Engineer?"></a>Q: Why Software Engineer?</h2><p>Well, the answer is simple: being a software engineer gives me a sense of accomplishment. You know, when you see your code runs and something beautiful happens, it’s quiet amazing. I still remember the time when I first accomplished the first web demo, although it’s just a simple web page, I still got so excited and tell my friend about it. It was at that time I determined to be a software engineer.</p>
<h2 id="Q-Problem-solving"><a href="#Q-Problem-solving" class="headerlink" title="Q: Problem-solving"></a>Q: Problem-solving</h2><p>Ok, problems occur quite often when I tried to build the project I mentioned earlier. You know, this is the first time I use node.js to build website , and I found it’s quiet difficult to understand some middleware, for example, like passport, there are so many different strategy and sometimes it can be hard to debug. To solve such questions, I use mocha as the debugging tool and ask friends who have previous experience in mean stack for help. Finally, problems get solved and I also learned a lot from the solving process, like how the node.js works and how to design and implement database, and I also have more confident when building web applications.</p>
<h2 id="Q-Mistake"><a href="#Q-Mistake" class="headerlink" title="Q: Mistake"></a>Q: Mistake</h2><h2 id="Q-Design-a-Venmo-like-App"><a href="#Q-Design-a-Venmo-like-App" class="headerlink" title="Q: Design a Venmo like App"></a>Q: Design a Venmo like App</h2><h2 id="Q-哪些东西-Inspire了你？"><a href="#Q-哪些东西-Inspire了你？" class="headerlink" title="Q: 哪些东西 Inspire了你？"></a>Q: 哪些东西 Inspire了你？</h2><p>The sense of accomplishment, and the pleasure when you see your code runs.</p>
<h2 id="Q-遇到困难怎么办？"><a href="#Q-遇到困难怎么办？" class="headerlink" title="Q:遇到困难怎么办？"></a>Q:遇到困难怎么办？</h2><h2 id="Q-What-the-company-is-working-on-what-I’ll-be-doing-after-joining-the-team"><a href="#Q-What-the-company-is-working-on-what-I’ll-be-doing-after-joining-the-team" class="headerlink" title="Q: What the company is working on, what I’ll be doing after joining the team"></a>Q: What the company is working on, what I’ll be doing after joining the team</h2><h2 id="Q-What-brought-you-to-drawbridge"><a href="#Q-What-brought-you-to-drawbridge" class="headerlink" title="Q: What brought you to drawbridge"></a>Q: What brought you to drawbridge</h2><h2 id="Most-proud-Project"><a href="#Most-proud-Project" class="headerlink" title="Most proud Project"></a>Most proud Project</h2><p>My favorite project is a web application based on MEAN stack. The application works as a platform for us students to sell used items, and provide the function like register/ login, post,update, delete, comment etc function.<br>As a student who changed one’s major, I spent two month on this project and through the building process, I have a through understanding of how web application works behind the scene, and in the meantime, I also have more knowledge of the node.js. So I’m quiet proud about this project.<br>This application is now deployed on Heroku, and if you are interested, you can check it here.(<a href="https://mighty-badlands-58522.herokuapp.com/" target="_blank" rel="noopener">https://mighty-badlands-58522.herokuapp.com/</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Behavior Question/" data-id="cjd8d3nxc0000cuzhvhaxa1r8" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Intro to Python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Intro to Python/" class="article-date">
  <time datetime="2018-02-04T05:43:32.228Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Intro-to-Python"><a href="#Intro-to-Python" class="headerlink" title="Intro to Python"></a>Intro to Python</h1><p>** 2018-01-23</p>
<h2 id="Basic-Language"><a href="#Basic-Language" class="headerlink" title="Basic Language"></a>Basic Language</h2><h3 id="Reserved-Keywords"><a href="#Reserved-Keywords" class="headerlink" title="Reserved Keywords"></a>Reserved Keywords</h3><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><h3 id="Complex-numbers"><a href="#Complex-numbers" class="headerlink" title="Complex numbers"></a>Complex numbers</h3><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><h3 id="Basic-Data-Structures"><a href="#Basic-Data-Structures" class="headerlink" title="Basic Data Structures"></a>Basic Data Structures</h3><p>Python provides many powerful data structures. The two most powerful and fundamental are the list and dictionary. We have already seen that strings are immutable. Python also provides immutable data structures.</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Python中列表是可变的， 这是它区别于字符串和元祖的最重要的特点， 一句话概括即： 列表可以修改， 而字符串和远组不能。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是一个无序不重复元素的集。 基本功能包括关系测试和消除重复元素。</p>
<p>可以用大括号（{}）来创建集合。 注意： 如果要创建一个空集合， 你必须用set()而不是{}； 后者创建一个空的字典。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>序列是以连续的整数作为索引， 与此不同的是， 字典以关键字为索引， 关键字可以是任意不可变类型， 通常用字符串或数值。在同一个字典之内， 关键字必须是互不相同。</p>
<p>一对大括号创建一个空的字典：{}</p>
<p>构造函数dict()直接从键值对元祖列表中构建字典。 如果有固定的模式， 列表推导式指定特定的键值对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)])</span><br><span class="line">&#123;&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127&#125;</span><br></pre></td></tr></table></figure>
<p>此外， 字典推导可以用来创建任意键和值的表达式词典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br></pre></td></tr></table></figure>
<p>or：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)</span><br><span class="line">&#123;&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127&#125;</span><br></pre></td></tr></table></figure>
<p>如何创建字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; top=&#123;&apos;math&apos;:&apos;Gauss&apos;,&apos;phys&apos;:&apos;Newton&apos;,&apos;art&apos;:&apos;Vemeer&apos;,&apos;phil&apos;:&apos;Emerson&apos;,</span><br><span class="line">... &apos;play&apos;:&apos;Shakespeare&apos;,&apos;actor&apos;:&apos;Kidman&apos;,&apos;direct&apos;:&apos;Kubrick&apos;,</span><br><span class="line">... &apos;author&apos;:&apos;Hemmingway&apos;,&apos;bio&apos;:&apos;Watson&apos;,&apos;group&apos;:&apos;R.E.M&apos;&#125;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; len(top) #&#123; &#125; are dictionary creation operators</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; top[&apos;pres&apos;]=&apos;F.D.R.&apos;</span><br><span class="line">&gt;&gt;&gt; top[&apos;bio&apos;]=&apos;Darwin&apos;</span><br><span class="line">&gt;&gt;&gt; #can delete a key,value pair</span><br><span class="line">&gt;&gt;&gt; del top[&apos;actor&apos;]</span><br><span class="line">&gt;&gt;&gt; # another way of creating a dict</span><br><span class="line">&gt;&gt;&gt; x=dict(key=&apos;value&apos;,another_key=1.333,more_keys=[1,3,4,&apos;one&apos;])</span><br><span class="line">&gt;&gt;&gt; print x </span><br><span class="line">&#123;&apos;another_key&apos;: 1.333, &apos;more_keys&apos;: [1, 3, 4, &apos;one&apos;], &apos;key&apos;: &apos;value&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; x=&#123;(1,3):&apos;value&apos;&#125;     # any immutable type can be a valid key</span><br><span class="line">&gt;&gt;&gt; print x</span><br><span class="line">&#123;(1, 3): &apos;value&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; x[(1,3)]=&apos;immutables can be keys&apos;</span><br></pre></td></tr></table></figure>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>Tuples are another general purpose sequential container in Python, very similar to lists, but these are immutable.Tuples are delimited by commas.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple([1,3,4])</span><br><span class="line">(1, 3, 4)</span><br><span class="line">&gt;&gt;&gt; 1,3,4</span><br><span class="line">(1, 3, 4)</span><br><span class="line">&gt;&gt;&gt; pets=(&apos;dog&apos;,&apos;cat&apos;,&apos;bird&apos;)  #Parentheses () create tuples</span><br><span class="line">&gt;&gt;&gt; pets[0]</span><br><span class="line">&apos;dog&apos;</span><br><span class="line">&gt;&gt;&gt; pets + pets # addition</span><br><span class="line">(&apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;, &apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;)</span><br><span class="line">&gt;&gt;&gt; pets*3</span><br><span class="line">(&apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;, &apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;, &apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;)</span><br><span class="line">&gt;&gt;&gt; pets[0]=&apos;rat&apos; # assignment not work!</span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br></pre></td></tr></table></figure>
<h4 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h4><p>在字典中遍历时， 关键字和对应的值可以使用items()方法同时解读出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class="line">...     print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>
<p>在列表中遍历时， 索引位置和对应值可以使用enumerate()函数同时得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):</span><br><span class="line">...     print(i, v)</span><br><span class="line">...</span><br><span class="line">0 tic</span><br><span class="line">1 tac</span><br><span class="line">2 toe</span><br></pre></td></tr></table></figure>
<p>同时遍历两个或更多的序列， 可以使用zip()组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]</span><br><span class="line">&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]</span><br><span class="line">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class="line">...     print(&apos;What is your &#123;0&#125;?  It is &#123;1&#125;.&apos;.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure>
<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><p>The for loop iterates items that provided by the iterator, which is the range(3) list in the above example. Python abstracts the idea of <code>iterable</code> out of the looping construction so that some Python objects are iterable all by themselves and are just are waiting for an iteration provider like a for a while loop to get them going.</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Python is a <em>truthy</em> language:</p>
<p>Only these are false:</p>
<ul>
<li><code>None</code></li>
<li><code>False</code></li>
<li>zero of any numeric type, for example, <code>0, 0L, 0.0, 0j</code>.</li>
<li>any empty sequence, for example, <code>&#39;&#39;, (), []</code>.</li>
<li>any empty mapping, for example, <code>{}</code>.</li>
<li>instances of user-defined classes, if the class defines a <code>__nonzero__()</code> or <code>__len__()</code> method, when that method returns the integer zero or bool value False.</li>
</ul>
<h4 id="Difference-between-is-and-“-”"><a href="#Difference-between-is-and-“-”" class="headerlink" title="Difference between is and “==”"></a>Difference between is and “==”</h4><p>The keyword is is stronger than equality, because it checks if two objects are the same.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x= &apos;this string&apos;</span><br><span class="line">y= &apos;this string&apos;</span><br><span class="line">print x is y</span><br><span class="line"></span><br><span class="line">print x==y</span><br></pre></td></tr></table></figure>
<p><code>is</code> is really checking the id of each of the items.</p>
<h4 id="Conditionals"><a href="#Conditionals" class="headerlink" title="Conditionals"></a>Conditionals</h4><p>The for loop can have an else clause as in the following</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rangelist = range(10)</span><br><span class="line">&gt;&gt;&gt; print rangelist</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; for number in rangelist:</span><br><span class="line">...       # Check if number is one of</span><br><span class="line">...       # the numbers in the tuple.</span><br><span class="line">...       if number in (3, 4, 7, 9):</span><br><span class="line">...           # &quot;Break&quot; terminates a for without</span><br><span class="line">...           # executing the &quot;else&quot; clause.</span><br><span class="line">...           break</span><br><span class="line">...       else:</span><br><span class="line">...           # &quot;Continue&quot; starts the next iteration</span><br><span class="line">...           # of the loop. It&apos;s rather useless here,</span><br><span class="line">...           # as it&apos;s the last statement of the loop.</span><br><span class="line">...           continue</span><br><span class="line">... else:</span><br><span class="line">...       # The &quot;else&quot; clause is optional and is</span><br><span class="line">...       # executed only if the loop didn&apos;t &quot;break&quot;.</span><br><span class="line">...       pass # Do nothing</span><br></pre></td></tr></table></figure>
<p>the else clause is to detect the “break” in the previous for clause.</p>
<p>This is good for recognizing when a loop exists normally or via break.</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Note that you need a return statement and that you need the parenthesis to actually invoke the function. Without the return statement, the functions returns the None singleton.</p>
<p>Functions are first-class objects.</p>
<p>Practically speaking, this means they can be manipulated like any other Python object— they can be put in containers and passed around without any special handling. Naturally, we want to supply arguments to our functions . There are two kinds of function arguments positional and keyword.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def foo(x=20): # keyword named argument</span><br><span class="line">...     return 2*x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; foo(1)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; foo()</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; foo(x=30)</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; def foo(x=20,y=30):</span><br><span class="line">...     return x+y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; foo(20,)</span><br><span class="line">50</span><br><span class="line">&gt;&gt;&gt; foo(1,1)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; foo(y=12)</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; help(foo) </span><br><span class="line">Help on function foo in module __main__:</span><br><span class="line">...</span><br><span class="line">foo(x=20, y=30) # provides automatic documentation</span><br></pre></td></tr></table></figure>
<p>Python makes it easy to include document for your functions using <code>docstrings</code>. That makes the help function more useful for functions.</p>
<p>In addition to using the <code>def</code> statement, you can also create functions using <code>lambda</code>. These are sometimes called <code>anonymous</code> functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x:  x**2 # anonymous functions</span><br><span class="line">&gt;&gt;&gt; f(10)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; [lambda x: x, lambda x:x**2] # list of functions</span><br><span class="line">[&lt;function &lt;lambda&gt; at ...&gt;, &lt;function &lt;lambda&gt; at ...&gt;]</span><br><span class="line">&gt;&gt;&gt; for i in  _:</span><br><span class="line">...   print i(10)</span><br><span class="line">10</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>So far, we have not made good use of tuple, but these data structures become very powerful when used with functions. This is because they allow you to separate the function arguments from the function itself. This means you can pass them around and build function arguments and then later execute them with one or more functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">The usefulness of tuples derives from using them with functions</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; args = (1,3,4)</span><br><span class="line">&gt;&gt;&gt; def foo(x,y,z): #defining</span><br><span class="line">...   return x+y+z</span><br><span class="line">&gt;&gt;&gt; print foo(*args) # note the asterisk notation</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">This also works with keyword arguments</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def foo(x=1,y=2,z=3):</span><br><span class="line">...   return x+y+z</span><br><span class="line">&gt;&gt;&gt; kwargs = &#123;&apos;x&apos;:10,&apos;y&apos;:20,&apos;z&apos;:30&#125;</span><br><span class="line">&gt;&gt;&gt; print foo(**kwargs) # note the double asterisks</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; kwargs = &#123;&apos;x&apos;:10,&apos;y&apos;:20,&apos;z&apos;:30,&apos;h&apos;:100&#125; # extra argument</span><br><span class="line">&gt;&gt;&gt; print foo(**kwargs) # note the double asterisks</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: foo() got an unexpected keyword argument &apos;h&apos;</span><br><span class="line"></span><br><span class="line">This also works in combination</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def foo(x,y=2,z=3): # note the the first argument is positional</span><br><span class="line">...    return x+y+z</span><br><span class="line">&gt;&gt;&gt; kwargs = &#123;&apos;y&apos;:20,&apos;z&apos;:30&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1,)</span><br><span class="line">&gt;&gt;&gt; foo(*args,**kwargs)</span><br><span class="line">51</span><br></pre></td></tr></table></figure>
<p>对于map， reduce以及filter的介绍：</p>
<ol>
<li><p>map:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(function_to_apply, list_of_inputs)</span><br><span class="line">items=[1,2,3,4,5]</span><br><span class="line">squared=list(map(lambda x: x**2, items))</span><br></pre></td></tr></table></figure>
<p>Instead of a list of inputs, we can even have a list of functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def multiply(x):</span><br><span class="line">    return (x*x)</span><br><span class="line">def add(x):</span><br><span class="line">    return (x+x)</span><br><span class="line"></span><br><span class="line">funcs = [multiply, add]</span><br><span class="line">for i in range(5):</span><br><span class="line">    value = list(map(lambda x: x(i), funcs))</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Filter</p>
<p>As the name suggests, filter creates a list of elements for which a function returns true. Here is a short and concise example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number_list = range(-5, 5)</span><br><span class="line">less_than_zero = list(filter(lambda x: x &lt; 0, number_list))</span><br><span class="line">print(less_than_zero)</span><br><span class="line"></span><br><span class="line"># Output: [-5, -4, -3, -2, -1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reduce:</p>
<p><code>Reduce</code> is a really useful function for performing some computation on a list and returning the result. It applies a rolling computation to sequential pairs of values in a list. For example, if you wanted to compute the product of a list of integers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">product = reduce((lambda x, y: x * y), [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Function-Variable-Scoping"><a href="#Function-Variable-Scoping" class="headerlink" title="Function Variable Scoping"></a>Function Variable Scoping</h4><p>Variables within functions or subfunctions are local to that respective scope. Global variables require special handling if they are going to be changed inside the function body.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=10 # outside function</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...    return x</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...    x=1 # defined inside function</span><br><span class="line">...    return x</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...   global x # define as global</span><br><span class="line">...   x=20     # assign inside function scope</span><br><span class="line">...   return x</span><br><span class="line">&gt;&gt;&gt; print x</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="Function-keyword-filtering"><a href="#Function-keyword-filtering" class="headerlink" title="Function keyword filtering"></a>Function keyword filtering</h4><p>Using <code>**kwds</code> at the end allows functions to disregard keywords they don’t use while filtering out(using the function signature) the keyword puts that it doer use.</p>
<p><a href="http://lazybios.com/2013/04/four-kinds-of-function-argment-pass-in-python/" target="_blank" rel="noopener">参考资料</a></p>
<p>python 中参数的传递是通过赋值来传递的， 函数参数的使用又有两个方面值得注意：</p>
<ul>
<li>函数参数是如何定义的</li>
<li>在调用函数的过程中参数是如何被解析的。</li>
</ul>
<ol>
<li><p>F(arg1, arg2)</p>
<p>这 是最常见的定义方式，一个函数可以定义任意个参数，每个参数间用逗号分割，用这种方式定义的函数在调用的的时候也必须在函数名后的小括号里提供个数相等的 值（实际参数），而且顺序必须相同，也就是说在这种调用方式中，形参和实参的个数必须一致，而且必须一一对应，也就是说第一个形参对应这第一个实参。</p>
</li>
<li><p>F(arg1, arg2=value2, …)</p>
<p>这种方式就是第一种的改进版， 提供了默认值</p>
</li>
<li><p>F(*arg1)</p>
<p>上面两个方式是有多少个形参， 就传进去多少个实参， 但有时候会不确定有多少个参数， 则此时第三种方式就比较有用， 它以一个*加上形参名的方式来表示这个函数的实参个数不定， 可能为0个也可能为n个。 注意一点是， 不管有多少个， 在函数内部都被存放在以形参名为标识符的tuple中。</p>
</li>
<li><p>F(**arg1)</p>
<p>形参名前加两个**表示， 参数在函数内部将被存放在以形式名为标识符的dictionary中， 此时调用函数的方法则需要采用arg1= value1, arg2= value2 这样的形式。</p>
</li>
</ol>
<p>上面介绍了四种定义方式， 接下来看函数参数在调用过程中是怎样被解析的， 其实只要记住上面这四种方法优先级依次降低， 先1， 后2， 再3， 最后4， 也就是先把方式1 中的arg解析， 最后解析方式2 中的arg= value， 再解析方式3， 即是把多出来的arg这种形式的实参组成个tuple传进去， 最后把剩下的key=value这种形式的实参组成一个dictionary传给带两个型号的形参， 也就是方式4。</p>
<p>首先说说Python中参数传递的问题， Python中有可变对象和不可变对象， 在参数传递时分为两种情况：</p>
<ul>
<li>对于不可变对象作为函数参数， 相当于C系语言的值传递；</li>
<li>对于可变对象作为函数参数， 相当于C系语言的引用传递。</li>
</ul>
<p>Python传参数可以理解成C的const指针， 它所指向的对象可以被修改产生副作用， 但变量本身不能修改指向其他对象。</p>
<h4 id="Functional-Programming-Idioms"><a href="#Functional-Programming-Idioms" class="headerlink" title="Functional Programming Idioms"></a>Functional Programming Idioms</h4><p>Although not a real functional programming language(i.e., Haskell), Python has useful functional idioms. These become important in parallel computing frameworks like pySpark, but have become deprecated in Python 3.x.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print map( lambda x:  x**2 , range(10))</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; [i**2 for i in range(10)]</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x,y:x+2*y,[0,1,2,3],0)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; filter(lambda x: x%2, range(10) )</span><br><span class="line">[1, 3, 5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; [i for i in range(10) if i %2 ]</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>
<p>Pay attention to the recursive problem that reduce solves because reduce is super-fast in Python. the least common multiple algorithm can be effectively implemented using reduce, as shown:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def gcd(a, b):</span><br><span class="line">    &quot;&quot;&quot;Return greatest common divisor using Euclid&apos;s Algorithm.&quot;&quot;&quot;</span><br><span class="line">    while b:</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">def lcm(a, b):</span><br><span class="line">    &quot;&quot;&quot;Return lowest common multiple.&quot;&quot;&quot;</span><br><span class="line">    return a * b // gcd(a, b)</span><br><span class="line"></span><br><span class="line">def lcmm(*args):</span><br><span class="line">    &quot;&quot;&quot;Return lcm of args.&quot;&quot;&quot;</span><br><span class="line">    return reduce(lcm, args)</span><br></pre></td></tr></table></figure>
<p>reduce() in Python:</p>
<p>The reduce(fun, seq) function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along. This function is defined in “functools” module.</p>
<p><strong>Working :</strong></p>
<ul>
<li>At first step, first two elements of sequence are picked and the result is obtained.</li>
<li>Next step is to apply the same function to the previously attained result and the number just succeeding the second element and the result is again stored.</li>
<li>This process continues till no more elements are left in the container.</li>
<li>The final returned result is returned and printed on console.</li>
</ul>
<p>Also beware to the default containers in functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def foo(x=[]): # using empty list as default</span><br><span class="line">...     x.append(10)</span><br><span class="line">...     return x</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; foo() # maybe you expected this...</span><br><span class="line">[10]</span><br><span class="line">&gt;&gt;&gt; foo() # ... but did you expect this...</span><br><span class="line">[10, 10]</span><br><span class="line">&gt;&gt;&gt; foo() # ... or this? What&apos;s going on here?</span><br><span class="line">[10, 10, 10]</span><br></pre></td></tr></table></figure>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="Basic-file-usage"><a href="#Basic-file-usage" class="headerlink" title="Basic file usage"></a>Basic file usage</h4><h4 id="Serialization-Saving-Complex-objects"><a href="#Serialization-Saving-Complex-objects" class="headerlink" title="Serialization: Saving Complex objects"></a>Serialization: Saving Complex objects</h4><p>Serialization means packing Python objects to be shipped between separate Python processes or separate computers.</p>
<p>The multiplatform nature of Python means that one cannot be assured that the low-level attributes of Python objects (say, between platform types or Python versions) will remain consistent. This <a href="https://pyvideo.org/video/384/pycon-2011--everything-you-wanted-to-know-about-p" target="_blank" rel="noopener">video</a> provides an in-depth discussion of each step of the Python serialization process.</p>
<p>For the vast majority of situations, the following will work.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import cPickle</span><br><span class="line">&gt;&gt;&gt; mylist = [&quot;This&quot;, &quot;is&quot;, 4, 13327]</span><br><span class="line">&gt;&gt;&gt; f=open (&apos;myfile.dat&apos;,&apos;wb&apos;) # write-binary mode</span><br><span class="line">&gt;&gt;&gt; cPickle.dump(mylist, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; f=open (&apos;myfile.dat&apos;,&apos;rb&apos;) # write-binary mode</span><br><span class="line">&gt;&gt;&gt; print cPickle.load(f)</span><br><span class="line">[&apos;This&apos;, &apos;is&apos;, 4, 13327]</span><br></pre></td></tr></table></figure>
<h3 id="Dealing-with-Errors"><a href="#Dealing-with-Errors" class="headerlink" title="Dealing with Errors"></a>Dealing with Errors</h3><p>try except block</p>
<h2 id="Some-Other-features"><a href="#Some-Other-features" class="headerlink" title="Some Other features"></a>Some Other features</h2><h3 id="The-max-function"><a href="#The-max-function" class="headerlink" title="The max function"></a>The max function</h3><p>the max function takes the maximum of a sequence.</p>
<p>If the items in the sequence are tuples, then the first item in the tuple is used for the ranking.</p>
<p>This function takes a key argument that controls how the items in the sequence are evaluated. For example, we can rank based on the second element in the tuple.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max([1,4],[3,2]), key= lambda i: i[1]</span><br><span class="line">(1, 4)</span><br></pre></td></tr></table></figure>
<h3 id="The-sorted-function"><a href="#The-sorted-function" class="headerlink" title="The sorted function"></a>The sorted function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student_tuples=[</span><br><span class="line">  (&apos;john&apos;,&apos;A&apos;, 15),</span><br><span class="line">  (&apos;jane&apos;, &apos;B&apos;, 12),</span><br><span class="line">  (&apos;dave&apos;, &apos;B&apos;, 10),</span><br><span class="line">]</span><br><span class="line">sorted(student_tuples, key=lambda students: student[2])</span><br></pre></td></tr></table></figure>
<p>or we can use the old way using the cmp parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def numeric_compare(x, y):</span><br><span class="line">	return x-y</span><br><span class="line">sorted([5,2,4,1,3], cmp=numeric_compare)</span><br></pre></td></tr></table></figure>
<h3 id="The-with-statement"><a href="#The-with-statement" class="headerlink" title="The with statement"></a>The with statement</h3><p>Set up a context for subsequent code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ControlledExecution:</span><br><span class="line">	def __enter__(self):</span><br><span class="line">		# set things up</span><br><span class="line">		return thing</span><br><span class="line">    def __exit__(self, type, value, traceback):</span><br><span class="line">      	#tear things down</span><br><span class="line"> with ControlledExecution() as thing:</span><br><span class="line">  	some code</span><br></pre></td></tr></table></figure>
<p>Using with files:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;sample1.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;open file &apos;sample1.txt&apos;, mode &apos;r&apos; at 0x00AE82F0&gt;</span><br><span class="line">&gt;&gt;&gt; f.__enter__()</span><br><span class="line">&lt;open file &apos;sample1.txt&apos;, mode &apos;r&apos; at 0x00AE82F0&gt;</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; f.__exit__(None, None, None)</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file</span><br></pre></td></tr></table></figure>
<p>This is the new way to open close files that makes it harder to forget to close the files when you’re done.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;x.txt&quot;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    #do something with data</span><br></pre></td></tr></table></figure>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p><a href="http://kissg.me/2016/04/09/python-generator-yield/" target="_blank" rel="noopener">reference</a></p>
<p>Just-in-time memory efficient containers</p>
<ul>
<li>produces a stream of on-demand values</li>
<li>only executes on next()</li>
<li>yield() produces a value, but saves the function’s state for later</li>
<li>Consumable(use once-only)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def generate_ints(N):</span><br><span class="line">  for i in range(N):</span><br><span class="line">    yield i #the yield makes the function a generator</span><br><span class="line">x= generate_ints(3)</span><br><span class="line">x.next()</span><br><span class="line">x.next()</span><br><span class="line">x.next()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pi_series(): # infinite series converges to pi</span><br><span class="line">...    sm = 0</span><br><span class="line">...    i = 1.0; j = 1</span><br><span class="line">...    while True: # loops forever!</span><br><span class="line">...       sm = sm + j/i</span><br><span class="line">...       yield 4*sm</span><br><span class="line">...       i = i + 2; j = j * -1</span><br><span class="line">&gt;&gt;&gt; x = pi_series()</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">4.0</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">2.666666666666667</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">3.4666666666666668</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">2.8952380952380956</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">3.3396825396825403</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">2.9760461760461765</span><br><span class="line">&gt;&gt;&gt; x.next()</span><br><span class="line">3.2837384837384844</span><br></pre></td></tr></table></figure>
<p>Generators can also be created as list comprehensions by changing the bracket notation to parentheses.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x= (i for i in range(10))</span><br><span class="line">&gt;&gt;&gt; print type(x)</span><br><span class="line">&lt;type &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="noopener">More about generators</a></p>
<p>我们以如何生成斐波那契数列为例：</p>
<ul>
<li><p>code 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def fab(max): </span><br><span class="line">   n, a, b = 0, 0, 1 </span><br><span class="line">   while n &lt; max: </span><br><span class="line">       print b </span><br><span class="line">       a, b = b, a + b </span><br><span class="line">       n = n + 1</span><br></pre></td></tr></table></figure>
<p>直接在fab函数中用print打印数字可能会导致该函数可复用性比较差， 因为fab函数返回None， 其他函数无法获取该函数生成的数列。</p>
</li>
<li><p>code 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fab(max): </span><br><span class="line">   n, a, b = 0, 0, 1 </span><br><span class="line">   L = [] </span><br><span class="line">   while n &lt; max: </span><br><span class="line">       L.append(b) </span><br><span class="line">       a, b = b, a + b </span><br><span class="line">       n = n + 1 </span><br><span class="line">   return L</span><br></pre></td></tr></table></figure>
<p>改写后的fab函数通过返回List能满足复用性的要求， 但是该函数在运行中占用的内存会随着参数max的增大而增大， 如果要控制内存占用， 最好不用List来保存中间结果， 而是通过iterable来迭代， 例如在python2中， 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for in in range(1000): pass</span><br></pre></td></tr></table></figure>
<p>会生成一个1000个元素的List， 而代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(1000): pass</span><br></pre></td></tr></table></figure>
<p>则不会生成一个1000个元素的List， 而是在每次迭代中返回下一个数值， 内存空间占用很小。 因为xrange不返回list， 而是返回一个iterable对象。</p>
</li>
<li><p>利用iterable我们可以把fab函数改写为一个支持iterable的class， 以下时第三个版本的Fab：</p>
<p>code 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Fab(object): </span><br><span class="line"> </span><br><span class="line">   def __init__(self, max): </span><br><span class="line">       self.max = max </span><br><span class="line">       self.n, self.a, self.b = 0, 0, 1 </span><br><span class="line"> </span><br><span class="line">   def __iter__(self): </span><br><span class="line">       return self </span><br><span class="line"> </span><br><span class="line">   def __next__(self): </span><br><span class="line">       if self.n &lt; self.max: </span><br><span class="line">           r = self.b </span><br><span class="line">           self.a, self.b = self.b, self.a + self.b </span><br><span class="line">           self.n = self.n + 1 </span><br><span class="line">           return n</span><br><span class="line">       raise StopIteration()</span><br></pre></td></tr></table></figure>
<p>Fab类通过next()不断返回数列的下一个数， 内存占用始终为常数。</p>
<p>然而使用class改写的这个版本， 代码远远没有第一版的fab函数来得简洁。 如果我们想要保持第一版fab函数的简洁性， 同时又要获得iterable的对象， yield就派上用场了。</p>
</li>
<li><p>code 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fab(max): </span><br><span class="line">    n, a, b = 0, 0, 1 </span><br><span class="line">    while n &lt; max: </span><br><span class="line">        yield b </span><br><span class="line">        # print b </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + 1 </span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单地讲， yield的作用就是把一个函数变成了一个generator，带有yield的函数不再是一个普通函数， Python解释器会将其视为一个generator， 调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。</p>
<p>也可以手动调用 fab(5) 的 next() 方法（因为 fab(5) 是一个 generator 对象，该对象具有 next() 方法），这样我们就可以更清楚地看到 fab 的执行流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = fab(5) </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">1 </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">1 </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">2 </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">3 </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">5 </span><br><span class="line">&gt;&gt;&gt; f.next() </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>我们可以得出以下结论：</p>
<p>一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。</p>
<p>yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。</p>
<p>如何判断一个函数是否是一个特殊的 generator 函数？可以利用 isgeneratorfunction 判断：</p>
<p>使用 isgeneratorfunction 判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from inspect import isgeneratorfunction</span><br><span class="line">&gt;&gt;&gt; isgeneratorfunction(fab) </span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>要注意区分 fab 和 fab(5)，fab 是一个 generator function，而 fab(5) 是调用 fab 返回的一个 generator，好比类的定义和类的实例的区别：</p>
<p>类的定义和类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types </span><br><span class="line">&gt;&gt;&gt; isinstance(fab, types.GeneratorType)</span><br><span class="line">False </span><br><span class="line">&gt;&gt;&gt; isinstance(fab(5), types.GeneratorType) </span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>``</p>
<p>fab 是无法迭代的，而 fab(5) 是可迭代的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable </span><br><span class="line">&gt;&gt;&gt; isinstance(fab, Iterable) </span><br><span class="line">False </span><br><span class="line">&gt;&gt;&gt; isinstance(fab(5), Iterable) </span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>每次调用 fab 函数都会生成一个新的 generator 实例，各实例互不影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1 = fab(3)</span><br><span class="line">&gt;&gt;&gt; f2 = fab(5) </span><br><span class="line">&gt;&gt;&gt; print &apos;f1:&apos;, f1.next() </span><br><span class="line">f1: 1 </span><br><span class="line">&gt;&gt;&gt; print &apos;f2:&apos;, f2.next() </span><br><span class="line">f2: 1 </span><br><span class="line">&gt;&gt;&gt; print &apos;f1:&apos;, f1.next() </span><br><span class="line">f1: 1 </span><br><span class="line">&gt;&gt;&gt; print &apos;f2:&apos;, f2.next() </span><br><span class="line">f2: 1 </span><br><span class="line">&gt;&gt;&gt; print &apos;f1:&apos;, f1.next() </span><br><span class="line">f1: 2 </span><br><span class="line">&gt;&gt;&gt; print &apos;f2:&apos;, f2.next() </span><br><span class="line">f2: 2 </span><br><span class="line">&gt;&gt;&gt; print &apos;f2:&apos;, f2.next() </span><br><span class="line">f2: 3 </span><br><span class="line">&gt;&gt;&gt; print &apos;f2:&apos;, f2.next() </span><br><span class="line">f2: 5</span><br></pre></td></tr></table></figure>
<h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><p>Decorators are functions that make functions out of functions. It sounds redundant, but turns out to be very useful for uniting disparate concepts.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def my_decorator(fn): # note that function as input</span><br><span class="line">...   def new_function(*args,**kwargs): # we&apos;ve seen these arguments before</span><br><span class="line">...       print &apos;this runs before function&apos;</span><br><span class="line">...       return fn(*args,**kwargs) # return a function</span><br><span class="line">...   return new_function</span><br><span class="line">&gt;&gt;&gt; def foo(x):</span><br><span class="line">...   return 2*x</span><br><span class="line">&gt;&gt;&gt; goo = my_decorator(foo)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; foo (3)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; goo (3)</span><br><span class="line">this runs before function</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>Decorators are useful for debugging:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def log_arguments(fn): # note that function as input</span><br><span class="line">...   def new_function(*args,**kwargs): # we&apos;ve seen these arguments before</span><br><span class="line">...       print &apos;positional arguments:&apos;</span><br><span class="line">...       print args</span><br><span class="line">...       print &apos;keyword arguments:&apos;</span><br><span class="line">...       print kwargs</span><br><span class="line">...       return fn(*args,**kwargs) # return a function</span><br><span class="line">...   return new_function</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; @log_arguments # these are stackable also</span><br><span class="line">... def foo(x,y=20):</span><br><span class="line">...   return x*y</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; foo (1,y=3)</span><br><span class="line">positional arguments:</span><br><span class="line">(1,)</span><br><span class="line">keyword arguments:</span><br><span class="line">&#123;&apos;y&apos;: 3&#125;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="use-of-in-keyword"><a href="#use-of-in-keyword" class="headerlink" title="use of in keyword"></a>use of <code>in</code> keyword</h3><p><a href="https://stackoverflow.com/questions/19775692/use-and-meaning-of-in-in-an-if-statement" target="_blank" rel="noopener">reference</a></p>
<p>It depends on what <code>next</code> is.</p>
<p>If it’s a string (as in your example), then <code>in</code> checks for substrings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;in&quot; in &quot;indigo&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;in&quot; in &quot;violet&quot;</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;0&quot; in &quot;10&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;1&quot; in &quot;10&quot;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>If it’s a different kind of iterable (list, tuple, dictionary…), then <code>in</code> checks for membership.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;in&quot; in [&quot;in&quot;, &quot;out&quot;]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;in&quot; in [&quot;indigo&quot;, &quot;violet&quot;]</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>In a dictionary, membership is seen as “being one of the keys”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;in&quot; in &#123;&quot;in&quot;: &quot;out&quot;&#125;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;in&quot; in &#123;&quot;out&quot;: &quot;in&quot;&#125;</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h3 id="import-amp-amp-modules"><a href="#import-amp-amp-modules" class="headerlink" title="import &amp;&amp; modules"></a>import &amp;&amp; modules</h3><p>这里需要遇到问题的时候再看一下。</p>
<h2 id="Object-oriented-programming"><a href="#Object-oriented-programming" class="headerlink" title="Object oriented programming"></a>Object oriented programming</h2><p>The purpose of object-oriented programming is to facilitate encapsulation of variables and functions and to facilitate fine-grained code re-use.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html" target="_blank" rel="noopener">link_1</a></p>
<p><a href="http://python.jobbole.com/82023/" target="_blank" rel="noopener">link_2</a></p>
<p><a href="http://python.jobbole.com/83747/" target="_blank" rel="noopener">link_3</a></p>
<h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul>
<li>Properties/Attribute—embedded data</li>
<li>Methods/Behaviors—function on data</li>
<li>Interfaces—communicating with the outside world</li>
<li>inheritance– re-using code</li>
</ul>
<p>For safety reasons this arbitrary attaching of attributes to objects is blocked for certain built-in objects (c.f., <code>__slots__</code>), but you get the idea. You can create your own objects with the <code>class</code> keyword. The following is the simplest possible custom object,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure>
<p>We’ll talk about the <code>object</code> part later. We can instantiate our <code>Foo</code>object in the following,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = Foo() # need parenthesis</span><br><span class="line">&gt;&gt;&gt; f.x = 30  # tack on attribute</span><br><span class="line">&gt;&gt;&gt; f.x</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<p>The <code>__init__</code> method is the constructor for objects/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.x=30</span><br></pre></td></tr></table></figure>
<p>Remember that the <code>__init__</code> functions is just another Python function and follows the same syntax. The surrounding double underscores indicate that the function has a special low-level status.</p>
<p>Unlike many object-oriented languages, Python does not have implement private versus public attributes as part of the language. Rather, these are managed by convention. For example, attributes that start with a single underscore character are(only by convention) considered private, although nothing in the language provides them special status.</p>
<p>Access to the attributes of the object is the distinction between methods and functions. For example, I can create a function and tack it onto an existing objects as in the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f= Foo()  #create an object</span><br><span class="line">f.func= lambda i: i**2</span><br></pre></td></tr></table></figure>
<p>Everything in python is an object, which means operations like the plus can be specified as methods.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">	def __init__(self, x=10):</span><br><span class="line">		self.x= x</span><br><span class="line">	def __add__(self, y):  #overloading &apos;addition&apos; opertion</span><br><span class="line">		return self.x+y.x</span><br><span class="line">		</span><br><span class="line">a= Foo(x=20)</span><br><span class="line">b=Foo()</span><br><span class="line">a+b</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>The idea is to re-use your own codes with inheritance. Python also supports multiple inheritance and delegation(via keyword);</p>
<p>for example, here we overwrite the <code>__repr__</code> function in the list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyList(list): # inherit from built-in list object</span><br><span class="line">...   def __repr__(self):</span><br><span class="line">...       list_string = list.__repr__(self)</span><br><span class="line">...       return list_string.replace(&apos; &apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; MyList([1,3]) # no spaces in output</span><br><span class="line">[1,3]</span><br><span class="line">&gt;&gt;&gt; list([1,3])</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure>
<p>Once you can roll your own objects, you can reproduce the behavior of other Python objects, like iterables, for instance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...     def __init__(self,size=10):</span><br><span class="line">...         self.size = size</span><br><span class="line">...     def __iter__(self): # produces iterable</span><br><span class="line">...         self.counter = range(self.size)</span><br><span class="line">...         return self # return object that has next() method</span><br><span class="line">...     def next(self): # does iteration</span><br><span class="line">...        if self.counter:</span><br><span class="line">...           return self.counter.pop()</span><br><span class="line">...        else:</span><br><span class="line">...           raise StopIteration</span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line">&gt;&gt;&gt; list(f)</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; for i in Foo(3): # iterate over</span><br><span class="line">...   print i</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="class-variables"><a href="#class-variables" class="headerlink" title="class variables"></a>class variables</h3><ol>
<li><p>在变量前面加上<code>__</code>双下划线来区分private变量， 但Python的访问限制其实并不严格， 主要靠自觉。</p>
</li>
<li><p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<ul>
<li>对扩展开放：允许新增Animal子类；</li>
<li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</li>
</ul>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Start...&apos;)</span><br></pre></td></tr></table></figure>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<p>总结一下：</p>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
</li>
</ol>
<p>This also works with functions, not just variables. You have to use the <code>@classmethod</code> decorator for this. Note that the existence of class variables does not make them known to the rest of the class definition automatically. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">   x = 10</span><br><span class="line">   def __init__(self):</span><br><span class="line">      self.fx = x**2 # x variable is not known</span><br></pre></td></tr></table></figure>
<p>will result in the following error: <code>NameError: global name &#39;x&#39; isnot defined</code>. This can be fixed by providing the full class reference to <code>x</code> as in the following,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">   x = 10</span><br><span class="line">   def __init__(self):</span><br><span class="line">      self.fx = Foo.x**2 # full reference to x</span><br></pre></td></tr></table></figure>
<p>Although, it’s probably best to avoid doing this.</p>
<p>从上面的例子可以看出， 在编写程序的时候， 千万不要把实例属性和类属性使用相同的名字， 因为相同名称的实例属性将屏蔽掉类属性， 但是当你删除实例属性后， 再使用相同的名称， 访问到的将是类属性。</p>
<h3 id="Hashing-hides-parent-variables-from-children"><a href="#Hashing-hides-parent-variables-from-children" class="headerlink" title="Hashing hides parent variables from children"></a>Hashing hides parent variables from children</h3><p>Using double underscores in methods internally hashes the function names.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...    def __init__(self):</span><br><span class="line">...        self.__x=10</span><br><span class="line">...    def count(self):</span><br><span class="line">...        return self.__x*30</span><br></pre></td></tr></table></figure>
<p>Note that the <code>count</code> function utilizes the double underscored variable <code>self.__x</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Goo(Foo): # child with own .__x attribute</span><br><span class="line">...    def __init__(self,x):</span><br><span class="line">...        self.__x=x</span><br><span class="line">&gt;&gt;&gt; g=Goo(11)</span><br><span class="line">&gt;&gt;&gt; print g.count() # won&apos;t work</span><br><span class="line">AttributeError: &apos;Goo&apos; object has no attribute &apos;_Foo__x&apos;</span><br></pre></td></tr></table></figure>
<p>This means that the <code>__x</code> variable in the <code>Foo</code> declaration is attached to the <code>Foo</code> class.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Intro to Python/" data-id="cjd8d3nyi000acuzh646xdohe" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java Generics简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java Generics简介/" class="article-date">
  <time datetime="2018-02-04T05:43:32.212Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Generics-in-Java"><a href="#Generics-in-Java" class="headerlink" title="Generics in Java"></a>Generics in Java</h1><p>** 2017-11-27</p>
<h1 id="Java泛型详解"><a href="#Java泛型详解" class="headerlink" title="Java泛型详解"></a>Java泛型详解</h1><p>Java泛型是jdk1.5 中引入的一个新特性， 泛型提供了编译时的类型检测机制， 该机制允许程序员在编译时检测到非法的类型。 泛型是java中一个非常重要的知识点， 在Java集合类框架中泛型被广泛应用。</p>
<h2 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>我们首先定义一个简单的Box类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line">    private String object;</span><br><span class="line">    public void set(String object) &#123; this.object = object; &#125;</span><br><span class="line">    public String get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最常见的做法， 这样做的一个坏处是Box里面现在只能装入String类型的元素， 今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box， 代码得不到复用， 使用泛型可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt;&#123;</span><br><span class="line">  // T stands for &quot;Type&quot;</span><br><span class="line">  private T t;</span><br><span class="line">  public void set(T t)&#123;</span><br><span class="line">    this.t= t;</span><br><span class="line">  &#125;</span><br><span class="line">  public T get()&#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们的Box类便可以得到复用， 我们可以将T替换成任何我们想要的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();</span><br><span class="line">Box&lt;String&gt; stringBox = new Box&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>看完了泛型类，接下来我们来了解一下泛型方法。 声明一个泛型方法很简单，只要在返回类型前面加上一个类似的形式就行了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Util &#123;</span><br><span class="line">    public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</span><br><span class="line">        return p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pair&lt;K, V&gt; &#123;</span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setKey(K key) &#123; this.key = key; &#125;</span><br><span class="line">    public void setValue(V value) &#123; this.value = value; &#125;</span><br><span class="line">    public K getKey()   &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样去调用泛型方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br></pre></td></tr></table></figure>
<p>或者在Java1.7/1.8 利用type inference, 让java自动推导出相应的类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">boolean same = Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>
<h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h3><p>现在我们要实现这样一个功能， 查找一个泛型数组中大于某个特定元素的个数， 我们可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e &gt; elem)  // compiler error</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样很明显是错误的， 因为除了short, int, double, long, float, byte, char等原始类型， 其他的类并不一定能够使用操作符&gt;, 所以编译器报错， 那怎么解决这个问题呢？ 答案是使用边界符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">  	public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做一个类似于下面这样的声明， 这样就等于告诉编译器类型参数T代表的都是实现了<code>Comparable</code>接口的类， 这样等于告诉编译器它们都至少实现了compareTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e.compareTo(elem) &gt; 0)</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在了解通配符之前， 我们首先要澄清一个概念， 还是借用我们上面定义的Box类， 假设我们添加了一个这样的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void boxTest(Box&lt;Number&gt; n) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure>
<p>那么现在Box n允许接受什么类型的参数？ 我们是否能够传入Box 或者Box呢？ 答案是否定的， 虽然Integer 和Double是Number的子类，但是在泛型中 Box 或者Box与Box之间并没有任何的关系。 这一点非常重要。</p>
<p>下面这个例子中，我们创建了一个泛型类<code>Reader</code>，然后在<code>f1()</code>中当我们尝试<code>Fruit f = fruitReader.readExact(apples);</code>编译器会报错，因为<code>List&lt;Fruit&gt;</code>与<code>List&lt;Apple&gt;</code>之间并没有任何的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Fruit &#123;&#125;</span><br><span class="line">class Apple extends Fruit &#123;&#125;</span><br><span class="line">class Orange extends Fruit &#123;&#125;</span><br><span class="line">public class GenericReading &#123;</span><br><span class="line">    static List&lt;Apple&gt; apples = Arrays.asList(new Apple());</span><br><span class="line">    static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit());</span><br><span class="line">    static class Reader&lt;T&gt; &#123;</span><br><span class="line">        T readExact(List&lt;T&gt; list) &#123;</span><br><span class="line">            return list.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void f1() &#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = new Reader&lt;Fruit&gt;();</span><br><span class="line">        // Errors: List&lt;Fruit&gt; cannot be applied to List&lt;Apple&gt;.</span><br><span class="line">        // Fruit f = fruitReader.readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是按照我们通常的思维习惯， Apple和Fruit之间肯定是存在联系， 然而编译器却无法识别， 那么怎么在泛型代码中解决这个问题呢？ 我们可以通过使用通配符来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class CovariantReader&lt;T&gt; &#123;</span><br><span class="line">    T readCovariant(List&lt;? extends T&gt; list) &#123;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void f2() &#123;</span><br><span class="line">    CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;Fruit&gt;();</span><br><span class="line">    Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">    Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就相当于告诉编译器， fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。</p>
<h3 id="PESC原则"><a href="#PESC原则" class="headerlink" title="PESC原则"></a>PESC原则</h3><p>上面我们看到了类似<code>&lt;? extends T&gt;</code>的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsAndCovariance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Wildcards allow covariance:</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</span><br><span class="line">        // Compile Error: can&apos;t add any type of object:</span><br><span class="line">        // flist.add(new Apple())</span><br><span class="line">        // flist.add(new Orange())</span><br><span class="line">        // flist.add(new Fruit())</span><br><span class="line">        // flist.add(new Object())</span><br><span class="line">        flist.add(null); // Legal but uninteresting</span><br><span class="line">        // We Know that it returns at least Fruit:</span><br><span class="line">        Fruit f = flist.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为<code>List&lt;? extends Fruit&gt; flist</code>它自身可以有多种含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</span><br><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Orange&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们尝试add一个Apple的时候，flist可能指向<code>new ArrayList&lt;Orange&gt;()</code>;</li>
<li>当我们尝试add一个Orange的时候，flist可能指向<code>new ArrayList&lt;Apple&gt;()</code>;</li>
<li>当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。</li>
</ul>
<p>所以对于实现了<code>&lt;? extends T&gt;</code>的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。</p>
<p>如果我们要add元素应该怎么做呢？可以使用<code>&lt;? super T&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWriting &#123;</span><br><span class="line">    static List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();</span><br><span class="line">    static List&lt;Fruit&gt; fruit = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">    static &lt;T&gt; void writeExact(List&lt;T&gt; list, T item) &#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    static void f1() &#123;</span><br><span class="line">        writeExact(apples, new Apple());</span><br><span class="line">        writeExact(fruit, new Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    static &lt;T&gt; void writeWithWildcard(List&lt;? super T&gt; list, T item) &#123;</span><br><span class="line">        list.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    static void f2() &#123;</span><br><span class="line">        writeWithWildcard(apples, new Apple());</span><br><span class="line">        writeWithWildcard(fruit, new Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f1(); f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于<code>List&lt;? super Apple&gt; list</code>，它可以有下面几种含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Apple&gt;();</span><br><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<p>当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。</p>
<p>根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”：</p>
<ul>
<li>“Producer Extends” - 如果你需要一个只读List，用它来produce T，那么使用<code>? extends T</code>。</li>
<li>“Consumer Super” - 如果你需要一个只写List，用它来consume T，那么使用<code>? super T</code>。</li>
<li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li>
</ul>
<p>如何阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class="line">        for (int i=0; i&lt;src.size(); i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java泛型中最令人苦恼的地方或许就是类型擦除了。 类型擦除就是说Java泛型只能用于在编译期间的静态类型检查， 然后编译器生成的 代码会查出相应的类型信息， 这样到了运行期间JVM并不知道泛型所代表的具体类型。</p>
<p>这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。</p>
<p>说了这么多，那么泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public Node(T data, Node&lt;T&gt; next) &#125;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(Object data, Node next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着不管我们声明<code>Node&lt;String&gt;</code>还是<code>Node&lt;Integer&gt;</code>，到了运行期间，JVM统统视为<code>Node&lt;Object&gt;</code>。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译器就会将<code>T</code>出现的地方替换成<code>Comparable</code>而不再是默认的<code>Object</code>了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    private Comparable data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(Comparable data, Node next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Comparable getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的概念或许还是比较好理解，但其实泛型擦除带来的问题远远不止这些，接下来我们系统地来看一下类型擦除所带来的一些问题，有些问题在C++的泛型中可能不会遇见，但是在Java中却需要格外小心。</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在Java中不允许创建泛型数组，类似下面这样的做法编译器会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure>
<p>为什么编译器不支持上面这样的做法呢？继续使用逆向思维，我们站在编译器的角度来考虑这个问题。</p>
<p>我们先来看一下下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure>
<p>对于上面这段代码还是很好理解，字符串数组不能存放整型元素，而且这样的错误往往要等到代码运行的时候才能发现，编译器是无法识别的。接下来我们再来看一下假设Java支持泛型数组的创建会出现什么后果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">// An ArrayStoreException should be thrown, but the runtime can&apos;t detect it.</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道<code>new ArrayList&lt;String&gt;()</code>和<code>new ArrayList&lt;Integer&gt;()</code>的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。</p>
<p>如果你对上面这一点还抱有怀疑的话，可以尝试运行下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ErasedTypeEquivalence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Due to the implementation of Java generics, you can’t have code like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GenSet&lt;E&gt;&#123;</span><br><span class="line">  private E a[];</span><br><span class="line">  public GenSet()&#123;</span><br><span class="line">    a= new E[INITIAL_ARRAY_LENGTH];// error: generic array creation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How can implement this while maintaining type safety?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">class Stack&lt;T&gt; &#123;</span><br><span class="line">    public Stack(Class&lt;T&gt; clazz, int capacity) &#123;</span><br><span class="line">        array = (T[])Array.newInstance(clazz, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final T[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/529085/how-to-create-a-generic-array-in-java" target="_blank" rel="noopener">How to create a generic array in Java?</a></p>
<p>You can always do this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[] arr= (E[]) new Object[INITIAL_ARRAY_LENGTH]</span><br></pre></td></tr></table></figure>
<p>This is one of the suggested ways of implementing a generic collection in <em>Effective Java; Item 26</em>. No type errors, no need to cast the array repeatedly. <em>However</em> this triggers a warning because it is potentially dangerous, and should be used with caution. As detailed in the comments, this <code>Object[]</code> is now masquerading as our <code>E[]</code> type, and can cause unexpected errors or <code>ClassCastException</code>s if used unsafely.</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>继续复用我们上面的<code>Node</code>的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出<code>ClassCastException</code>异常，提示String无法转换成Integer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn; // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;); // Causes a ClassCastException to be thrown.</span><br><span class="line">// Integer x = mn.data;</span><br></pre></td></tr></table></figure>
<p>如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在<code>setData(String data)</code>方法，所以只能调用父类Node的<code>setData(Object data)</code>方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那<code>ClassCastException</code>到底是怎么抛出的？</p>
<p>实际上Java编译器对上面代码自动还做了一个处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就是为什么上面会报错的原因了，<code>setData((Integer) data);</code>的时候String无法转换成Integer。所以上面第2行编译器提示<code>unchecked warning</code>的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上<code>Node&lt;Integer&gt; n = mn</code>就好了，这样编译器就可以提前帮我们发现错误。</p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure>
<p>实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。</p>
<h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>我们无法对泛型代码直接使用<code>instanceof</code>关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>的之间的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=&gt; &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;, LinkedList&lt;Character&gt;, ... &#125;</span><br></pre></td></tr></table></figure>
<p>和上面一样，我们可以使用通配符重新设置bounds来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="To-be-Read"><a href="#To-be-Read" class="headerlink" title="To be Read:"></a>To be Read:</h2><p><a href="http://blog.csdn.net/qq_27093465/article/details/73229016" target="_blank" rel="noopener">More about generics</a>;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>见下：</p>
<p><a href="http://lic128.me/2017/11/27/Generics-in-Java/generics.jpg" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/27/Generics-in-Java/generics.jpg" alt="img"></a></p>
<h3 id="StackOverflow"><a href="#StackOverflow" class="headerlink" title="StackOverflow"></a>StackOverflow</h3><p>I‘ve encountered a problem while doing a homework for online algorithms class. Casting Object[] to T[] where T is Comparable raises a run-time exception</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] xs)&#123;</span><br><span class="line">    T[] aux= (T[]) new Object[xs.length];</span><br><span class="line">  	mergeSort(xs, aux, 0, xs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In java, generic types don’t exist at runtime They are only a convenience to enable better compile time type checking. During compilation, generics are replaced by a real type in a process known as type erasure.</p>
<p>Normally, the erasure of a generic type is Object, but since you provided an upper bound for T, it is converted to that bound, Comparable, Therefore, after erasure, your code looks like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable[] aux=(Comparable[]) new Object[xs.length];</span><br></pre></td></tr></table></figure>
<p>In otherwords, you’re creating an array of type Object[] and immediately trying to cast it to type Comparable[]. Since Object doesn’t implement Comparable, the types are incompatible, so you get a runtime exception. You can fix this by creating an array of Comparable instead;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] xs)&#123;</span><br><span class="line">    T[] aux= (T[]) new Comparable[xs.length];</span><br><span class="line">  	mergeSort(xs, aux, 0, xs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java Generics简介/" data-id="cjd8d3ny70004cuzhjx8v34mw" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java中HashMap的实现机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java中HashMap的实现机制/" class="article-date">
  <time datetime="2018-02-04T05:43:32.200Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="The-implementation-of-HashMap-in-Java"><a href="#The-implementation-of-HashMap-in-Java" class="headerlink" title="The implementation of HashMap in Java"></a>The implementation of HashMap in Java</h1><p><strong> 2017-11-20 | </strong> <a href="http://lic128.me/categories/Java/" target="_blank" rel="noopener">Java</a></p>
<h2 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h2><h2 id="Java-HashMap-源码阅读"><a href="#Java-HashMap-源码阅读" class="headerlink" title="Java HashMap 源码阅读"></a>Java HashMap 源码阅读</h2><p><a href="http://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="noopener">Java 源码阅读</a></p>
<p>HashMap是基于哈希表的Map接口的非同步实现。 此实现提供所有可选的映射操作， 并允许使用null值和null键。 此类不保证映射的顺序， 特别是它不保证该顺序恒久不变。</p>
<p><em>HashMap与HashTable的主要区别</em></p>
<p><em>他们的主要区别其实就是Table加了线程同步保护</em></p>
<ul>
<li>Hashtable线程更加安全， 代价就是因为它粗暴的添加了同步锁， 所以会有性能损失。</li>
<li>其实有更好的concurrentHashMap可以代替HashTable</li>
</ul>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>在Java编程语言中， 最基本的结构就是两种， 一种是数组， 另外一个是指针（引用）， HashMap就是通过这两个数据结构进行实现。 HashMap实际上是一个“链表散列” 的数据结构， 即数组和链表的结合体。</p>
<p>观察这种结构， 我们可以发现， 失败的hashCode算法会导致hashMap的性能下降为链表（这叫做链地址处理冲突）， 所以想要避免发生碰撞， 就要提高hashCode结果的均匀性。 当然， 在JDK8中， 采用了红黑二叉树进行了处理。</p>
<p><em>什么是Hash攻击？</em></p>
<p><em>通过请求大量key不同，但是hashCode相同的数据， 让HashMap不断发生碰撞， 硬生生的变成了SingleLinkedList， 这样put/get性能就从O（1）变成了O（N), CPU负载呈直线上升， 行成了放大版DDOS的效果， 这种方式就叫做hash攻击，在java8 中通过使用TreeMap, 提升了处理性能， 可以一定程度的防御hash攻击。</em></p>
<p><a href="http://lic128.me/2017/11/20/The-implementation-of-HashMap-in-Java/Structure.jpg" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/20/The-implementation-of-HashMap-in-Java/Structure.jpg" alt="img"></a></p>
<p>每个元素存储的是一个链表的头节点。 那么这些元素是按照怎么样的规则存储到数组中呢？ 一般情况是通过hash（key）%len获得， 也就是元素的key的哈希值对数组长度取模得到。</p>
<p>HashMap里面实现一个静态内部类Entry，其重要的属性有key， value， next。 我们上面说到HashMap的基础就是一个线性数组， 这个数组就是Entry[],， Map里面的内容都保存在Entry[]里面。</p>
<h2 id="HashMap的初始化过程"><a href="#HashMap的初始化过程" class="headerlink" title="HashMap的初始化过程"></a>HashMap的初始化过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public HashMap&lt;Map&lt;? extends K, ? extends V&gt; m&gt;&#123;</span><br><span class="line">    this(Math.max((int)(m.size()/DEFAULT_LOAD_FACTOR)+1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">  inflateTable(threadshold);</span><br><span class="line">  putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>DEFAULT_LOAD_FACTOR</em>: 负载因子的默认值0.75表示数据填充的临界值， 即数据达到总数据的75%时就开始准备扩容了。</p>
<p><em>DEFAULT_INITIAL_CAPACITY</em>: 默认传入Map中的数据默认值为4， 从上面看出， 显示调用自己的构造方法， 然后创建存储的Table（实际是数组）， 最后把值添加到创建的table中。</p>
<h3 id="this-var1-var2-实际调用的构造方法"><a href="#this-var1-var2-实际调用的构造方法" class="headerlink" title="this(var1, var2)实际调用的构造方法"></a>this(var1, var2)实际调用的构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadfactor)&#123;</span><br><span class="line">  if(initalCapacity&lt;0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;+ initialCapacity);</span><br><span class="line">  if(initialCapacity&gt;MAXIMUN_CAPACITY)&#123;</span><br><span class="line">    initialCapacity=MAXIMUM_CAPACITY;</span><br><span class="line">  &#125;else if(initialCapacity&lt;DEFAULT_INITILA_CAPACITY)&#123;</span><br><span class="line">    initialCapacity=DEFAULT_INITIAL_CAPACTITY;</span><br><span class="line">  &#125;</span><br><span class="line">  if(loadFactor&lt;=0 || Float.isNAN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor:&quot;+ loadFactor);</span><br><span class="line">  threadshold= initialCapacity;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initialCapacity</code> : 即初始化申请空间的值,不等于Map实际初始化的内部数组的长度(稍后解释为什么)==,若不填写默认是<code>DEFAULT_INITIAL_CAPACITY</code>也就是4<br><code>initialCapacity</code>的最大值为1 &lt;&lt; 30 也就是2^30次方<br><code>initialCapacity</code>的最小值为DEFAULT_INITIAL_CAPACITY也就是4.</p>
<p><code>loadFactor</code>: 负载因子的初始化值， 若不填写默认问DEFAULT_LOAD_FACTOR也就是0.75</p>
<p><code>threadshold</code>： 下次扩容时的申请空间值。</p>
<h3 id="inflate-Table-方法"><a href="#inflate-Table-方法" class="headerlink" title="inflate Table 方法"></a>inflate Table 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inflates the table.</span><br><span class="line"> */</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    // Find a power of 2 &gt;= toSize</span><br><span class="line">    int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    // Android-changed: Replace usage of Math.min() here because this method is</span><br><span class="line">    // called from the &lt;clinit&gt; of runtime, at which point the native libraries</span><br><span class="line">    // needed by Float.* might not be loaded.</span><br><span class="line">    float thresholdFloat = capacity * loadFactor;</span><br><span class="line">    if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123;</span><br><span class="line">        thresholdFloat = MAXIMUM_CAPACITY + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = (int) thresholdFloat;</span><br><span class="line">    table = new HashMapEntry[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有个重点， 实际申请的内部数组的大小 <code>int capacity= roundUpToPowerOf2(toSize);</code></p>
<p>当数组长度为2^n的时候， 不同的key算得得index相同的几率较小， 那么数据在数组上分布就比较均匀， 也就是说碰撞的几率小， 相对的， 查询的时候就不用遍历某个位置上的链表， 这样查询效率也就较高了。</p>
<h3 id="putAllCreate方法"><a href="#putAllCreate方法" class="headerlink" title="putAllCreate方法"></a>putAllCreate方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void putAllCreate(Map&lt;? extends K, ? extends V&gt; m)&#123;</span><br><span class="line">    for(Map.Entry&lt;? extends K, ? extends V&gt; e: m.entrySet())</span><br><span class="line">      putFOrCreate(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个foreach循环， 将m中的数据拿出来一一添加到map， 下面看具体的putForCreate 方法</p>
<h3 id="putForCreate-方法"><a href="#putForCreate-方法" class="headerlink" title="putForCreate 方法"></a>putForCreate 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void putForCreate(K key, V value)&#123;</span><br><span class="line">  int hash= null==key? 0: sum,sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">  int i= indexFor(hash, table.length);</span><br><span class="line">  for(HashMapEntry&lt;K, V&gt; e= table[i]; e!=null; e=e.next)&#123;</span><br><span class="line">      Object k;</span><br><span class="line">    if(e.hash==hash &amp;&amp; ((k==e.key)==key || (key!=null &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">        e.value= value;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>计算key的hash值</li>
<li>计算数组下标按位取并， 作用上相当于取模mod或者取余%。 这意味着数组下标相同，并不表示hashCode相同。</li>
<li>在对应的key上赋值或者添加一组map。</li>
</ol>
<h3 id="存储数据，-Put方法"><a href="#存储数据，-Put方法" class="headerlink" title="存储数据， Put方法"></a>存储数据， Put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">      if (table == EMPTY_TABLE) &#123;</span><br><span class="line">          inflateTable(threshold);</span><br><span class="line">      &#125;</span><br><span class="line">      if (key == null)</span><br><span class="line">          return putForNullKey(value);</span><br><span class="line">      int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">      int i = indexFor(hash, table.length);</span><br><span class="line">      for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">          Object k;</span><br><span class="line">          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              e.value = value;</span><br><span class="line">              e.recordAccess(this);</span><br><span class="line">              return oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      modCount++;</span><br><span class="line">      addEntry(hash, key, value, i);</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源代码中可以看出</p>
<ol>
<li>Map支持key=null；HashMap会将Key为null组成的Entry<code>&lt;null, value&gt;</code>放置到table[0], 即第一个桶中。在get和put中， 对其进行特殊处理。</li>
<li>当我们往HashMap中put元素的时候， 先根据key的hashCode重新计算hash值， 根据hash值得到这个元素在数组中的位置， 即下标， 如果该数组上已经存放有其他元素了， 那么在这个位置上的元素将以链表的形式存放， 新加入的放在链头， 最先加入的放在链尾。 如果数组该位置上没有元素， 就直接把该元素放在该数组中的该位置上。</li>
</ol>
<p>对于给定的Key， Value, 判断该Key是否与Entry链表中有某一个Entry对象的key值相等时用的是<code>(k=e.key)==key ||key.equals(k)</code>， 另外还有一个判断条件： 即Key经过hash函数转换后的hash值和当前Entry对象的hash属性值相等.</p>
<p>上面的情况我们可以总结为： HashMap在确定Key是否在HashMap中存在的要求有两个：</p>
<ol>
<li>Key值是否相等；</li>
<li>hashcode是否相等；</li>
</ol>
<p>所以我们在定义类时， 如果重写了equals()方法， 但是hashcode却没有保证相等， 就会导致当使用该类实例作为key值放入HashMap中时， 会出现HashMap“工作异常”的问题， 会出现你不希望的情况。</p>
<h4 id="addEntry方法"><a href="#addEntry方法" class="headerlink" title="addEntry方法"></a>addEntry方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储HashMap中的key-value对时， 完全没有考虑Entry中的value， 仅仅只是根据key来计算并决定每个Entry的存储位置。 我们完全可以把Map集合中的value当成key的附属， 当系统决定key的存储位置之后， value随之保存在那里即可。</p>
<p>HashMap的get和put方法实现基本相同， 归纳起来简单地说，HashMap在底层将key-value当成一个整体进行处理， 这个整体就是一个Entry对象。 HashMap底层采用一个Entry[] 数组来保存所有的key-value对， 当需要存储一个Entry对象时， 会根据hash算法来决定其在数组中的存储位置， 再根据equals方法决定其再数组位置上的链表的存储位置； 当需要取出一个Entry时， 也会根据hash算法找到其再数组中的存储位置， 再根据equals方法从该位置上的链表中取出该Entry。</p>
<h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     void resize(int newCapacity) &#123;</span><br><span class="line">       HashMapEntry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">        //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">//根据传入参数的长度定义新的数组</span><br><span class="line">       HashMapEntry[] newTable = new HashMapEntry[newCapacity];</span><br><span class="line">       //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">       transfer(newTable);</span><br><span class="line">       table = newTable;</span><br><span class="line">         //更新临界值</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>旧数组的数据转到新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  void transfer(HashMapEntry[] newTable) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。<br>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">           expectedModCount = modCount;</span><br><span class="line">           if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">               HashMapEntry[] t = table;</span><br><span class="line">               while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">                   ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>　　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）</p>
<p>　在HashMap的API中指出：<br>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。<br>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误.</p>
<h3 id="JDK8-中HashMap的新特性"><a href="#JDK8-中HashMap的新特性" class="headerlink" title="JDK8 中HashMap的新特性"></a>JDK8 中HashMap的新特性</h3><p>如果某个桶的链表记录过大的话（当前是TREEIFY_THRESHOLD=8）， 就会把这个链动态变成红黑二叉树， 使查询最差复杂度由O（n）变成了O（logN）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">    if ((e = p.next) == null) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, null);</span><br><span class="line">        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        break;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附录：-常见哈希算法"><a href="#附录：-常见哈希算法" class="headerlink" title="附录： 常见哈希算法"></a>附录： 常见哈希算法</h3><p>下面给出几个常用的哈希码的算法。</p>
<ol>
<li>Object类的hashcode返回对象的内存地址经过处理后的结构， 由于每个对象的内存地址都不一样， 所以哈希码也不一样。 这个时native方法， 这个取决于JVM的设计， 一般是某种地址的偏移。</li>
<li>String类的hashCode。 根据String类包含的字符串的内容， 根据一种特殊算法返回哈希码， 只要字符串的内容相同， 返回的哈希码也相同。</li>
<li>Integer等包装类， 返回的哈希码就是Integer对象里面所包含的那个整数的数值， 由此可见， 2个一样的Integer对象， 返回的哈希码也一样。</li>
</ol>
<h3 id="附录，-在笔试中的使用"><a href="#附录，-在笔试中的使用" class="headerlink" title="附录， 在笔试中的使用"></a>附录， 在笔试中的使用</h3><h4 id="查重与分组问题"><a href="#查重与分组问题" class="headerlink" title="查重与分组问题"></a>查重与分组问题</h4><p>某公司正在做一个寻找走失儿童的公益项目，现在有一个函数，可以输入两个图片，并返回这个儿童是否重复。请你设计一个系统，帮助他们寻找儿童。</p>
<ol>
<li>网友可以同时上传一批图片</li>
<li>系统能够把所有图片分类并归为一组</li>
<li>网友上传图片后，网页要尽快返回该照片所在的组。</li>
</ol>
<p>A：假设你现在有一个机器，请写出你的数据结构与处理流程，设计的思路。<br>B：如果你有多台机器，如果缩短请求的时间？</p>
<p><strong>Answer：</strong></p>
<p>我们可以把它分解成两个部分， 一个是数据结构一个是上传流程</p>
<ol>
<li>对于数据结构来说， 一个是对儿童信息进行包装， 另一个是实现儿童信息的高效查找。 对于儿童信息包装类来说， 除了加入儿童的图片， 姓名， 生日等基本信息外， 特别要注意重写equals与hashCode， 这个equals就是题目所说的比较函数。 对于查找的实现来说， 首先我们建立一个HashSet， 用于存储儿童信息。 网友上传后， 服务器通过对图像计算出特征Hash值， 并查Hash表， 如果HashCode相同， 则返回所在的组； 如果不相同， 就加入hash表中。</li>
<li>对于多图上传问题， 使用生产者-消费者阻塞队列就可以实现尽快的依次返回照片所在的组。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.jianshu.com/p/8d2d1c4779eb" target="_blank" rel="noopener">HashMap的实现原理</a></li>
<li><a href="http://www.importnew.com/21294.html" target="_blank" rel="noopener">HashMap的实现与优化</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/41576373" target="_blank" rel="noopener">HashMap的设计原理和实现分析</a></li>
<li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK源码中HashMap的hash方法原理时什么？(To be read)</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~hsinmu/courses/_media/dsa_12spring/hashing.pdf" target="_blank" rel="noopener">HashMap</a></li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如何解决Collision：</p>
<ol>
<li><p>Chaining： 使用Linked list 把 hashing到同一个slot的value串起来。这个我们上面已经很详细地介绍过了。</p>
</li>
<li><p>Open Addressing， 使用Probing Method 来寻找Table中空的slot存放资料。</p>
<p>当hash Function 把具有不同Key的资料分配到同一个slot时， 继续寻找下一个空的slot， 直到找到或者所有slot都满了为止。</p>
<p>这种寻找下一格空的slot的方式就称为Probing。</p>
</li>
</ol>
<h4 id="Probing"><a href="#Probing" class="headerlink" title="Probing"></a>Probing</h4><p>Probing就是寻找下一个空的slot， 如果没找到， 就要继续往下找， 因此Probing的精髓就是要制造出往下找的顺序， 这个顺序尽可能越不规则越好， 如此可以确保Hash Function不会一直找到同一个slot。</p>
<p>可以想象的是， 如果对于所有item都只有一种Probing顺序， 那么在加入第一个item时， 只需要O(1)的时间， 但是再继续加入item时， 就必须考虑现有的item数， 也就是说， 其复杂度随着item上升儿上升。</p>
<p>常见的Probing method</p>
<ol>
<li>Linear probing</li>
<li>Quadratic probing</li>
<li>Double hashing</li>
</ol>
<p>特别注意， probing的hash function 与chaining 的hash function 略有不同（虽然都称为Hash Function):</p>
<ul>
<li>Chaining 使用的hash function 只有一个参数， 就是资料的key。</li>
<li>Open Addressing 使用的hash function有两个参数， 一个时资料的key，另一个是probing的次数。</li>
</ul>
<p>基本的hash函数：</p>
<ol>
<li><p>Division Method: m有限制， 但是比较快。</p>
<p>相当于直接做余数运算。</p>
<ul>
<li>优点： 速度快， 只需要做一次余数运算即可。</li>
<li>缺点： 较为理想的Table大小m是距离2^n够远的质数， 像是701. 换句话说， Table大小m必须慎选。例如， 要尽量避免2的指数， 否则就只有最低的p-bit会影响Hash Function.</li>
</ul>
</li>
<li><p>Multiplication Method： m没有限制， 但是比较慢, 各种奇怪的hash算法。</p>
</li>
</ol>
<p>Simple Implementation of HashMap in Java.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class myHashMap &#123;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private String key;</span><br><span class="line">        private String value;</span><br><span class="line">        private Node next;</span><br><span class="line">        public Node()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public Node(String key, String value)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">            this.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getKey()&#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setKey(String key)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getValue()&#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setValue(String value)&#123;</span><br><span class="line">            this.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node getNext()&#123;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setNext(Node next)&#123;</span><br><span class="line">            this.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int BUCKET_ARRAY_SIZE= 256;</span><br><span class="line">    private Node bucketArray[]= new Node[BUCKET_ARRAY_SIZE];</span><br><span class="line">    public myHashMap(int initialSize)&#123;</span><br><span class="line">        this.BUCKET_ARRAY_SIZE= initialSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String key, String value)&#123;</span><br><span class="line">        int hash= Math.abs(key.hashCode()%BUCKET_ARRAY_SIZE);</span><br><span class="line">        Node entry= new Node(key, value);</span><br><span class="line">        if(bucketArray[hash]== null)&#123;</span><br><span class="line">            bucketArray[hash]= entry;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node current= bucketArray[hash];</span><br><span class="line">            while(current.next!= null)&#123;</span><br><span class="line">                if(current.getKey().equals(entry.getKey()))&#123;</span><br><span class="line">                    current.setValue(entry.getValue());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                current= current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next= entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String get(String Key)&#123;</span><br><span class="line">        int hash= Math.abs(Key.hashCode()%BUCKET_ARRAY_SIZE);</span><br><span class="line">        Node n= bucketArray[hash];</span><br><span class="line">        while(n!= null)&#123;</span><br><span class="line">            if(n.getKey().equals(Key))&#123;</span><br><span class="line">                return n.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            n= n.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals-and-hashCode"><a href="#equals-and-hashCode" class="headerlink" title="equals() and hashCode()"></a>equals() and hashCode()</h3><p>As you know this method priovides the hashcode of an object, Basically the default implementation of hashCode() provided by Object is derived by mapping the memory address to an integer value. If look into the source of Object class, you will find the following code for the hashCode. public native int hashCode(); It indicates that hashCode is the native implementation which provides the memory address to a certain content. However it is possible to override the hashCode method in your implementation class.</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>This particular method is used to make equal comparison between two objects.</p>
<p>This particular method is used to make equal comparison between two objects. There are two types of comparisons in Java. One is using “= =” operator and another is “equals()”. I hope that you know the difference between this two. More specifically the “.equals()” refers to equivalence relations. So in broad sense you say that two objects are equivalent they satisfy the “equals()” condition. If you look into the source code of Object class you will find the following code for the equals() method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) </span><br><span class="line">&#123;</span><br><span class="line">	return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now I will explain you when to override the equals() and hashCode() methods and why it is necessary to override these methods. In this regard there is a rule of thumb that if you are going to override the one of the methods( ie equals() and hashCode() ) , you have to override the both otherwise it is a violation of contract made for equals() and hashCode(). Please refer to the Sun’s java docs for the method’s contract. I provide some test case scenario where you will find the significance of these methods. Case-1: You can override the hashCode method in your own way. Please refer to the following example.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above example class “Emp” the variable age is the significant factor. Here the hashCode value will return the age of the person. Now let us consider the following test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;emp1.hashCode()---&gt;&gt;&gt;&quot;+emp1.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you run the above program, the output will be the age what you have given i.e. 23. Now question arises whether there is any way we can get the original hashCode(). We can say that if we do not override the hashCode() method what could have been the hashCode of this object. However please do not feel depressed, Java provide another approach even if you have overridden the hashCode() method , still you can get the original hashCode of a particular class. Now run the following test harness program.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;Overridden hashCode()---&gt;&gt;&gt;&quot;+emp1.hashCode());</span><br><span class="line">		int originalHashCode = System.identityHashCode(emp1);</span><br><span class="line">		System.out.println(&quot;Original hashCode of Emp----&gt;&gt;&gt;&quot;+originalHashCode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here the output will be like this Overridden hashCode()—&gt;&gt;&gt;23 Original hashCode of Emp—-&gt;&gt;&gt;8567361 As you know the above number is arbitrary, it depends upon your system. So then why it is necessary to override this method. There is one reason that if want to compare two objects based upon the equals() method. Although in a very simple class like “Emp”, you can achieve without overriding hashCode() method. But if you do this , you are going to violate the contract for the methods hashCode() and hashCode() of the object class. The similar case is for the method equals(). So funcational point is that if want to compare two objects based upon the equals() method you have to override both hashCode() and equals() methods. Please have look into the Emp class with the overridden methods and the related test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean equals( Object obj )</span><br><span class="line">	&#123;</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		Emp emp = ( Emp )obj;</span><br><span class="line">		if( emp.age == age )</span><br><span class="line">			flag = true;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The related test harness class is given below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		Emp emp2 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;emp1.equals(emp2)---&gt;&gt;&gt;&quot;+emp1.equals(emp2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Case- 2 Think of a test scenario where you want to store your objects in a HasSet and you want to find a particular object. First let us see if we do not override the methods and we want to store the objects in the HashSet. Let us analyse the impact of it from the following code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above code it is a normal class. Now let us see the test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		Emp emp2 = new Emp(24);</span><br><span class="line">		Emp emp3 = new Emp(25);</span><br><span class="line">		Emp emp4 = new Emp(26);</span><br><span class="line">		Emp emp5 = new Emp(27);</span><br><span class="line">		HashSet&lt;Emp&gt; hs = new HashSet&lt;Emp&gt;();</span><br><span class="line">		hs.add(emp1);</span><br><span class="line">		hs.add(emp2);</span><br><span class="line">		hs.add(emp3);</span><br><span class="line">		hs.add(emp4);</span><br><span class="line">		hs.add(emp5);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;HashSet Size---&gt;&gt;&gt;&quot;+hs.size());</span><br><span class="line">		System.out.println(&quot;hs.contains( new Emp(25))---&gt;&gt;&gt;&quot;+hs.contains(new Emp(25)));</span><br><span class="line">		System.out.println(&quot;hs.remove( new Emp(24)---&gt;&gt;&gt;&quot;+hs.remove( new Emp(24));</span><br><span class="line">		System.out.println(&quot;Now HashSet Size---&gt;&gt;&gt;&quot;+hs.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you run the above program, the will output will be like the following. HashSet Size—&gt;&gt;&gt;5 hs.contains( new Emp(25))—&gt;&gt;&gt;false hs.remove( new Emp(24)—&gt;&gt;&gt;false Now HashSet Size—&gt;&gt;&gt;5 It means that you can not find the object. However it is not the case for Integer object. You can put object of type Integer in a HashSet and you can try and you can see the effect. Now let us modify the “Emp” class so that we will get over the problems what we faced in the above test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean equals( Object obj )</span><br><span class="line">	&#123;</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		Emp emp = ( Emp )obj;</span><br><span class="line">		if( emp.age == age )</span><br><span class="line">			flag = true;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here in the above class, we have overridden the hashCode() and equals() methods. Now if you run the same test harness class, you will get the desired output like the following. HashSet Size—&gt;&gt;&gt;5 hs.contains( new Emp(25))—&gt;&gt;&gt;true hs.remove( new Emp(24))—&gt;&gt;&gt;true Now HashSet Size—&gt;&gt;&gt;4 Case – 3 In this case you want to use your object as key not the value in the HashMap. So you have to override both the methods hashCode() and equals(). However it is left to the reader to create the object and test the feature in a Map. Case-4 If want to make your own immutable object , it will be wiser to override the equals() and hashCode() methods. To test the above programs, please create the appropriate package as mentioned in the program. You can also create your own package and modify the package name in the above programs. You can all the code in your favorable java editor.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java中HashMap的实现机制/" data-id="cjd8d3ny90005cuzhs4j6z5ni" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java线程简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java线程简介/" class="article-date">
  <time datetime="2018-02-04T05:43:32.184Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Concurrent-Java"><a href="#Concurrent-Java" class="headerlink" title="Concurrent Java"></a>Concurrent Java</h1><p>** 2018-01-08</p>
<h2 id="线程的两种创建方式以及优劣比较"><a href="#线程的两种创建方式以及优劣比较" class="headerlink" title="线程的两种创建方式以及优劣比较"></a>线程的两种创建方式以及优劣比较</h2><ol>
<li><p>通过实现Runnable 接口线程创建</p>
<ul>
<li>定义一个类实现Runnable接口， 重写接口中的run()方法。 在run()方法中加入具体的任务代码或者处理逻辑。</li>
<li>创建Runnable接口实现类的对象。</li>
<li>创建一个Thread类的对象， 需要封装前面Runnable接口实现类的对象。(接口可以实现多继承)</li>
<li>调用Thread对象的start()方法， 启动线程。</li>
</ul>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo1 implements Runnable&#123;</span><br><span class="line">    private int countDown=10;</span><br><span class="line">  @Override</span><br><span class="line">  public void run()&#123;</span><br><span class="line">      while(countDown--&gt;10)&#123;</span><br><span class="line">          System.out.println(&quot;#&quot;+ Thread.currentThread().getName()+ &quot;(&quot;+ countDown+&quot;)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      //Runnable中run方法是一个空方法， 并不会产生任何线程行为， 必须显式地将一个任务附着到现呈上。</span><br><span class="line">    ThreadDemo1 tt= new ThreadDemo1();</span><br><span class="line">    new Thread(tt).start();</span><br><span class="line">    new Thread(tt).start();</span><br><span class="line">    System.out.println(&quot;Counting Down:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法共享countDown， 所以结果的输出只有十行。</p>
</li>
<li><p>通过继承Thread类创建线程。</p>
<ul>
<li>首先定义一个类去继承Thread父类， 重写父类中的run()方法。 在run()方法中加入具体的任务代码或处理逻辑。</li>
<li>直接创建一个ThreadDemo类的对象， 也可以利用多态性，变量声明为父类的类型。</li>
<li>调用start方法， 线程t启动， 隐含的调用run()方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo extends Thread&#123;</span><br><span class="line">    private int countDown=10;</span><br><span class="line">  	@Override</span><br><span class="line">  	public void run()&#123;</span><br><span class="line">		while(countDown--&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+ this.getName()+&quot;(&quot;+ countDown+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	public static void main(String[] args)&#123;</span><br><span class="line">        new ThreadDemo2().start();</span><br><span class="line">      new ThreadDemo2().start();</span><br><span class="line">      System.out.println(&quot;Counting down:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会输出20行。 因为变量并不共享。</p>
</li>
<li><p>两种方式的比较。</p>
<p>同样是创建了两个线程， 为什么结果不一样呢？</p>
<p>使用实现Runnable接口方式创建线程可以共享同一个目标对象(ThreadDemo 1 tt= new ThreadDemo1();), 实现了多个线程可以处理同一份资源。</p>
<p>然后再看一段来自JDK的解释：</p>
<p>Runnable接口应该由哪些通过某一线程执行其实例的类来实现。 类必须定义一个称为run的无参数方法。</p>
<p>设计该接口的目的是为希望再活动时执行代码的对象提供一个公共协议。 例如， Thread类实现了Runnable。 激活的意思是说某个线程已启动并且尚未停止。</p>
<p>此外， Runnable为非Thread子类的类提供了一种激活方式。 通过实例化某个Thread实例并将自身作为运行目标， 就可以运行实现Runnable的类而无须创建Thread的子类。 大多数情况下， 如果指向重写run()方法， 而不重写其他Thread方法， 那么应该使用Runnable接口。 这很重要， 因为除非程序员打算修改或增强类的基本行为， 否则不应为该类创建子类。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java线程简介/" data-id="cjd8d3ny30002cuzhuh0zradw" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java里面的生产者-消费者模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java里面的生产者-消费者模型/" class="article-date">
  <time datetime="2018-02-04T05:43:32.172Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Producer-Consumer-in-Java"><a href="#Producer-Consumer-in-Java" class="headerlink" title="Producer-Consumer in Java"></a>Producer-Consumer in Java</h1><p>** 2018-01-09</p>
<h1 id="Java-里的生产者-消费者模型-Producer-and-Consumer"><a href="#Java-里的生产者-消费者模型-Producer-and-Consumer" class="headerlink" title="Java 里的生产者-消费者模型(Producer and Consumer)"></a>Java 里的生产者-消费者模型(Producer and Consumer)</h1><p>生产者-消费者模型是多线程问题里面的经典问题， 也是面试的常见问题。 有如下几个常见的实现方法：</p>
<ol>
<li>wait()/notify()</li>
<li>lock &amp; condition</li>
<li>Blocking Queue</li>
</ol>
<p>下面来逐一分析：</p>
<ol>
<li><p>wait()/notify()</p>
<p>第一种实现， 利用根类Object的两个方法wait()/notify(), 来停止或者唤醒线程的执行； 这也是最原始的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyBroker&lt;T&gt; implements Brocker&lt;T&gt;&#123;</span><br><span class="line">    private final Object[] items;</span><br><span class="line">  	private int takeIndex;</span><br><span class="line">  	private int putIndex;</span><br><span class="line">  	private int count;</span><br><span class="line">  	public WaitNotifyBroker(int capacity)&#123;</span><br><span class="line">        this.items= new Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">  	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  	@Override </span><br><span class="line">  	public T take()&#123;</span><br><span class="line">        T tmpObj= null;</span><br><span class="line">      	try&#123;</span><br><span class="line">            synchronized(items)&#123;</span><br><span class="line">                while(0==count)&#123;</span><br><span class="line">                    items.wait();</span><br><span class="line">                &#125;</span><br><span class="line">              	tmpObj= (T) items[takeIndex];</span><br><span class="line">              if(++Index==items.length)&#123;</span><br><span class="line">                  takeIndex=0;</span><br><span class="line">              &#125;</span><br><span class="line">              count--;</span><br><span class="line">              items.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      	return tmpObj&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void put(T obj)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            synchronized(items)&#123;</span><br><span class="line">                while(items.length==count)&#123;</span><br><span class="line">                    items.wait();</span><br><span class="line">                &#125;</span><br><span class="line">              	items[putIndex]= obj;</span><br><span class="line">              	if(++putIndex==items.length)&#123;</span><br><span class="line">                    putIndex=0;</span><br><span class="line">                &#125;</span><br><span class="line">              	count++;</span><br><span class="line">              	items.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用Array构造一个Buffer去存取数据， 并利用count， putIndex和 takeIndex来保证FIrst-In-First-Out。</p>
<p>如果利用LinkedList 来代替Array， 相对来说会稍微简单些。</p>
<p>LinkedList的实现， 可以参考《Java 7 Concurrency Cookbook》第二章 wait/notify;</p>
</li>
<li><p>lock &amp; condition</p>
<p>lock &amp; condition， 实际上也实现了类似synchronized和wait()/notify()的功能， 但是在加锁和解锁， 暂停和唤醒方面， 更加细腻和可控。</p>
<p>在JDK的BlockingQueue的默认实现里， 也是利用了lock &amp; condition。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class LockConditionBroker&lt;T&gt; implements Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    private final int capacity;</span><br><span class="line">    private LinkedList&lt;T&gt; items;</span><br><span class="line"></span><br><span class="line">    public LockConditionBroker(int capacity) &#123;</span><br><span class="line">        this.lock = new ReentrantLock();</span><br><span class="line">        this.notFull = lock.newCondition();</span><br><span class="line">        this.notEmpty = lock.newCondition();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        items = new LinkedList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        T tmpObj = null;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (items.size() == 0) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmpObj = items.poll();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return tmpObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(T obj) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (items.size() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            items.offer(obj);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BlockingQueue</p>
<p>最后这种方法， 也是最简单最值得推荐的， 利用冰法并发包提供的工具： 阻塞队列， 将阻塞的逻辑交给BlockingQueue， 实际上， 上述1 和2 的方法实现的Broker类， 也可以视为一种简单的阻塞队列， 不过没有标准包那么完善。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueueBroker&lt;T&gt; implements Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final BlockingQueue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">    public BlockingQueueBroker() &#123;</span><br><span class="line">        this.queue = new LinkedBlockingQueue&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return queue.take();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(T obj) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.put(obj);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来， 就是一个1P2C的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T take();</span><br><span class="line"></span><br><span class="line">    void put(T obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public class Producer implements Runnable {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private final Broker&lt;Integer&gt; broker;</span><br><span class="line">private final String name;</span><br><span class="line"></span><br><span class="line">public Producer(Broker&lt;Integer&gt; broker, String name) &#123;</span><br><span class="line">    this.broker = broker;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            broker.put(i);</span><br><span class="line">            System.out.format(&quot;%s produced: %s%n&quot;, name, i);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        broker.put(-1);</span><br><span class="line">        System.out.println(&quot;produced termination signal&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
</li>
</ol>
<p>public class Consumer implements Runnable {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final Broker&lt;Integer&gt; broker;</span><br><span class="line">private final String name;</span><br><span class="line"></span><br><span class="line">public Consumer(Broker&lt;Integer&gt; broker, String name) &#123;</span><br><span class="line">    this.broker = broker;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Integer message = broker.take(); message != -1; message = broker.take()) &#123;</span><br><span class="line">            System.out.format(&quot;%s consumed: %s%n&quot;, name, message);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;received termination signal&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           Broker&lt;Integer&gt; broker = new WaitNotifyBroker&lt;Integer&gt;(5);</span><br><span class="line"></span><br><span class="line">   //         Broker&lt;Integer&gt; broker = new LockConditionBroker&lt;Integer&gt;(5);</span><br><span class="line"></span><br><span class="line">   //         Broker&lt;Integer&gt; broker = new BlockingQueueBroker&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">           new Thread(new Producer(broker, &quot;prod 1&quot;)).start();</span><br><span class="line">           new Thread(new Consumer(broker, &quot;cons 1&quot;)).start();</span><br><span class="line">           new Thread(new Consumer(broker, &quot;cons 2&quot;)).start();</span><br><span class="line">    </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Consider the standard producer-consumer problem. Assume, we have a buffer of 4096 byte length. A producer thread collects the data and writes it tp the buffer. A consumer thread processes the collected data from the buffer. Objective is, both the threads should not run at the same time.</p>
<ul>
<li><p>Using Mutex:</p>
<p>A mutex provides mutual exclusion, either producer or consumer can have the key(mutex) and proceed with their work. As long as the buffer is filled by producer, the consumer needs to wait, and vice versa.</p>
<p>At any point of time, only one thread can work with with the entire buffer. The concept can be generalized using semaphore.</p>
</li>
<li><p>Using Semaphore:</p>
<p>A semaphore is a generalized mutex. In lieu of single buffer, we can split the 4 KB buffer into four 1 KB buffers(identical resources). A semaphore can be associated with these four buffers. The consumer and producer can work on different buffers at the same time.</p>
</li>
<li><p>Misconception:</p>
<p>There is an ambiguity between binary semaphore and mutex. we might have come across that a mutex is binary semaphore. But they are not! The purpose of mutex and semaphore are different . May be, due to similarity in their</p>
<p>implementation a mutex would be referred as binary semaphore.</p>
<p>Strictly speaking, a mutex is locking mechanism used to synchronize access to resource. Only one task(can be a thread or process based on OS abstraction) can acquire the mutex. It means there is ownership associated with mutex, and only the owner can release the lock(mutex).</p>
<p>Semaphore is signaling mechanism(“I am done, you can carry on “ kind of signal). For example, if you are listening songs(assume it as one task) on your mobile and at the same time your friend calls you, an interrupt is triggered upon which an interrupt service routine signals the call processing task to wake up.</p>
</li>
</ul>
<h3 id="General-Questions"><a href="#General-Questions" class="headerlink" title="General Questions:"></a>General Questions:</h3><ol>
<li><p>Can a thread acquire more than one lock(Mutex)?</p>
<p>Yes, it is possible that a thread is in need of more than one resource, hence the locks. If any lock is not available the thread will wait(block) on the lock.</p>
</li>
<li><p>Can a mutex be locked more than once?</p>
<p>A mutex is a lock. Only one state(locked/unlocked) is associated with it. However, a recursive mutex can be locked more than once(POSIX complaint systems), in which a count is associated with it, yet retains only one state(locked/unlocked). The programmer must unlock the mutex as many number times as it was locked.</p>
</li>
<li><p>What happens if a non-recursive mutex is locked more than once.</p>
<p>Deadlock. If a thread which had already locked a mutex, tries to lock the mutex again, it will enter into the waiting list of that mutex, which results in deadlock. It is because no other thread can unlock the mutex. An operating system implementer can exercise care in identifying the owner of mutex and return if it is already locked by same thread to prevent deadlocks.</p>
</li>
<li><p>Are binary semaphore and mutex same?</p>
<p>No, we suggest to treat them separately, as it is explained signaling vs locking mechanisms. But a binary semaphore may experience the same critical issues associated with mutex.</p>
</li>
<li><p>What is mutex and critical section?</p>
<p>Some operating systems use the same word critical section in the API. Usually a mutex is costly operation due to protection protocols associated with it. At last, the objective of mutex is atomic access. There are other ways to achieve atomic access like disabling interrupts which can be much faster but ruins responsiveness. The alternate API makes use of disabling interrupts.</p>
</li>
</ol>
<h2 id="StackOverflow-click-here"><a href="#StackOverflow-click-here" class="headerlink" title="StackOverflow: click here"></a>StackOverflow: <a href="https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex" target="_blank" rel="noopener">click here</a></h2><p>Mutex can be released only by thread that had acquired it, while you can signal semaphore from any other thread(or process), so semaphores are more suitable for some synchronization problems like producer-consumer.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java里面的生产者-消费者模型/" data-id="cjd8d3nxw0001cuzhg4t8zvqu" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java面试问题/" class="article-date">
  <time datetime="2018-02-04T05:43:32.156Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-Interview-Questions"><a href="#Java-Interview-Questions" class="headerlink" title="Java Interview Questions"></a>Java Interview Questions</h1><p>** 2017-12-23</p>
<h2 id="What-if-the-main-method-is-declared-as-private"><a href="#What-if-the-main-method-is-declared-as-private" class="headerlink" title="What if the main method is declared as private?"></a>What if the main method is declared as private?</h2><p>The program compiles properly but at runtime it will give “Main method not public.” message.</p>
<h2 id="What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method"><a href="#What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method" class="headerlink" title="What if the static modifier is removed from the signature of the main method?"></a>What if the static modifier is removed from the signature of the main method?</h2><p>Program compiles. But at runtime throws an error “NoSuchMethodError”.</p>
<h2 id="What-if-I-write-static-public-void-instead-of-public-static-void"><a href="#What-if-I-write-static-public-void-instead-of-public-static-void" class="headerlink" title="What if I write static public void instead of public static void?"></a>What if I write static public void instead of public static void?</h2><p>Program compiles and runs properly.</p>
<h2 id="What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method"><a href="#What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method" class="headerlink" title="What if I do not provide the String array as the argument to the method?"></a>What if I do not provide the String array as the argument to the method?</h2><p>Program compiles but throws a runtime error “NoSuchMethodError”.</p>
<h2 id="What-is-the-first-argument-of-the-String-array-in-main-method"><a href="#What-is-the-first-argument-of-the-String-array-in-main-method" class="headerlink" title="What is the first argument of the String array in main method?"></a>What is the first argument of the String array in main method?</h2><p>The String array is empty. It does not have any element. This is unlike C/C++ where the first element by default is the program name.</p>
<h2 id="If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null"><a href="#If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null" class="headerlink" title="If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?"></a>If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?</h2><p>It is empty. But not null.</p>
<h2 id="How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code"><a href="#How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code" class="headerlink" title="How can one prove that the array is not null but empty using one line of code?"></a>How can one prove that the array is not null but empty using one line of code?</h2><p>Print args.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print args.length.</p>
<h2 id="What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs"><a href="#What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs" class="headerlink" title="What environment variables do I need to set on my machine in order to be able to run Java programs?"></a>What environment variables do I need to set on my machine in order to be able to run Java programs?</h2><p>CLASPATH and PATH are the two variables.</p>
<h2 id="Can-an-application-have-multiple-classes-having-main-method"><a href="#Can-an-application-have-multiple-classes-having-main-method" class="headerlink" title="Can an application have multiple classes having main method?"></a>Can an application have multiple classes having main method?</h2><p>Yes it is possible. While starting the application we mention the class name to be run. The JVM will look for the Main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.</p>
<h2 id="Can-I-have-multiple-methods-in-the-same-class"><a href="#Can-I-have-multiple-methods-in-the-same-class" class="headerlink" title="Can I have multiple methods in the same class?"></a>Can I have multiple methods in the same class?</h2><p>No the program fails to compile. The compiler says that the main method is already defined in the class.</p>
<h2 id="Do-I-need-to-import-java-lang-package-any-time-Why"><a href="#Do-I-need-to-import-java-lang-package-any-time-Why" class="headerlink" title="Do I need to import java.lang package any time? Why?"></a>Do I need to import java.lang package any time? Why?</h2><p>No. It is by default loaded internally by the JVM.</p>
<h2 id="Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime"><a href="#Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime" class="headerlink" title="Can I import same package/class twice? will the JVM load the package twice at runtime?"></a>Can I import same package/class twice? will the JVM load the package twice at runtime?</h2><p>one can import the same package or same class multiple times. Neither complier nor JVM complains about it. And the JVM will internally load the class only once no matter how many times you import the same class.</p>
<h2 id="What-are-Checked-and-UnChecked-Exception"><a href="#What-are-Checked-and-UnChecked-Exception" class="headerlink" title="What are Checked and UnChecked Exception?"></a>What are Checked and UnChecked Exception?</h2><p>A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses.<br>Making an exception checked forces client programmers to deal with the possibility that the exception will be thrown. eg, IOException thrown by java.io.FileInputStream’s read() method·<br>Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked. With an unchecked exception, however, the compiler doesn’t force client programmers either to catch the<br>exception or declare it in a throws clause. In fact, client programmers may not even know that the exception could be thrown. eg, StringIndexOutOfBoundsException thrown by String’s charAt() method· Checked exceptions must be caught at compile time. Runtime exceptions do not need to be. Errors often cannot be.</p>
<h2 id="What-is-Overriding"><a href="#What-is-Overriding" class="headerlink" title="What is Overriding?"></a>What is Overriding?</h2><p>When a class defines a method using the same name, return type, and arguments as a method in its superclass, the method in the class overrides the method in the superclass. when the method is invoked for an object of the class, it is the new definition of the method that is called,and not the method definition from the superclass. Methods may be overridden to be more public, not more private.</p>
<h2 id="What-are-different-types-of-inner-classes"><a href="#What-are-different-types-of-inner-classes" class="headerlink" title="What are different types of inner classes?"></a>What are different types of inner classes?</h2><h3 id="Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes"><a href="#Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes" class="headerlink" title="Nested top-level classes, Member classes, Local classes, Anonymous classes."></a>Nested top-level classes, Member classes, Local classes, Anonymous classes.</h3><p>参考： <a href="https://www.jianshu.com/p/3ec6aa56fe6a" target="_blank" rel="noopener">java中的四种内部类</a></p>
<h4 id="Nested-top-level-classes"><a href="#Nested-top-level-classes" class="headerlink" title="Nested top-level classes"></a>Nested top-level classes</h4><p>If you declare a class within a class and specify the static modifier, the compiler treats the class just like any other top-level class.</p>
<p>Any class outside the declaring class accesses the nested class with the declaring class name acting similarly to a package. eg, outer.inner. Top-level inner classes implicitly have access only to static variables. There can also be inner interfaces. All of these are of the nested top-level variety.</p>
<p>静态内部类也是定义在另一个类里面的类， 只不过在类的前面多了一个关键字static。 静态内部类是不需要依赖于外部类的， 这点和类的静态成员属性有点类似。并且它不能使用内部类的非static成员变量或者方法， 这点很好理解， 因为在没有外部类的对象的情况下， 可以创建静态内部类的对象， 如果允许访问外部类的非static成员就会产生矛盾， 因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">	static class Inner &#123;</span><br><span class="line">		void go() &#123;</span><br><span class="line">			System.out.println(&quot;Inner class reference is: &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer.Inner n = new Outer.Inner();</span><br><span class="line">		n.go();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Member-classes"><a href="#Member-classes" class="headerlink" title="Member classes"></a>Member classes</h4><p>Member inner classes are just like other member methods and member variables and access to the member class is restricted, just like methods and variables. This means a public member classes acts similarly to a nested top-level class. The primary difference between member classes and nested top-level classes is that member classes is that member classes have access to the specific instance of the enclosing class.</p>
<p>成员内部类， 就是作为外部类的成员， 可以直接使用外部类的所有成员和方法， 即使是private的。 同时外部类要访问内部类的所有成员变量/方法， 则需要通过内部类的对象来获取。</p>
<p>要注意的是， 成员内部类不能含有static的变量和方法。 因为成员内部类需要先创建了外部类， 才能创建它自己的。</p>
<p>在成员内部类要引用外部类对象时， 使用outer.this 来表示外部类对象； 创建内部类对象， 可以使用 outer.inner obj= outerobj. new innier();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int x = 100;</span><br><span class="line"> </span><br><span class="line">    public void makeInner()&#123;</span><br><span class="line">        Inner in = new Inner();</span><br><span class="line">        in.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Inner&#123;</span><br><span class="line">        public void seeOuter()&#123;</span><br><span class="line">            System.out.println(&quot;Outer x is &quot; + x);</span><br><span class="line">            System.out.println(&quot;Inner class reference is &quot; + this);</span><br><span class="line">            System.out.println(&quot;Outer class reference is &quot; + Outer.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">    	Outer o = new Outer();</span><br><span class="line">        Inner i = o.new Inner();</span><br><span class="line">        i.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Local-classes"><a href="#Local-classes" class="headerlink" title="Local classes"></a>Local classes</h4><p>Local classes are like local variables, specific to a block of code. Their visibility is only within the block of their declaration. In order for the class to be useful beyond the declaration block, it would need to implement a more publicly available interface.Because local classes are not members, the modifiers public, protected, private, and static are not usable.</p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类， 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">	private String x = &quot;outer&quot;;</span><br><span class="line"> </span><br><span class="line">	public void doStuff() &#123;</span><br><span class="line">		class MyInner &#123;</span><br><span class="line">			public void seeOuter() &#123;</span><br><span class="line">				System.out.println(&quot;x is &quot; + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		MyInner i = new MyInner();</span><br><span class="line">		i.seeOuter();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer o = new Outer();</span><br><span class="line">		o.doStuff();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Anonymous-classes"><a href="#Anonymous-classes" class="headerlink" title="Anonymous classes"></a>Anonymous classes</h4><p>Anonymous inner classes extend local inner classes one level further. As anonymous classes have no name, you cannot provide a constructor.</p>
<p>匿名内部类最常使用的情况就是在多线程的实现上， 因为要实现多线程必须继承Thread类或者实现Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(new ActionListener()&#123;</span><br><span class="line">     public void actionPerformed(ActionEvent e)&#123;</span><br><span class="line">         comp.setText(&quot;Button has been clicked&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="What-is-the-difference-between-an-Interface-and-an-abstract-class"><a href="#What-is-the-difference-between-an-Interface-and-an-abstract-class" class="headerlink" title="What is the difference between an Interface and an abstract class?"></a>What is the difference between an Interface and an abstract class?</h2><p>An abstract class can have instance methods that implement a default behavior. An Interface can only declare constants and instance methods, but cannot implements default behavior and all methods are implicitly abstract . An interface has all public members and no implementation. Am abstract class is a class which may have the usual flavors of class members(private , protected, etc.), but has some abstract methods.</p>
<p>抽象类是用来捕捉子类中的通用特性的。 它不能被实例化， 只能被用作子类的超类。 抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;</span><br><span class="line">    // abstract method</span><br><span class="line">    abstract void service(ServletRequest req, ServletResponse res);</span><br><span class="line"> </span><br><span class="line">    void init() &#123;</span><br><span class="line">        // Its implementation</span><br><span class="line">    &#125;</span><br><span class="line">    // other method related to Servlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当HttpServlet类继承GenericServlet 时， 它提供了service方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServlet extends GenericServlet &#123;</span><br><span class="line">    void service(ServletRequest req, ServletResponse res) &#123;</span><br><span class="line">        // implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // some other methods related to HttpServlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是抽象方法的集合。 如果一个类实现了某个接口， 那么它就继承了这个接口的抽象方法。 这就像契约模式， 如果实现了这个接口， 那么就必须确保使用这些方法。 接口只是一种形式， 接口自身不能做任何事情。 以Externalizable接口为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Externalizable extends Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    void writeExternal(ObjectOutput out) throws IOException;</span><br><span class="line"> </span><br><span class="line">    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你实现这个接口时， 你就需要实现上面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements Externalizable &#123;</span><br><span class="line"> </span><br><span class="line">    int employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<p>Oracle已经开始尝试向接口中引入默认方法和静态方法， 以此来减少抽象类和接口之间的差异。 现在， 我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。</p>
<h2 id="Describe-synchronization-in-respect-to-multithreading"><a href="#Describe-synchronization-in-respect-to-multithreading" class="headerlink" title="Describe synchronization in respect to multithreading."></a>Describe synchronization in respect to multithreading.</h2><p>With respect to multithreading, synchronization is the capability to control the access of multiple threads to shared resources. Without synchronization, it is possible for one thread to modify a shared variables while another thread is in the process of using or updating same shared variable. This usually leads to significant errors.</p>
<h2 id="Explain-different-way-of-using-thread"><a href="#Explain-different-way-of-using-thread" class="headerlink" title="Explain different way of using thread?"></a>Explain different way of using thread?</h2><p>The thread could be implemented by using runnable interface or by inheriting from the Thread class. The former is more advantageous, ‘cause when you are going for multiple inheritance, the only interface can help.</p>
<h2 id="Difference-between-HashMap-and-HashTable"><a href="#Difference-between-HashMap-and-HashTable" class="headerlink" title="Difference between HashMap and HashTable?"></a>Difference between HashMap and HashTable?</h2><p>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesnt allow). HashMap does not guarantee that the order of the map will remain constant over time. HashMap is unsynchronized and Hashtable is synchronized.</p>
<h2 id="What-is-the-difference-between-a-constructor-and-a-method"><a href="#What-is-the-difference-between-a-constructor-and-a-method" class="headerlink" title="What is the difference between a constructor and a method?"></a>What is the difference between a constructor and a method?</h2><p>A constructor is a member function of a class that is used to create objects of that class. It has the same name as the class itself, has no return type, and is invoked using the new operator.<br>A method is an ordinary member function of a class. It has its own name, a return type (which may be void), and is invoked using the dot operator.</p>
<h2 id="What-is-an-Iterator"><a href="#What-is-an-Iterator" class="headerlink" title="What is an Iterator?"></a>What is an Iterator?</h2><p>Some of the collection classes provide traversal of their contents via a java.util.Iterator interface. This interface allows you to walk through a collection of objects, operating on each object in turn. Remember when using Iterators that they contain a snapshot of the collection at the time the Iterator was obtained; generally it is not advisable to modify the collection itself while traversing an Iterator.</p>
<h2 id="State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers"><a href="#State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers" class="headerlink" title="State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers."></a>State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers.</h2><p><strong><em>public : \</em></strong>Public class is visible in other packages, field is visible everywhere (class must be public too)<br><strong><em>private :\</em></strong> Private variables or methods may be used only by an instance of the same class that declares the variable or method, A private feature may only be accessed by the class that owns the feature.<br><strong><em>protected :\</em></strong> Is available to all classes in the same package and also available to all subclasses of the class that owns the protected feature.This access is provided even to subclasses that reside in a different package from the class that owns the protected feature.<br><strong><em>default :\</em></strong>What you get by default ie, without any access modifier (ie, public private or protected).It means that it is visible to all within a particular package.</p>
<h2 id="What-is-static-in-Java"><a href="#What-is-static-in-Java" class="headerlink" title="What is static in Java?"></a>What is static in Java?</h2><p>static means one per class, not one for each object no matter how many instance of a class might exist. This means that you can use them without creating an instance of a class. Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can’t override a static method with a non-static method. In other words, you can’t change a static method into an instance method in a subclass.</p>
<p>Static methods can be overriden, but they cannot be overriden to be non-static,Whereas final methods cannot be overridden.</p>
<p>A static method is a method that’s invoked through a class, rather than a specific object of that class. Static methods can only access static variables – they can’t use anything that’s specific to a particular object. Nonstatic methods (or instance methods) must be called on a specific object and can use the object’s instance data.<br>A final method is just a method that cannot be overridden – while static methods are implicitly final, you might also want to create an final instance method.</p>
<p>In this code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the static method in Bar ‘hides’ the static method declared in Foo, as opposed to overriding it in the polymorphism sense.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Foo.method();</span><br><span class="line">        Bar.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>will output:</p>
<p>in Foo<br>in Bar</p>
<p>Re-defining method() as final in Foo will disable the ability for Bar to hide it, and re-running main() will output:</p>
<p>in Foo<br>in Foo</p>
<p>Compilation fails when you mark the method as final, and only runs again when remove Bar.method()</p>
<p>Final will prevent the method from being hidden by subclasses .</p>
<h2 id="Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests"><a href="#Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests" class="headerlink" title="Does importing a package imports the subpackages as well? e.g. Does importing com.Test. also import com.MyTest.UnitTests.?"></a>Does importing a package imports the subpackages as well? e.g. Does importing com.Test.<em> also import com.MyTest.UnitTests.</em>?</h2><p>No you will have to import the subpackage explicitly. Importing com.MyTest.* will import classes in the package MyTest only. It will not import any class in any of it’s subpackage.</p>
<h2 id="What-is-serialization"><a href="#What-is-serialization" class="headerlink" title="What is serialization?"></a>What is serialization?</h2><p>Serialization is a mechanism by which you can save the state of an object by converting it to a byte stream.</p>
<p>The serializable interface is an empty interface. It does not contain any methods. So we do not implement ant methods.</p>
<h2 id="What-is-the-common-usage-of-serialization"><a href="#What-is-the-common-usage-of-serialization" class="headerlink" title="What is the common usage of serialization?"></a>What is the common usage of serialization?</h2><p>Whenever an object is to be sent over the network, objects need to be serialized. Moreover if the state of an object is to be saved, objects need to be serialized.</p>
<h2 id="What-are-wrapper-classes"><a href="#What-are-wrapper-classes" class="headerlink" title="What are wrapper classes?"></a>What are wrapper classes?</h2><p>java provides specialized classes corresponding to each of the primitive data types. These are called wrapper classes. They are e.g. Integer, Character, Double etc.</p>
<h2 id="What-are-the-different-ways-to-handle-exceptions"><a href="#What-are-the-different-ways-to-handle-exceptions" class="headerlink" title="What are the different ways to handle exceptions?"></a>What are the different ways to handle exceptions?</h2><p>There are two ways to handle exceptions,</p>
<ol>
<li>By wrapping the desired code in a try block followed by a catch block to catch the exceptions.</li>
<li>Lit the desired exceptions in the throws clause of the method and let the caller of the method handle those exceptions.</li>
</ol>
<h2 id="Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block"><a href="#Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block" class="headerlink" title="Is it necessary that each try block must be followed by a catch block?"></a>Is it necessary that each try block must be followed by a catch block?</h2><p>It is not necessary that each catch block must be followed by a catch block. It should be followed by either a catch block or a finally block. And whatever exceptions are likely to be thrown should be declared in the throws clause if the method.</p>
<h2 id="If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt"><a href="#If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt" class="headerlink" title="If I write return at the end of the try block, will the finally block still execute&gt;"></a>If I write return at the end of the try block, will the finally block still execute&gt;</h2><p>Yes even if you write return as the last statement in the try block and no exception occurs, the finally block will execute. The finally block will execute and then the control system.</p>
<h2 id="If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute"><a href="#If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute" class="headerlink" title="If I write System.exit (0); at the end of the try block, will the finally block still execute?"></a>If I write System.exit (0); at the end of the try block, will the finally block still execute?</h2><p>No in this case the finally block will not execute because when you say System.exit (0); the control immediately goes out of the program, and thus finally never executes.</p>
<h2 id="Can-a-java-file-contain-more-than-one-java-classes"><a href="#Can-a-java-file-contain-more-than-one-java-classes" class="headerlink" title="Can a .java file contain more than one java classes?"></a>Can a .java file contain more than one java classes?</h2><p>Yes, a .java file contain more than one java classes, provided at the most one of of them is a public class.</p>
<h2 id="What-is-the-default-value-of-the-local-variables"><a href="#What-is-the-default-value-of-the-local-variables" class="headerlink" title="What is the default value of the local variables?"></a><strong>What is the default value of the local variables?</strong></h2><p>The local variables are not initialized to any default value, neither primitives nor object references. If you try to use these variables without initializing them explicitly, the java compiler will not compile the code. It will complain abt the local variable not being initialized.</p>
<h2 id="Can-we-Overload-main-method"><a href="#Can-we-Overload-main-method" class="headerlink" title="Can we Overload main() method?"></a>Can we Overload main() method?</h2><p>Yes. We can overload main() method. A java class can have any number of main() methods. But to run the java class. class should have main() method with signature as “public static void main(String[] args)”. If you do any modification to this signature, compilation will be successful. But, you can’t run the java program. You will get run time error as main method not found.</p>
<h2 id="Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier"><a href="#Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier" class="headerlink" title="Can we declare main() method as private or protected or with no access modifier?"></a>Can we declare main() method as private or protected or with no access modifier?</h2><p>No, main() method must be public. You can’t define main() methods as private or protected or with no access modifier. This is because to make the main() method accessible to JVM. If you define main() method other than public, compilation will be successful but you will get run time error as no main method found.</p>
<h2 id="Can-we-Declare-main-Method-As-Non-Static"><a href="#Can-we-Declare-main-Method-As-Non-Static" class="headerlink" title="Can we Declare main() Method As Non-Static?"></a>Can we Declare main() Method As Non-Static?</h2><p>No, main() method must be declared as static so than JVM can call main() method without instantiating it’s class. If you remove “static” from main() method signature, compilation will be successful but program fails at run time.</p>
<h2 id="Can-we-change-return-type-of-main-method"><a href="#Can-we-change-return-type-of-main-method" class="headerlink" title="Can we change return type of main() method?"></a>Can we change return type of main() method?</h2><p>No. The return type of main() method must be void only. Any other type is not acceptable.</p>
<h2 id="Can-we-run-java-class-without-main-method"><a href="#Can-we-run-java-class-without-main-method" class="headerlink" title="Can we run java class without main() method?"></a>Can we run java class without main() method?</h2><p>No, you can’t run java class without main method. But, there are some scenarios like if super class has main() method. then sub class can be run without defining main() method in it.</p>
<h3 id="What-is-Thread-in-Java"><a href="#What-is-Thread-in-Java" class="headerlink" title="What is Thread in Java?"></a>What is Thread in Java?</h3><p>The thread is an independent path of execution. It’s way to take advantage of multiple CPU available in a machine. By employing multiple threads you can speed up CPU bound task. For example, if one thread takes 100 milliseconds to do a job, you can use 10 threads to reduce that task into 10 milliseconds. Java provides excellent support for multithreading at the language level, and it’s one of the strong selling points.</p>
<h3 id="What-is-the-difference-between-Thread-and-Process-in-Java"><a href="#What-is-the-difference-between-Thread-and-Process-in-Java" class="headerlink" title="What is the difference between Thread and Process in Java?"></a>What is the difference between Thread and Process in Java?</h3><p>The thread is a subset of Process, in other words, one process can contain multiple threads. Two process runs on different memory space, but all threads share same memory space. Don’t confuse this with stack memory, which is different for the different thread and used to store local data to that thread.</p>
<h3 id="How-do-you-implement-Thread-in-Java"><a href="#How-do-you-implement-Thread-in-Java" class="headerlink" title="How do you implement Thread in Java?"></a>How do you implement Thread in Java?</h3><p>At the language level, there are two ways to implement Thread in Java. An instance of java.lang.Thread represent a thread but it needs a task to execute, which is an instance of interface java.lang.Runnable. Since Thread class itself implement Runnable, you can override run() method by extending Thread class or just implementing Runnable interface.</p>
<h3 id="When-to-use-Runnable-vs-Thread-in-Java"><a href="#When-to-use-Runnable-vs-Thread-in-Java" class="headerlink" title="When to use Runnable vs Thread in Java?"></a>When to use Runnable vs Thread in Java?</h3><p>This question will be easy to answer if you know that Java programming language doesn’t support multiple inheritances of class, but it allows you to implement multiple interfaces. Which means, it’s better to implement Runnable then extends Thread if you also want to extend another class.</p>
<h3 id="What-is-the-difference-between-start-and-run-method-of-Thread-class"><a href="#What-is-the-difference-between-start-and-run-method-of-Thread-class" class="headerlink" title="What is the difference between start() and run() method of Thread class?"></a>What is the difference between start() and run() method of Thread class?</h3><p>start() method is used to start newly created thread, while start() internally calls run() method, there is difference calling run() method directly. When you invoke run() as normal method, it’s called in the same thread, no new thread is started, which is the case when you call start() method.</p>
<h3 id="What-is-the-difference-between-Runnable-and-Callable-in-Java"><a href="#What-is-the-difference-between-Runnable-and-Callable-in-Java" class="headerlink" title="What is the difference between Runnable and Callable in Java?"></a>What is the difference between Runnable and Callable in Java?</h3><p>Both Runnable and Callable represent task which is intended to be executed in a separate thread. Runnable is there from JDK 1.0 while Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. See my <a href="http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html" target="_blank" rel="noopener">blog post</a> on the same topic for a more in-depth answer to this question.</p>
<h3 id="What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java"><a href="#What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java" class="headerlink" title="What is the difference between CyclicBarrier and CountDownLatch in Java?"></a>What is the difference between CyclicBarrier and CountDownLatch in Java?</h3><p>Though both CyclicBarrier and CountDownLatch wait for number of threads on one or more events, the main difference between them is that you can not re-use CountDownLatch once count reaches to zero, but you can reuse same CyclicBarrier even after barrier is broken.</p>
<h3 id="What-is-volatile-variable-in-Java"><a href="#What-is-volatile-variable-in-Java" class="headerlink" title="What is volatile variable in Java?"></a>What is volatile variable in Java?</h3><p>volatile is a special modifier, which can only be used with instance variables. In concurrent Java programs, changes made by multiple threads on instance variables is not visible to other in absence of any synchronizers e.g. synchronized keyword or locks. Volatile variable guarantees that a write will happen before any subsequent read: as stated:”volatile variable rule”.</p>
<h3 id="What-is-thread-safety-is-a-Vector-a-thread-safe-class"><a href="#What-is-thread-safety-is-a-Vector-a-thread-safe-class" class="headerlink" title="What is thread-safety? is a Vector a thread-safe class?"></a>What is thread-safety? is a Vector a thread-safe class?</h3><p>Thread-safety is a property of an object or code which guarantees that if executed or used by multiple threads in any manner. For example, a thread-safe counter object will not miss any count if same instance of that counter is shared among multiple threads. Apparently, you can also divide collection classes in two category, thread-safe and non-thread-safe. Vector is indeed a thread-safe class and it achieves thread-safety by synchronizing methods which modify state of Vector, on the other hand, its counterpart ArrayList is not thread-safe.</p>
<h3 id="How-to-stop-a-thread-in-Java"><a href="#How-to-stop-a-thread-in-Java" class="headerlink" title="How to stop a thread in Java?"></a>How to stop a thread in Java?</h3><p>I always said that Java provides rich APIs for everything but ironically Java doesn’t provide a sure shot way of stopping thread. There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which was deprecated in later releases due to potential deadlock threats, from then Java API designers has not made any effort to provide a consistent, thread-safe and elegant way to stop threads. Programmers mainly rely on the fact that thread stops automatically as soon as they finish execution of run() or call() method. To manually stop, programmers either take advantage of volatile boolean variable and check in every iteration if run method has loops or interrupt threads to abruptly cancel tasks. See this <a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="noopener">tutorial</a> for sample code of stopping thread in Java.</p>
<h3 id="What-happens-when-an-Exception-occurs-in-a-thread"><a href="#What-happens-when-an-Exception-occurs-in-a-thread" class="headerlink" title="What happens when an Exception occurs in a thread?"></a>What happens when an Exception occurs in a thread?</h3><p>This is one of the good <a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="noopener">tricky Java question</a> I have seen in interviews. In simple words, If not caught thread will die, if an uncaught exception handler is registered then it will get a call back. Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments.</p>
<h3 id="What-is-the-difference-between-notify-and-notifyAll-in-Java"><a href="#What-is-the-difference-between-notify-and-notifyAll-in-Java" class="headerlink" title="What is the difference between notify and notifyAll in Java?"></a>What is the difference between notify and notifyAll in Java?</h3><p>This is another tricky questions from core Java interviews, since multiple threads can wait on single monitor lock, Java API designer provides method to inform only one of them or all of them, once waiting condition changes, but they provide half implementation. There notify() method doesn’t provide any way to choose a particular thread, that’s why its only useful when you know that there is only one thread is waiting. On the other hand, notifyAll() sends notification to all threads and allows them to compete for locks, which ensures that at-least one thread will proceed further. See my <a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="noopener">blog post</a> on similar topic for a more detailed answer and code example.</p>
<h3 id="Why-wait-notify-and-notifyAll-are-not-inside-thread-class"><a href="#Why-wait-notify-and-notifyAll-are-not-inside-thread-class" class="headerlink" title="Why wait, notify and notifyAll are not inside thread class?"></a>Why wait, notify and notifyAll are not inside thread class?</h3><p>This is a design related question, which checks what candidate thinks about existing system or does he ever thought of something which is so common but looks in-appropriate at first. In order to answer this question, you have to give some reasons why it make sense for these three method to be in Object class, and why not on Thread class. One reason which is obvious is that Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object.</p>
<h3 id="What-is-ThreadLocal-variable-in-Java"><a href="#What-is-ThreadLocal-variable-in-Java" class="headerlink" title="What is ThreadLocal variable in Java?"></a>What is ThreadLocal variable in Java?</h3><p>ThreadLocal variables are special kind of variable available to Java programmer. Just like instance variable is per instance, ThreadLocal variable is per thread. It’s a nice way to achieve thread-safety of expensive-to-create objects, for example you can make SimpleDateFormat thread-safe using ThreadLocal. Since that class is expensive, its not good to use it in local scope, which requires separate instance on each invocation. By providing each thread their own copy, you shoot two birds with one arrow. First, you reduce number of instance of expensive object by reusing fixed number of instances, and Second, you achieve thread-safety without paying cost of synchronization or immutability. Another good example of thread local variable is ThreadLocalRandom class, which reduces number of instances of expensive-to-create Random object in multi-threading environment. See this <a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="noopener">answer</a> to learn more about thread local variables in Java.</p>
<h3 id="What-is-FutureTask-in-Java"><a href="#What-is-FutureTask-in-Java" class="headerlink" title="What is FutureTask in Java?"></a>What is FutureTask in Java?</h3><p>FutureTask represents a cancellable asynchronous computation in concurrent Java application. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get methods will block if the computation has not yet completed. A FutureTask object can be used to wrap a Callable or Runnable object. Since FutureTask also implements Runnable, it can be submitted to an Executor for execution.</p>
<h3 id="What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java"><a href="#What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java" class="headerlink" title="What is the difference between the interrupted() and isInterrupted() method in Java?"></a>What is the difference between the interrupted() and isInterrupted() method in Java?</h3><p>Main difference between interrupted() and isInterrupted() is that former clears the interrupt status while later does not. The interrupt mechanism in Java multi-threading is implemented using an internal flag known as the interrupt status. Interrupting a thread by calling Thread.interrupt() sets this flag. When interrupted thread checks for an interrupt by invoking the <a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="noopener">static method</a> Thread.interrupted(), interrupt status is cleared. The non-static isInterrupted() method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag. By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it’s always possible that interrupt status will immediately be set again, by another thread invoking interrupt</p>
<h3 id="Why-wait-and-notify-method-are-called-from-synchronized-block"><a href="#Why-wait-and-notify-method-are-called-from-synchronized-block" class="headerlink" title="Why wait and notify method are called from synchronized block?"></a>Why wait and notify method are called from synchronized block?</h3><p>Main reason for calling wait and notify method from either synchronized block or method is that it made mandatory by Java API. If you don’t call them from synchronized context, your code will throw IllegalMonitorStateException. A more subtle reason is to avoid the race condition between wait and notify calls.</p>
<h3 id="What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java"><a href="#What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java" class="headerlink" title="What is the difference between synchronized and concurrent collection in Java?"></a>What is the difference between synchronized and concurrent collection in Java?</h3><p>Though both synchronized and concurrent collection provides thread-safe collection suitable for multi-threaded and concurrent access, later is more scalable than former. Before Java 1.5, Java programmers only had synchronized collection which becomes source of contention if multiple thread access them concurrently, which hampers scalability of system. Java 5 introduced concurrent collections like ConcurrentHashMap, which not only provides thread-safety but also improves scalability by using modern techniques like lock stripping and partitioning internal table.</p>
<h3 id="What-is-the-difference-between-Stack-and-Heap-in-Java"><a href="#What-is-the-difference-between-Stack-and-Heap-in-Java" class="headerlink" title="What is the difference between Stack and Heap in Java?"></a>What is the difference between Stack and Heap in Java?</h3><p>Why does someone this question as part of multi-threading and concurrency? because Stack is a memory area which is closely associated with threads. To answer this question, both stack and heap are specific memories in Java application. Each thread has their own stack, which is used to store local variables, method parameters and call stack. Variable stored in one Thread’s stack is not visible to other. On another hand, the heap is a common memory area which is shared by all threads. Objects whether local or at any level is created inside heap. To improve performance thread tends to cache values from heap into their stack, which can create problems if that variable is modified by more than one thread, this is where volatile variables come into the picture. volatile suggest threads read the value of variable always from main memory.</p>
<h3 id="What-is-thread-pool-Why-should-you-thread-poll-in-Java"><a href="#What-is-thread-pool-Why-should-you-thread-poll-in-Java" class="headerlink" title="What is thread pool? Why should you thread poll in Java?"></a>What is thread pool? Why should you thread poll in Java?</h3><p>Creating thread is expensive in terms of time and resource. If you create thread at time of request processing it will slow down your response time, also there is only a limited number of threads a process can create. To avoid both of these issues, a pool of thread is created when application starts-up and threads are reused for request processing. This pool of thread is known as “thread pool” and threads are known as worker thread. From JDK 1.5 release, Java API provides Executor framework, which allows you to create different types of thread pools e.g. single thread pool, which process one task at a time, fixed thread pool (a pool of fixed number of threads) or cached thread pool (an expandable thread pool suitable for applications with many short lived tasks).</p>
<h3 id="How-do-you-check-if-a-Thread-holds-a-lock-or-not"><a href="#How-do-you-check-if-a-Thread-holds-a-lock-or-not" class="headerlink" title="How do you check if a Thread holds a lock or not?"></a>How do you check if a Thread holds a lock or not?</h3><p>I didn’t even know that you can check if a Thread already holds lock before this question hits me in a telephonic round of Java interview. There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object.</p>
<h3 id="What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java"><a href="#What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java" class="headerlink" title="What is the difference between synchronized and ReentrantLock in Java?"></a>What is the difference between synchronized and ReentrantLock in Java?</h3><p>There were days when the only way to provide mutual exclusion in Java was via synchronized keyword, but it has several shortcomings e.g. you can not extend lock beyond a method or block boundary, you can not give up trying for a lock etc. Java 5 solves this problem by providing more sophisticated control via Lock interface. ReentrantLock is a common implementation of Lock interface and provides re-entrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p>
<h3 id="There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java"><a href="#There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java" class="headerlink" title="There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?"></a>There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?</h3><p>Sequencing in multi-threading can be achieved by different means but you can simply use the join() method of thread class to start a thread when another one has finished its execution. To ensure three threads execute you need to start the last one first e.g. T3 and then call join methods in reverse order e.g. T3 calls T2. join and T2 calls T1.join, these ways T1 will finish first and T3 will finish last.</p>
<h3 id="What-does-yield-method-of-Thread-class-do"><a href="#What-does-yield-method-of-Thread-class-do" class="headerlink" title="What does yield method of Thread class do?"></a>What does yield method of Thread class do?</h3><p>Yield method is one way to request current thread to relinquish CPU so that other thread can get a chance to execute. Yield is a static method and only guarantees that current thread will relinquish the CPU but doesn’t say anything about which other thread will get CPU. Its possible for the same thread to get CPU back and start its execution again.</p>
<h3 id="What-is-Semaphore-in-Java"><a href="#What-is-Semaphore-in-Java" class="headerlink" title="What is Semaphore in Java?"></a>What is Semaphore in Java?</h3><p>Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool.</p>
<h3 id="What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled"><a href="#What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled" class="headerlink" title="What happens if you submit a task when the queue of the thread pool is already filled?"></a>What happens if you submit a task when the queue of the thread pool is already filled?</h3><p>This is another tricky question on my list. Many programmers will think that it will block until a task is cleared but its true. ThreadPoolExecutor’s submit() method throws RejectedExecutionException if the task cannot be scheduled for execution.</p>
<h3 id="What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java"><a href="#What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java" class="headerlink" title="What is the difference between the submit() and execute() method thread pool in Java?"></a>What is the difference between the submit() and execute() method thread pool in Java?</h3><p>Both methods are ways to submit a task to thread pools but there is a slight difference between them. execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. Its return type is void. On other hand submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods.</p>
<h3 id="What-is-ReadWriteLock-in-Java"><a href="#What-is-ReadWriteLock-in-Java" class="headerlink" title="What is ReadWriteLock in Java?"></a>What is ReadWriteLock in Java?</h3><p>In general, read write lock is the result of lock stripping technique to improve the performance of concurrent applications. In Java, ReadWriteLock is an interface which was added in Java 5 release. A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive. If you want you can implement this interface with your own set of rules, otherwise you can use ReentrantReadWriteLock, which comes along with JDK and supports a maximum of 65535 recursive write locks and 65535 read locks.</p>
<h3 id="What-is-the-difference-between-the-volatile-and-atomic-variable-in-java"><a href="#What-is-the-difference-between-the-volatile-and-atomic-variable-in-java" class="headerlink" title="What is the difference between the volatile and atomic variable in java?"></a>What is the difference between the volatile and atomic variable in java?</h3><p>This is an interesting question for Java programmer, at first, volatile and atomic variable look very similar, but they are different. Volatile variable provides you happens-before guarantee that a write will happen before any subsequent write, it doesn’t guarantee atomicity. For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly you have atomic version for other data type and reference variable as well.</p>
<h3 id="What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block"><a href="#What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block" class="headerlink" title="What happens if a thread throws an Exception inside synchronized block?"></a>What happens if a thread throws an Exception inside synchronized block?</h3><p>This is one more tricky question for average Java programmer, if he can bring the fact about whether lock is released or not is a key indicator of his understanding. To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a <a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="noopener">finally block</a>.</p>
<h3 id="What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading"><a href="#What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading" class="headerlink" title="What is the difference between calling wait() and sleep() method in Java multi-threading?"></a>What is the difference between calling wait() and sleep() method in Java multi-threading?</h3><p>Though both wait and sleep introduce some form of pause in Java application, they are the tool for different needs. Wait method is used for inter-thread communication, it relinquishes lock if waiting for a condition is true and wait for notification when due to an action of another thread waiting condition becomes false. On the other hand sleep() method is just to relinquish CPU or stop execution of current thread for specified time duration. Calling sleep method doesn’t release the lock held by the current thread.</p>
<p>中文版： <a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">http://www.importnew.com/12773.html</a></p>
<p>When you synchronize a method, you are effectively synchronizing to the object itself. In the case of a static method, you’re synchronizing to the class of the object.</p>
<h3 id="how-does-Java-object-casting-work-behind-the-scene"><a href="#how-does-Java-object-casting-work-behind-the-scene" class="headerlink" title="how does Java object casting work behind the scene?"></a>how does Java object casting work behind the scene?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class parent&#123;</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends parent&#123;</span><br><span class="line">  @override</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent p= new Parent();</span><br><span class="line">Child c= (Child) p;</span><br></pre></td></tr></table></figure>
<p>Essentially the parent class is treated like an interface might be. when you cast the child to the Parent, only the Parent API is available. However, the overridden method will still be called. So , if you do:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent p= (Parent) new Child()</span><br><span class="line">p.a()</span><br></pre></td></tr></table></figure>
<p>the Child’s public void a() will be called, even though it is being seem through the lens of the Parent class. However if you were to have a second method in the Child that the parent does not have, you would not be able to call that without casting the object back to a Child.</p>
<h3 id="hashcode-and-equals"><a href="#hashcode-and-equals" class="headerlink" title="hashcode() and equals()"></a>hashcode() and equals()</h3><p>我们以“类的用途”来讲hashCode()和equals()的关系分两种情况来说明。</p>
<ul>
<li><p>第一种， 不会创建类所对应的散列表</p>
<p>这里所说的不会创建类所对应的散列表是说： 我们不会在HashSet, hashTable, HashMap等等这些本质是散列表的数据结构中， 用到此类。</p>
<p>在这种情况下， 该类的hashCode()和equals没有关系。</p>
<p>在这种情况下， equals()用来比较该类的两个对象是否相等。 而hashCode()则根本没有任何作用， 所以不用理会hashcode()</p>
</li>
<li><p>第二种， 会创建类所对应的散列表</p>
<p>这里所说的会创建类对应的散列表是说， 我们会在hashset， hashtable， hashtable等等这些本质是散列表的数据结构中， 用到该类。</p>
<p>在这种情况下， 该类的hashCode() 和 equals()是有关系的:</p>
<ul>
<li><p>如果两个对象相等， 那么它们的hashCode()值一定相同。</p>
<p>这里的相等是指， 通过equals()比较两个对象时返回true。</p>
</li>
<li><p>如果两个对象hashCode()相等， 它们并不一定相等。</p>
</li>
</ul>
<p>因为在散列表中， hashcode()相等， 即两个键值对的哈希值相等， 然而哈希值相等， 并不一定能得出键值对相等。</p>
<p>此外， 在这种情况下， 若要判断两个对象是否相等， 除了要覆盖equals之外， 也要覆盖hashCode()函数。 否则， equals()无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest2&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        Person p4 = new Person(&quot;EEE&quot;, 100);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象 </span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 比较p1 和 p4， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc重写hashCode </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode()&#123;  </span><br><span class="line">            int nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">            return nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc 覆盖equals方法 </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;  </span><br><span class="line">            if(obj == null)&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //如果是同一个对象返回true，反之返回false  </span><br><span class="line">            if(this == obj)&#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //判断是否类型相同  </span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>这里有个比较好的例子， 由这个例子， 我们可以看出来， 因为通过这个来讲的话， hashset在进行add的时候， 我们先比较hashcode， 然后再进行equal。 所以， hashcode这个只和分桶有关， 我们还要通过equals的比较才能进行更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java面试问题/" data-id="cjd8d3ny60003cuzh25yc8drv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Resume Review" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Resume Review/" class="article-date">
  <time datetime="2018-02-04T05:43:32.100Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Resume-review"><a href="#Resume-review" class="headerlink" title="Resume review"></a>Resume review</h1><p>** 2017-12-26</p>
<h1 id="Shopping-Website-Design-and-Development"><a href="#Shopping-Website-Design-and-Development" class="headerlink" title="Shopping Website Design and Development"></a>Shopping Website Design and Development</h1><p>Well, I built this project in the summer.</p>
<p>This is a project which is a web application based on mongodb, express, and node.js. As you know, as an international student, sometimes we have to move often, and every time we move, we might need to sell something.So I built this website to works as a platform for student to sell used items to other. You can register, login and post, delete and comment on the website. The frontend of the website is based on bootstrap and the backend is based on mongodb and node.js. And now the project is deployed on Heroku, and I’m still working on it to add more new features. If you are interested, I can send you a link to the website.</p>
<h2 id="What-did-you-learned-from-the-process"><a href="#What-did-you-learned-from-the-process" class="headerlink" title="What did you learned from the process."></a>What did you learned from the process.</h2><p>well, before building this project, I have no experience in mean stack. And through building this project, I have a through understanding of how node.js works, and build some frontend page, which is quiet interesting.</p>
<h2 id="Difficulty"><a href="#Difficulty" class="headerlink" title="Difficulty"></a>Difficulty</h2><p>Well, as I have said, I have no experience in building website before, and in the meantime, node.js is quiet new for me, so problem occurs a lot in the process. Like how different middleware works, and how to add register and login function. So to solve those problems, I spent a lot of time searching on the website and ask friend who have experience in mean stack for help. And in the last, the problem was solved.</p>
<h1 id="Customer-Relationship-Management-System-Design-and-Development"><a href="#Customer-Relationship-Management-System-Design-and-Development" class="headerlink" title="Customer Relationship Management System Design and Development."></a>Customer Relationship Management System Design and Development.</h1><p>Actually, this is a basic management system to record the membership of one application, like class or something. It’s just like a to-do app which involves basic frontend and database, you can like add different member and record the information of the member.</p>
<p>This is a quiet simple application, I build this project just to have some experience in Java web, and it indeed help me to understand how the basic logic works behind the web.</p>
<p>The frontend was based on servlet, jsp, and the backend was based on mySQL;</p>
<h1 id="Development-of-Recommender-System-based-on-reviews-from-Amazon"><a href="#Development-of-Recommender-System-based-on-reviews-from-Amazon" class="headerlink" title="Development of Recommender System based on reviews from Amazon."></a>Development of Recommender System based on reviews from Amazon.</h1><p><a href="http://www.cnblogs.com/loujiayu/p/3859076.html" target="_blank" rel="noopener">参考资料</a></p>
<p>This is a course project, and our professor gives us dataset which contains 200000(two hundred thousand) reviews from amazon, and every review contains like the rating, the name and all kinds of information. And our job is to predict the helpfulness of one review and using latent factor algorithm to recommend items to the user. And the professor creates a competition on the Kaggle for us to upload different.</p>
<p>So in the first part, we just use different regression models to predict the helpfulness, like linear, Ridge, lasso and SVM, we even try to dive into the text of the review to gain more information, but due to the time reason, I didn’t get a good result, and now I think maybe I should try gradient boosting or random forest to get a better result.</p>
<p>And in the second part, we are given the user id and item id, and our job is to predict the rating of one item and based on the rating to recommend similar items to the user.</p>
<p>The latent factor algorithm is just like singular value decomposition. We are given the user-item-rating matrix, say a m*n matrix, and we are going to break the matrix to the form of two matrix multiplication like (m, k) and (k, n), and the k is the latent class, and the left matrix can explained as the user’s preference toward item, and the right matrix can explained as the characteristic matrix of item in the latent area. And our job is to find such composition.</p>
<p>user’s interest</p>
<p>item’s characteristic</p>
<p>下面我们简要介绍以下Latent Factor模型：</p>
<p>给定一个给定的用户行为数据集， 数据集包含的是所有的user， 所有的item， 以及每个user有过行为的item列表， 使用LFM对其建模后， 我们可以得到如下图所示的模型：</p>
<p><a href="http://img.blog.csdn.net/20130812142043312" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20130812142043312" alt="img"></a></p>
<p>R矩阵是user-item矩阵， 矩阵值表示的user i 对于 item j的兴趣度， 这正是我们要求的值。 对于一个user来说， 当计算出他对所有item的兴趣度后， 就可以进行排序并作出推荐。 LFM算法从数据集中抽出若干主题， 作为user和item之间连接的桥梁， 将R矩阵表示为P矩阵与Q矩阵的相乘。 其中P矩阵是user-class矩阵， 矩阵值Pij代替的是user i对 class j的兴趣度； Q矩阵是class-item矩阵， 矩阵值表示的是item j在class i中的权重， 权重越高越能作为此类的代表。 所以LFM根据如下公式来计算用户U对物品I的兴趣度：</p>
<p><a href="http://img.blog.csdn.net/20130812142048593" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20130812142048593" alt="img"></a></p>
<p>我们发现使用LFM后：</p>
<ol>
<li>我们不需要关心分类的角度， 结果都是基于用户行为统计自动聚类的， 全拼数据自己说了算。</li>
<li>不需要关心分类细度的问题， 通过设置LFM的最终分类数就可以控制粒度， 分类数越大， 粒度越细。</li>
<li>对于一个item， 并不是明确的划分到某一类， 而是计算其属于某一类的概率， 是一种标准的软分类。</li>
<li>对于一个user， 我们可以得到他对于每一类的兴趣度， 而不是只关心可见列表中的那几个类。</li>
<li>对于每一个class， 我们可以得到类中每个item的权重， 越能代表这个类的item， 权重越高。</li>
</ol>
<p>那么， 接下来的问题就是如何计算矩阵P和矩阵Q中参数值。 一般做法就是最优化损失函数来求参数， 在定义损失函数之前， 我们需要准备以下数据集并对兴趣度的取值做一说明。</p>
<h2 id="Difficulties"><a href="#Difficulties" class="headerlink" title="Difficulties"></a>Difficulties</h2><p>The optimization of the parameter, and the implementation of the whole project. And it takes like half an hour to run this algorithm locally.</p>
<h1 id="Boosting-Algorithm"><a href="#Boosting-Algorithm" class="headerlink" title="Boosting Algorithm"></a>Boosting Algorithm</h1><p>two main ideas:</p>
<ol>
<li>A combination of basic model can form a good-performance model.</li>
<li>Learn from error, using the recursion to reduce the rate of error.</li>
</ol>
<p>强学习算法： 存在一个多项式时间的学习算法以识别一组概念， 且识别的正确率很高；</p>
<p>弱学习算法： 识别一组概念的正确率仅比随机猜测策略好；</p>
<p>Boosting算法， 通过一系列的迭代来优化分类结果， 没迭代一次引入一个弱分类器， 来克服现在已经存在的弱分类器组合的shortcomings</p>
<p>在 Adaboosting算法中， 这个shortcomings的表征就是权值高的样本点， 而在gradient boosting算法中， 这个shortcomings的表征就是梯度。</p>
<h2 id="Adaboosting"><a href="#Adaboosting" class="headerlink" title="Adaboosting"></a>Adaboosting</h2><p>在整个训练集上维护一个分布权值向量W， 用赋予权重的训练集通过若分类算法产生假设（基学习器） y（x）， 然后计算错误率， 用得到的错误率去更新分布权值向量W， 对错误分类的样本分配更大的权值， 正确分类的样本赋予更小的权值。 每次更新后用相同的弱分类算法产生新的分类假设， 这些分类假设的序列构成多分类器， 对这些多分类器用加权的方法进行联合， 最后得到决策结果。</p>
<p><a href="https://images2015.cnblogs.com/blog/708708/201601/708708-20160129193753052-665222274.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/708708/201601/708708-20160129193753052-665222274.png" alt="img"></a></p>
<p>前一个学习器改变权重W， 然后再经过下一个学习器， 最终所有的学习器共同组成最后的学习器。</p>
<p>如果一个样本在前一个学习器中被误分， 那么它对应的权重会被加重， 相应地， 被正确分类的样本的权重会降低。</p>
<p>这里主要设计到两个权重的计算问题：</p>
<ol>
<li>样本的权值<ul>
<li>没有先验知识的情况下， 初始的分布应该为等概率分布， 样本数目为n， 权值为1/n;</li>
<li>每一次的迭代更新权值， 提高分错样本的权重。</li>
</ul>
</li>
<li>弱学习器的权重<ul>
<li>最后的强学习器是通过多个基学习器通过权值组合得到的。</li>
<li>通过权值体现不同基学习器的影响， 正确率高的基学习器权重高。 实际上是分类误差的一个函数。</li>
</ul>
</li>
</ol>
<h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>和Ada boosting不同， GradientBoosting在迭代的时候选择梯度下降的方向来保证最后的结果最好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Resume Review/" data-id="cjd8d3nya0006cuzhoc6y45ok" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/算法(二)/" class="article-date">
  <time datetime="2018-02-04T05:43:32.064Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-Part-2"><a href="#Algorithm-Part-2" class="headerlink" title="Algorithm Part 2"></a>Algorithm Part 2</h1><p>** 2018-01-02</p>
<h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root==p || root==q || root==null) return root;</span><br><span class="line">        TreeNode left= lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right= lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left!=null &amp;&amp; right!=null ) return root;</span><br><span class="line">        if(left==null) return right;</span><br><span class="line">        if(right==null) return left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        int min=Math.min(p.val, q.val);</span><br><span class="line">        int max=Math.max(p.val, q.val);</span><br><span class="line">        if(root.val&lt;min)  return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(root.val&gt;max)  return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if(x==0) return 0;</span><br><span class="line">        if(x&lt;=3) return 1;</span><br><span class="line">        int lo=2;</span><br><span class="line">        int hi=x/2;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+ (hi-lo)/2;</span><br><span class="line">            if(mid&lt; x/mid)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(mid== x/mid) return mid;</span><br><span class="line">            else hi= mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Left Table: Transaction Table</span><br><span class="line">Left Mapper: </span><br><span class="line">the transaction map() reads(transaction_id, product_id, user_id, quantity, amout) and emits a key-value pair composed of (user_id, product_id);</span><br><span class="line"></span><br><span class="line">Right Table: User Table</span><br><span class="line">Right Mapper:</span><br><span class="line">the user map() reads(user_id, location_id) and emits a key-value pair composed of (user_id, location_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Transaction mapper</span><br><span class="line">map(key value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String productID=tokens[1];</span><br><span class="line">  String userID= tokens[2];</span><br><span class="line">  outputKey= Pair(userID, 2);</span><br><span class="line">  outputValue= Pair(&quot;P&quot;, productID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// User mapper</span><br><span class="line">map(key, value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String userID= tokens[0];</span><br><span class="line">  String locationID= tokens[1];</span><br><span class="line">  outputKey= Pair(userID, 1);// make sure location shows before produ</span><br><span class="line">  outputValue=Pair(&quot;L&quot;, locationID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// values=List&lt;&gt;&#123;</span><br><span class="line">  Pair&lt;&quot;L&quot;, locationID&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID1&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID2&gt;,</span><br><span class="line">&#125;</span><br><span class="line">reduce(key, values)&#123;</span><br><span class="line">  locationID=&quot;undefined&quot;;</span><br><span class="line">  for(Pair&lt;left, right&gt; value: values)&#123;</span><br><span class="line">    if(value.left.equals(&quot;L&quot;))&#123;</span><br><span class="line">      locationID= value.right;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    productID= value.right;</span><br><span class="line">    emit(productID, locationID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的意思就是要设置label。</p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash.</li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int num: nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int num: nums2)&#123;</span><br><span class="line">            if(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)-1);</span><br><span class="line">                if(map.get(num)==0)&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125; </span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr= new int[res.size()];</span><br><span class="line">        for(int i=0; i&lt;res.size(); i++)&#123;</span><br><span class="line">            arr[i]= res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static double closestToT(double[] x, double t)&#123;</span><br><span class="line">    double prefix=0;</span><br><span class="line">  TreeSet&lt;Double&gt; set= new TreeSet&lt;&gt;();</span><br><span class="line">  set.add(prefix);</span><br><span class="line">  double leastDiff= Double.MAX_VALUE;</span><br><span class="line">  for(double i: x)&#123;</span><br><span class="line">      prefix+=i;</span><br><span class="line">    double rest= prefix-t;</span><br><span class="line">    // the next step is binary search, we can coporate the tree set api into it to solve this.</span><br><span class="line">    if(set.first()&lt;= rest)&#123;</span><br><span class="line">        double theSum= prefix- set.floor(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">    if(set.last()&gt; last)&#123;</span><br><span class="line">        double theSum= prefix- set.ceiling(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set.add(prefix);</span><br><span class="line">&#125;</span><br><span class="line">return leastDiff;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(int[] nums)&#123;</span><br><span class="line">    int ifRobbedPrevious= 0;</span><br><span class="line">  	int ifDidntRobPrevious=0;</span><br><span class="line">  	for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        int currRobbed= ifDidntRobPrevious+nums[i];</span><br><span class="line">      int currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);</span><br><span class="line">      </span><br><span class="line">      ifDidntRobPrevious= currNotRobbed;</span><br><span class="line">      ifRobbedPrevious= currRobbed;</span><br><span class="line">    &#125;</span><br><span class="line">  return Math.max(ifRobbedPrevious, ifDidntRobPrevious);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[][] direction= new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    public int longestIncreasingPath(int[][] matrix) &#123;</span><br><span class="line">        if(matrix.length==0 || matrix[0].length==0) return 0;</span><br><span class="line">        int[][] len= new int[matrix.length][matrix[0].length];</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int i=0; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;matrix[0].length; j++)&#123;</span><br><span class="line">                if(len[i][j]==0) dfs(i, j, len, matrix);</span><br><span class="line">                res= Math.max(res, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfs(int x, int y, int[][] len, int[][] matrix)&#123;</span><br><span class="line">        if(len[x][y]!=0) return len[x][y];</span><br><span class="line">        len[x][y]=1;</span><br><span class="line">        for(int i=0; i&lt;direction.length; i++)&#123;</span><br><span class="line">            int newX= x+ direction[i][0];</span><br><span class="line">            int newY= y+ direction[i][1];</span><br><span class="line">            if(newX&gt;=0 &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=0 &amp;&amp; newY&lt;matrix[0].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y])&#123;</span><br><span class="line">                len[x][y]= Math.max(len[x][y], 1+ dfs(newX, newY, len, matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param n: an integer</span><br><span class="line">     * @return: a boolean which equals to true if the first player will win</span><br><span class="line">     */</span><br><span class="line">    public boolean firstWillWin(int n) &#123;</span><br><span class="line">        if (n % 3 == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values) &#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    if(values.length==0) return false;</span><br><span class="line">    if(values.length&lt;3) return true;</span><br><span class="line">    // so here we are get to take number from left, so what happens h</span><br><span class="line">    // dp[i] means the max value we can get from i~end;</span><br><span class="line">    </span><br><span class="line">    // choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);</span><br><span class="line">    // choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);</span><br><span class="line">    int[] dp=new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        dp[i]=Math.max(values[i]+ Math.min((i+2&lt;dp.length?dp[i+2]:0),(i+3&lt;dp.length?dp[i+3]:0)), values[i]+ (i+1&lt;values.length? values[i+1]: 0)+ Math.min((i+3&lt;dp.length?dp[i+3]:0), (i+4&lt;dp.length?dp[i+4]:0)));</span><br><span class="line">    &#125;</span><br><span class="line">    //print(dp);</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int num: values)&#123;</span><br><span class="line">        sum+= num;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0]&gt;sum- dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values)&#123;</span><br><span class="line">    // dp[i]= sum[i]-max(dp[i-1], dp[i-2]);</span><br><span class="line">    int[] sum= new int[values.length];</span><br><span class="line">    int[] dp= new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        sum[i]= (i+1&lt;values.length?sum[i+1]:0)+values[i];</span><br><span class="line">        dp[i]= sum[i]- Math.min((i+1&lt;dp.length?dp[i+1]:0), (i+2&lt;dp.length?dp[i+2]:0));</span><br><span class="line">        //System.out.println(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum[0]-dp[0]&lt;dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Merge second and third piles =&gt; [4, 2, 4], score +2</span><br><span class="line">2. Merge the first two piles =&gt; [6, 4]，score +6</span><br><span class="line">3. Merge the last two piles =&gt; [10], score +10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class stonegame &#123;</span><br><span class="line">    public static int getMaxScore(int[] nums)&#123;</span><br><span class="line">        int[][] dp= new int[nums.length][nums.length];</span><br><span class="line">        //int[][] sum= new int[nums.length][nums.length];</span><br><span class="line">        int[] sum= new int[nums.length];</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum[i]= (i&gt;0?sum[i-1]:0)+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int len=1; len&lt;=nums.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len-1&lt;nums.length; i++)&#123;</span><br><span class="line">                int left= i;</span><br><span class="line">                int right= i+len-1;</span><br><span class="line">                if(left!=right)</span><br><span class="line">                    dp[left][right]=Integer.MAX_VALUE;</span><br><span class="line">                for(int mid= left; mid&lt;right; mid++)&#123;</span><br><span class="line">                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+1][right]+sum[right]-(left&gt;0?sum[left-1]:0), dp[left][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] nums= new int[]&#123;4,4,5,9&#125;;</span><br><span class="line">        System.out.println(getMaxScore(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h3><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class minAdjustCost &#123;</span><br><span class="line">    /**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个</span><br><span class="line">     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价</span><br><span class="line">     * 之和最小是多少。**/</span><br><span class="line">    public int MinAdjustmentCost(ArrayList&lt;Integer&gt;A, int target)&#123;</span><br><span class="line">        int n= A.size();</span><br><span class="line">        int[][] f= new int[n+1][101];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;</span><br><span class="line">            f[0][i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;=100; j++)&#123;</span><br><span class="line">                if(f[i-1][j]!= Integer.MAX_VALUE)&#123;// if the previous is restricted to the condition;</span><br><span class="line">                    for(int k=0; k&lt;=100; k++)&#123;</span><br><span class="line">                        if(Math.abs(j-k)&lt;= target)&#123;</span><br><span class="line">                            if(f[i][k]&gt; f[i-1][j]+Math.abs(A.get(i-1)-k))</span><br><span class="line">                                f[i][k] = f[i-1][j] + Math.abs(A.get(i-1)-k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt;= 100; ++i)</span><br><span class="line">            if (f[n][i] &lt; ans)</span><br><span class="line">                ans = f[n][i];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int nthUglyNumber(int n) &#123;</span><br><span class="line">        int[] dp= new int[n];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        int index_2= 0;</span><br><span class="line">        int index_3= 0;</span><br><span class="line">        int index_5= 0;</span><br><span class="line">        // we say it&apos;s a merge process;</span><br><span class="line">        for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">            int candidate_2=2* dp[index_2];</span><br><span class="line">            int candidate_3=3* dp[index_3];</span><br><span class="line">            int candidate_5=5* dp[index_5];</span><br><span class="line">            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);</span><br><span class="line">            if(dp[i]== candidate_2) index_2++;</span><br><span class="line">            if(dp[i]== candidate_3) index_3++;</span><br><span class="line">            if(dp[i]== candidate_5) index_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param root: param root: The root of the binary search tree</span><br><span class="line">     * @param k1: An integer</span><br><span class="line">     * @param k2: An integer</span><br><span class="line">     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span><br><span class="line">     */</span><br><span class="line">    // public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">    //     // write your code here</span><br><span class="line">    //     if(root==null) return new ArrayList&lt;&gt;();</span><br><span class="line">    //     if(k2&lt;root.val) return searchRange(root.left, k1, k2);</span><br><span class="line">    //     if(k1&gt;root.val) return searchRange(root.right,k1, k2);</span><br><span class="line">    //     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">    //     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);</span><br><span class="line">    //     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);</span><br><span class="line">    //     res.addAll(left);</span><br><span class="line">    //     res.add(root.val);</span><br><span class="line">    //     res.addAll(right);</span><br><span class="line">    //     return res;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, k1, k2, result);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void helper(TreeNode root, int k1, int k2, ArrayList&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line"></span><br><span class="line">        // in-order binary tree iteration</span><br><span class="line">        helper(root.left, k1, k2, result);</span><br><span class="line">        if (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k1, k2, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; majorityElement(int[] nums)&#123;</span><br><span class="line">    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  if(nums.length==0) return res;</span><br><span class="line">  int candidate_1= nums[0];</span><br><span class="line">  int candidate_2= nums[0];</span><br><span class="line">  int count_1=0;</span><br><span class="line">  int count_2=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">	if(nums[i]==candidate_1)&#123;</span><br><span class="line">        count_1++;</span><br><span class="line">    &#125;else if(nums[i]== candidate_2)&#123;</span><br><span class="line">        count_2++;</span><br><span class="line">    &#125;else if(count_1==0)&#123;</span><br><span class="line">        count_1=1;</span><br><span class="line">      	candidate_1=nums[i];</span><br><span class="line">    &#125;else if(count_2==0)&#123;</span><br><span class="line">        count_2=1;</span><br><span class="line">      	candidate_2= nums[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        count_1--;</span><br><span class="line">      	count_2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count_1=0;</span><br><span class="line">  count_2=0;</span><br><span class="line">  for(int num: nums)&#123;</span><br><span class="line">      if(num==candidate_1) count_1++;</span><br><span class="line">    else if(num==candidate_2) count_2++;</span><br><span class="line">  &#125;</span><br><span class="line">  if(count_1&gt; nums.length/3) res.add(candidate_1);</span><br><span class="line">  if(count_2&gt; nums.length/3)</span><br><span class="line">    res.add(candidate_2);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices)&#123;</span><br><span class="line">    int firstBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int firstSell=0;</span><br><span class="line">  	int secondBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int secondSell= 0;</span><br><span class="line">  	for(int price: prices)&#123;</span><br><span class="line">        secondSell= Math.max(secondBuy+price, secondSell);</span><br><span class="line">      	secondBuy= Math.max(firstSell- price, secondBuy);</span><br><span class="line">      	firstSell= Math.max(firstBuy+price, firstSell);</span><br><span class="line">      	firstBuy= Math.max(firstBuy, -price);</span><br><span class="line">    &#125;</span><br><span class="line">  return secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // state 1: after buy;</span><br><span class="line">        // state 2: after sell;</span><br><span class="line">        // buy[i] means until day i, the last action is buy, the max profit;</span><br><span class="line">        // buy[i]=sell[i-2]-price[i];</span><br><span class="line">        // sell[i] means until day j, the last action is sell, the max profit;</span><br><span class="line">        // sell[i]=buy[i-1]+ price[i];</span><br><span class="line">        if(prices.length==0) return 0;</span><br><span class="line">        int[] buy= new int[prices.length];</span><br><span class="line">        int[] sell= new int[prices.length];</span><br><span class="line">        buy[0]= -prices[0];</span><br><span class="line">        for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">            buy[i]= Math.max(buy[i-1], (i&gt;=2?sell[i-2]:0)-prices[i]);</span><br><span class="line">            sell[i]= Math.max(sell[i-1], buy[i-1]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell[prices.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices, int fee)&#123;</span><br><span class="line">    int[] buy= new int[prices.length];</span><br><span class="line">  	int[] sell= new int[prices.length];</span><br><span class="line">  	buy[0]= -prices[0];</span><br><span class="line">  	sell[0]= 0;</span><br><span class="line">  	for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">        buy[i]= Math.max(sell[i-1]-prices[i], buy[i-1]);</span><br><span class="line">      	sell[i]= Math.max(buy[i-1]+prices[i]- fee, sell[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">  	return sell[prices.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros &amp;&amp; Sort Colors"></a>Move zeros &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums)&#123;</span><br><span class="line">    int p1= 0;</span><br><span class="line">  	int p2= nums.length-1;</span><br><span class="line">  	int index=0;</span><br><span class="line">  	while(index&lt; nums.length)&#123;</span><br><span class="line">        if(nums[index]==0 &amp;&amp; index&gt; p1)&#123;</span><br><span class="line">            swap(p1, index, nums);</span><br><span class="line">          	p1++;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	if(nums[index]==2 &amp;&amp; index&lt;p2)&#123;</span><br><span class="line">            swap(p2, index, nums);</span><br><span class="line">          	p2--;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	index++;</span><br><span class="line">    &#125;</span><br><span class="line">  	public void swap(int p1, int p2, int nums)&#123;</span><br><span class="line">        int temp= nums[p1];</span><br><span class="line">      	nums[p1]= nums[p2];</span><br><span class="line">      	nums[p2]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>
<p>这里还有一道follow up：</p>
<p>Given an array of integers, remove the duplicate number in it. You should:</p>
<ol>
<li>Do it in place in the array.</li>
<li>Move the unique numbers to the front of the array</li>
<li>Return the total number of the unique numbers.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int deduplicatation(int[] nums)&#123;</span><br><span class="line">  if(nums.length==0) return 0;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  int len=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= nums[len])&#123;</span><br><span class="line">      swap(i, ++len, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-220-Contains-Duplicate"><a href="#Leetcode-220-Contains-Duplicate" class="headerlink" title="Leetcode 220. Contains Duplicate"></a>Leetcode 220. Contains Duplicate</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k;</p>
<p>这道题其实是一道很不错的题目， 对于这道题目， 我们可以有两个解法。</p>
<p>解法1： 利用TreeSet, 维持一个k大小的TreeSet， 每次进行查看， 复杂度 O(n lgk);</p>
<p>解法2： 利用bucket sort，限制bucket的大小， 使得处于一个bucket内的两个数字之差不能大于t, 这里我们选取t+1为bucket size， 而后每次查看前后两个两个bucket是否存在符合条件的点（因为两个相邻bucket之间也有可能存在的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">        if(k&lt;1 || t&lt;0) return false;</span><br><span class="line">        Map&lt;Long, Long&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            long remappedNum= (long) nums[i]- Integer.MIN_VALUE;</span><br><span class="line">            long bucket= remappedNum/((long) t +1);</span><br><span class="line">            if(map.containsKey(bucket)</span><br><span class="line">                    || (map.containsKey(bucket-1) &amp;&amp; remappedNum- map.get(bucket-1)&lt;=t)</span><br><span class="line">                    || (map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1)-remappedNum&lt;=t))</span><br><span class="line">                return true;</span><br><span class="line">            if(map.entrySet().size()&gt;=k)&#123;</span><br><span class="line">                long lastBucket=((long) nums[i-k]- Integer.MIN_VALUE)/((long) t+1);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Solution 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">  // floor(x) is the maximum number but still &lt;x</span><br><span class="line">  // ceiling(x) is the minimum number but still&gt;x</span><br><span class="line">    if(nums==null || nums.length==0 || k&lt;=0)  return false;</span><br><span class="line">  final TreeSet&lt;Integer&gt; values= new TreeSet&lt;&gt;();</span><br><span class="line">  for(int ind=0; ind&lt;nums.length; ind++)&#123;</span><br><span class="line">      final Integer floor= values.floor(nums[ind]+ t);</span><br><span class="line">    final Integer ceil= values.ceiling(nums[ind]-t);</span><br><span class="line">    if((floor!=null &amp;&amp; floor&gt;nums[ind])  || (ceil!=null &amp;&amp; ceil&lt;=nums[ind]))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    values.add(nums[ind]);</span><br><span class="line">            if (ind &gt;= k) &#123;</span><br><span class="line">                values.remove(nums[ind - k]);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287. Find the Duplicate Number"></a>Leetcode 287. Find the Duplicate Number</h3><p>Given an array nums containing n+1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int findDuplicate(int[] nums)&#123;</span><br><span class="line">  	int slow= nums[0];</span><br><span class="line">  	int fast= nums[nums[0]];</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">  	fast=0;</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">  	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有一些细节需要注意：</p>
<ol>
<li>对于slow和fast的初始化， 我们为什么要这么设；</li>
<li>在找到交点之后我们为什么又设置为0；</li>
</ol>
<p>以上两点都要从我们对于这道题目原理的理解进行出发开始解答， fast走了多远， slow走了多远， 把带环的linkedlist示意图画出来大概就能理解了。</p>
<h3 id="Leetcode-41-First-Missing-Positive"><a href="#Leetcode-41-First-Missing-Positive" class="headerlink" title="Leetcode 41. First Missing Positive"></a>Leetcode 41. First Missing Positive</h3><p>Given an unsorted integer array, find the first missing positive integer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums)&#123;</span><br><span class="line">  int end= nums.length -1;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">     if(nums[i]==i+1) continue;</span><br><span class="line">     int index= nums[i]-1;</span><br><span class="line">     if(index&gt;=0 &amp;&amp; index&lt;nums.length &amp;&amp; nums[index]!= nums[i])&#123;</span><br><span class="line">       swap(index, i, nums);</span><br><span class="line">       i--;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= i+1) return i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums.length+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两边扫描的方法， 第一遍扫描， 将可以放入正确slot的值放入其正确的slot， 第二遍扫描， 找到第一个不属于自己地方的num。</p>
<h3 id="Find-Two-missing-numbers"><a href="#Find-Two-missing-numbers" class="headerlink" title="Find Two missing numbers"></a>Find Two missing numbers</h3><p>Given an array of n unique integers where each element in the array is in range(1, n). The array has all distinct elements and size of array is(n-2). Hence Two numbers from the range are missing from this array. Find the two missing numbers.</p>
<p>Below are steps:</p>
<ol>
<li><p>Find XOR of all array elements and natural numbers from 1 to n.</p>
</li>
<li><p>As per the property of XOR, same elements will cancel out and we will be left with the two missing numbers A XOR B. But we don’t know the exact numbers.</p>
</li>
<li><p>A bit is set in XOR only of corresponding bits in A and B are different. This is the crucial step to understand.</p>
</li>
<li><p>We take a set bit in XOR. Let us consider the rightmost set bit in XOR, for example , we miss 2 and 4 in {1, 3, 5, 6}. the OXR we get is 110, then set_bit_no= 010.</p>
</li>
<li><p>Now again if we XOR all the elements of arr[] and 1 to n that have rightmost bit set we will get one of the repeating numbers, say x.</p>
<p>Ex:</p>
<p>Elements in arr[] with bit set: {3, 6}</p>
<p>Elements from 1 to n with bit set {2, 3, 6}</p>
<p>Result of XOR all these is x=2;</p>
</li>
<li><p>Similarly, if we XOR all the elements of arr[] and 1 to n that have rightmost bit not set, we will get the other element, say y.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void findTwoMissingNumbers(int[] arr, int n)&#123;</span><br><span class="line">  int XOR= arr[0];</span><br><span class="line">  for(int i=1; i&lt;n-2; i++)&#123;</span><br><span class="line">    XOR^=arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    XOR^=i;</span><br><span class="line">  &#125;</span><br><span class="line">  //Get a set bit of XOR(we get the rightmost set bit)</span><br><span class="line">  int set_bit_no= XOR &amp; ~(XOR-1);</span><br><span class="line">  // now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element.</span><br><span class="line">  int x=0, y=0;</span><br><span class="line">  for(int i=0; i&lt;n-2; i++)&#123;</span><br><span class="line">    if((arr[i] &amp; set_bit_no)&gt; 0)&#123;</span><br><span class="line">      x= x^arr[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y ^arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    if((i&amp; set_bit_no)&gt;0)&#123;</span><br><span class="line">      x= x^i;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y^i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // Here we get x and y, which is the result;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><a href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。" class="headerlink" title="给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。"></a>给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</h3><p>For each node:</p>
<ol>
<li>add node to a HashSet</li>
<li>increment the block count by one.</li>
<li>If the node’s previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counter blocks.</li>
</ol>
<h3 id="What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><a href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists" class="headerlink" title="What’s the time complexity of merge k sorted linked lists;"></a>What’s the time complexity of merge k sorted linked lists;</h3><p>Given K sorted linked lists of size n each, merge them and print the sorted output.</p>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>A Simple Solution is to initialize result as first list. Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way. Time complexity of this solution is O(N2) where N is total number of nodes, i.e., N = kn.</p>
<h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>A better solution is to use Min Heap based solution. Time complexity of this solution would be O(nk Log k); n is the size of the list.</p>
<h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><p>Merge recursively, the time complexity is just like method 2;</p>
<h3 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472 Concatenated Words"></a>Leetcode472 Concatenated Words</h3><p>Given a list of words(without duplicates). Please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of least shorter words in the given array,</p>
<p>其实这道题目本质上就是wordbreak， 用wordbreak的思路就能做出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        if(words.length==0) return res;</span><br><span class="line">        Arrays.sort(words, (s1, s2)-&gt;&#123;</span><br><span class="line">            return s1.length()- s2.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        Set&lt;String&gt; dict= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;words.length; i++)&#123;</span><br><span class="line">            if(canForm(dict, words[i]))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dict.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean canForm(Set&lt;String&gt; dict, String word)&#123;</span><br><span class="line">        if(dict.size()==0) return false;</span><br><span class="line">        boolean[] dp= new boolean[word.length()+1];</span><br><span class="line">        dp[0]= true;</span><br><span class="line">        for(int i=1; i&lt;=word.length(); i++)&#123;</span><br><span class="line">            for(int j=i-1; j&gt;=0; j--)&#123;</span><br><span class="line">                if(!dp[j]) continue;</span><br><span class="line">                if(dict.contains(word.substring(j, i)))&#123;</span><br><span class="line">                    dp[i]= true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="491-Increasing-subsequence"><a href="#491-Increasing-subsequence" class="headerlink" title="491. Increasing subsequence"></a>491. Increasing subsequence</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.</p>
<p>这道题目， 属于对于去重的考察比较好的一道题目， 为了完成去重， 我们要确定， 每一次加进去的数字都是第一次被访问的。 并且， 这是一个未排序的数列， 所以只能用hashset来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        helper(0, nums, new ArrayList&lt;&gt;(), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void helper(int pos, int[] nums, List&lt;Integer&gt; unit, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(unit.size()&gt;=2)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(unit));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; used= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i= pos; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(used.contains(nums[i])) continue;</span><br><span class="line">            if(unit.size()==0 || unit.get(unit.size()-1)&lt;=nums[i])&#123;</span><br><span class="line">                used.add(nums[i]);</span><br><span class="line">                unit.add(nums[i]);</span><br><span class="line">                helper(i+1, nums, unit, res);</span><br><span class="line">                unit.remove(unit.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zuma-Game"><a href="#Zuma-Game" class="headerlink" title="Zuma Game"></a>Zuma Game</h3><p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>
<p>Each time, you may choose a ball in your hand, and insert it into the row(including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>
<p>Find the minimum balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&apos;t exceed 5&quot;</span><br><span class="line"></span><br><span class="line">public int findMinStep(String board, String hand) &#123;</span><br><span class="line">    int[] handCount = new int[26];</span><br><span class="line">    for (int i = 0; i &lt; hand.length(); ++i) ++handCount[hand.charAt(i) - &apos;A&apos;];</span><br><span class="line">    int rs = helper(board + &quot;#&quot;, handCount);  // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.</span><br><span class="line">    return rs == MAXCOUNT ? -1 : rs;</span><br><span class="line">&#125;</span><br><span class="line">private int helper(String s, int[] h) &#123;</span><br><span class="line">    s = removeConsecutive(s);     </span><br><span class="line">    if (s.equals(&quot;#&quot;)) return 0;</span><br><span class="line">    int  rs = MAXCOUNT, need = 0;</span><br><span class="line">    for (int i = 0, j = 0 ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        if (s.charAt(j) == s.charAt(i)) continue;</span><br><span class="line">        need = 3 - (j - i);     //balls need to remove current consecutive balls.</span><br><span class="line">        if (h[s.charAt(i) - &apos;A&apos;] &gt;= need) &#123;</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] -= need;</span><br><span class="line">            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] += need;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br><span class="line">//remove consecutive balls longer than 3</span><br><span class="line">private String removeConsecutive(String board) &#123;</span><br><span class="line">    for (int i = 0, j = 0; j &lt; board.length(); ++j) &#123;</span><br><span class="line">        if (board.charAt(j) == board.charAt(i)) continue;</span><br><span class="line">        if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));</span><br><span class="line">        else i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return board;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解， 每次计算需要多少个球进行一次消失， 然后对board进行更新。进行递归计算。</p>
<h3 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210. Course Schedule II"></a>Leetcode 210. Course Schedule II</h3><p>除了喜闻乐见的bfs（即 topologic sort）做法来完成这一道题， 还可以用dfs来做， 所不同的是， 我们在这里用stack进行递归， 这样保证， 如果p-&gt;q, 那么p肯定属于stack的外层， 也就是说 整个stack的结构肯定是符合Schedule的。 这个做法还是非常之骚气的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   boolean hasCycle=false;</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites)&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map= new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        for(int[] prerequisite: prerequisites)&#123;</span><br><span class="line">            int curr=prerequisite[0];</span><br><span class="line">            int prev=prerequisite[1];</span><br><span class="line">            if(!map.containsKey(prev))&#123;</span><br><span class="line">                map.put(prev, new ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(prev).add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int[] visited= new int[numCourses];</span><br><span class="line">        for(int i=0; i&lt;numCourses; i++)&#123;</span><br><span class="line">            dfs(i, visited, map, stack);</span><br><span class="line">            if(hasCycle) return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[stack.size()];</span><br><span class="line">        int index=0;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            res[index++]=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int curr,int[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; map, Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">        if(visited[curr]==1)&#123;</span><br><span class="line">            hasCycle=true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(visited[curr]==-1) return;</span><br><span class="line">        if(!map.containsKey(curr))&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            visited[curr]=-1;</span><br><span class="line">            return;</span><br><span class="line">            // we have find the terminate, which means the end of one chain;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[curr]=1;</span><br><span class="line">        List&lt;Integer&gt; next= map.get(curr);</span><br><span class="line">        for(int num: next)&#123;</span><br><span class="line">            dfs(num, visited, map, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curr);</span><br><span class="line"></span><br><span class="line">        // post order</span><br><span class="line">        visited[curr]=-1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-57-Insert-Interval"><a href="#Leetcode-57-Insert-Interval" class="headerlink" title="Leetcode 57. Insert Interval"></a>Leetcode 57. Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals(merge if necessary). You may assume that the intervals were initially sorted according to their start time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        List&lt;Interval&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        Interval prev= newInterval;</span><br><span class="line">        for(Interval curr: intervals)&#123;</span><br><span class="line">            if(prev==null)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.end&lt;prev.start)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.start&lt;=prev.end)&#123;</span><br><span class="line">                prev.start = Math.min(prev.start,curr.start);</span><br><span class="line">                prev.end= Math.max(prev.end, curr.end);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.add(prev);</span><br><span class="line">                res.add(curr);</span><br><span class="line">                prev= null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prev!=null) res.add(prev);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清楚思路， 对于这道题， 我们所要完成的功能是把interval插进去。</p>
<ol>
<li>interval 已经插入过了， 那么interval是null， 我们直接continue;</li>
<li>interval在左边， 我们插入interval， 插入当前， 然后将interval置为null,表示已经插入过了。</li>
<li>interval在右边， 我们将curr插入， 继续遍历。</li>
<li>interval和当前重叠， 我们将curr 与interval merge， 作为新的interval；</li>
</ol>
<h3 id="Leetcode-630-Course-Schedule-III"><a href="#Leetcode-630-Course-Schedule-III" class="headerlink" title="Leetcode 630 Course Schedule III"></a>Leetcode 630 Course Schedule III</h3><p>There are n different online courses numbered from 1 to n. Each course has some duration(course length) t, and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given n online courses represented by pairs(t, d), your task is to find the maximal number of courses that can be taken;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">  public int scheduleCourse(int[][] courses)&#123;</span><br><span class="line">    Arrays.sort(courses, (a, b)-&gt; a[1]-b[1]);// sort the courses by their deadlines. Greedy! We have to deal with courses with early deadlines first</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;&gt;((a, b)-&gt; b-a);</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int[] c: courses)&#123;</span><br><span class="line">      time+=c[0];</span><br><span class="line">      pq.add(c[0]);</span><br><span class="line">      if(time&gt;c[1]) time-=pq.poll();// if time exceeds, drop the previous course which costs the most time.</span><br><span class="line">    &#125;</span><br><span class="line">    return pq.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题算是比较蛋疼的了。 记住做法就是了， 每一步， 我们先放入队列中， 如果发现不能满足条件的话， 我们删除占用时间最多的， 这样的话得到的结果总是最好的。</p>
<p>其实还是比较intuitive的。</p>
<h3 id="Leetcode-621-Task-Scheduler"><a href="#Leetcode-621-Task-Scheduler" class="headerlink" title="Leetcode 621. Task Scheduler"></a>Leetcode 621. Task Scheduler</h3><p>其实这道题目， 如果能够理解题目的话， 并不难。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int leastInterval(char[] tasks, int n)&#123;</span><br><span class="line">  int[] c= new int[26];</span><br><span class="line">  for(char t: tasks)&#123;</span><br><span class="line">    c[t-&apos;A&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(c);</span><br><span class="line">  int i=25;</span><br><span class="line">  while(i&gt;=0 &amp;&amp; c[i]==c[25]) i--;</span><br><span class="line">  return Math.max(tasks.length, (c[25]-1)*(n+1)+25-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于形成了一个框架， 然后往这个框架里面放元素。</p>
<h3 id="Leetcode-546-Remove-Boxes"><a href="#Leetcode-546-Remove-Boxes" class="headerlink" title="Leetcode 546. Remove Boxes"></a>Leetcode 546. Remove Boxes</h3><p>Given several boxes with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color(composed of k boxes, k&gt;=1), remove them and get k*k points.</p>
<p>Find the maximum points you can get.</p>
<p>暴力 backtracking 做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeBoxes(int[] boxes) &#123;</span><br><span class="line">        if(boxes.length==0) return 0;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int box: boxes)&#123;</span><br><span class="line">            list.add(box);</span><br><span class="line">        &#125;</span><br><span class="line">        return removeBoxes(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int removeBoxes(List&lt;Integer&gt; boxes)&#123;</span><br><span class="line">        if(boxes.size()==0) return 0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;boxes.size(); i++)&#123;</span><br><span class="line">            int start=i;</span><br><span class="line">            while(i&lt;boxes.size() &amp;&amp; boxes.get(i)==boxes.get(start)) i++;</span><br><span class="line">            List&lt;Integer&gt; next= new ArrayList&lt;&gt;();</span><br><span class="line">            for(int idx=0; idx&lt;boxes.size(); idx++)&#123;</span><br><span class="line">                if(idx&gt;=start &amp;&amp; idx&lt;i) continue;</span><br><span class="line">                next.add(boxes.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res, removeBoxes(next)+ (i-start)*(i-start));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top-down dp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int remooveBoxes(int[] boxes)&#123;</span><br><span class="line">  int n= boxes.length;</span><br><span class="line">  int[][][] dp= new int[n][n][n];</span><br><span class="line">  return removeBoxesSum(boxes, 0, n-1, 0, dp);</span><br><span class="line">&#125;</span><br><span class="line">private int removeBoxesSub(int[] boxes, int i, int j, int k, int[][] dp)&#123;</span><br><span class="line">  if(i&gt;j) return 0;</span><br><span class="line">  if(dp[i][j][k]&gt;0) return dp[i][j][k];</span><br><span class="line">  for(; i+1&lt;= j &amp;&amp; boxes[i+1]==boxes[i], i++, k++);// optimization: all boxes of the same color counted continuously from the first box should be grouped together;</span><br><span class="line">  int res=(k+1)*(k+1)+ removeBoxesSub(i+1, j. 0, dp);</span><br><span class="line">  for(int m= i+1; m&lt;=j; m++)&#123;</span><br><span class="line">    if(boxes[i]==boxes[m])&#123;</span><br><span class="line">      res= Math.max(res, removeBoxesSub(boxes, i+1, m-1, 0, dp)+ removeBoxesSub(boxes, m, j, k+1, dp));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> dp[i][j][k]= res;</span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k)&#123;</span><br><span class="line">  int[] count= new int[128];</span><br><span class="line">  int max=0;</span><br><span class="line">  int start=0;</span><br><span class="line">  for(int end=0; end&lt; s.length(); end++)&#123;</span><br><span class="line">    max= Math.max(max, ++count[s.charAt(end)]);</span><br><span class="line">    if(max+k&lt;=end-start)&#123;</span><br><span class="line">      count[s.charAt(start++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s.length()- start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n);</p>
<p>For example:</p>
<p>S=”ADOBECODEBANC”</p>
<p>T=”ABC”</p>
<p>Minimum window is “BANC”</p>
<p>这道题是window的一道很经典的题目了， 碰到这种题目的时候， 我们需要让window满足一个性质， 然后移动左右边界去更新。 得到我们想要的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t)&#123;</span><br><span class="line">  int count=0;</span><br><span class="line">  int[] cnt= new int[256];</span><br><span class="line">  for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">    cnt[t.charAt(i)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  int left= 0;</span><br><span class="line">  int min= Integer.MAX_VALUE;</span><br><span class="line">  String res= &quot;&quot;;</span><br><span class="line">  for(int right= 0; right&lt;s.length(); right++)&#123;</span><br><span class="line">    cnt[s.charAt(right)]--;</span><br><span class="line">    if(cnt[s.charAt(right)]&gt;=0) count++;</span><br><span class="line">    while(count&gt;= t.length())&#123;</span><br><span class="line">      if(right-left+1&lt;min)&#123;</span><br><span class="line">        min= right- left+1;</span><br><span class="line">        res=s.substring(left, right+1);</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[s.charAt(left)]++;</span><br><span class="line">      if(cnt[s.charAt(left)]&gt;0) count--;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-84-Largest-Rectangle-in-Histogram"><a href="#Leetcode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="Leetcode 84. Largest Rectangle in Histogram"></a>Leetcode 84. Largest Rectangle in Histogram</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>这道题目很经典， 在面试的时候stack基本都是这样用， 用来维持一个顺序， 我们在这里维持一个递增的stack， 每次发现数字比栈顶的数字要小的情况时， 对于栈顶而言， 我们找到了以栈顶为最高点的最大的长方形， 因此该长方形面积也能算出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        //maintain a stack which is strictly non-decreasing</span><br><span class="line">        int[] arr= new int[heights.length+1];</span><br><span class="line">        for(int i=0; i&lt;heights.length; i++)&#123;</span><br><span class="line">            arr[i]=heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&gt;arr[i])&#123;</span><br><span class="line">                int height= arr[stack.pop()];</span><br><span class="line">                int right=i-1;</span><br><span class="line">                int left=(stack.isEmpty()?-1:stack.peek())+1;</span><br><span class="line">               //System.out.println(&quot;height=&quot;+ height);</span><br><span class="line">               // System.out.println(&quot;width=&quot;+ (right-left+1));</span><br><span class="line">                res= Math.max(res, (right-left+1)* height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-218-the-skyline-problem"><a href="#Leetcode-218-the-skyline-problem" class="headerlink" title="Leetcode 218 the skyline problem"></a>Leetcode 218 the skyline problem</h3><p>在这道题里面， 我们给定了每个建筑的位置以及高度， 要我们输出一系列点（天际线）： A key point is the left endpoint of a horizontal line segment.</p>
<p>想法：</p>
<p>for position in sorted(all start points and all end points)</p>
<p>if this position is a start point:</p>
<p> add its height</p>
<p>if this position is a end point:</p>
<p> delete its height</p>
<p>Compare current max height with previous height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;int[]&gt; getSkyline(int[][] buildings)&#123;</span><br><span class="line">  List&lt;int[]&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;int[]&gt; height= new ArrayList&lt;&gt;();</span><br><span class="line">  for(int[] b: buildings)&#123;</span><br><span class="line">    height.add(new int[]&#123;b[0], -b[2]&#125;);</span><br><span class="line">    height.add(new int[]&#123;b[1], b[2]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(height, (a, b)-&gt;&#123;</span><br><span class="line">    if(a[0]==b[0])&#123;</span><br><span class="line">      return a[1]-b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0]-b[0];</span><br><span class="line">  &#125;);</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;Integer&gt;((a, b)-&gt;&#123;return b-a;&#125;);</span><br><span class="line">  pq.offer(0);</span><br><span class="line">  int prev_max=0;</span><br><span class="line">  for(int[] h: height)&#123;</span><br><span class="line">    if(h[1]&lt;0)&#123;</span><br><span class="line">      pq.offer(-h[1]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pq.remove(h[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int max= pq.peek();</span><br><span class="line">    if(prev_max!= max)&#123;</span><br><span class="line">      res.add(new int[]&#123;h[0], max&#125;);</span><br><span class="line">      prev_max= max;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-239-Sliding-Window-Maximum"><a href="#Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="Leetcode 239. Sliding Window Maximum"></a>Leetcode 239. Sliding Window Maximum</h3><p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>这道题目还是关于stack的题目， 所不同的是， 由于其特殊性， 这个栈的大小不能大于k， 所以在这里， 我们维持一个不大于k且递减的栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        // maintain a decreasing linkedlist;</span><br><span class="line">        if(nums.length==0) return new int[0];</span><br><span class="line">        Deque&lt;Integer&gt; deque= new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res= new int[nums.length- k+1];</span><br><span class="line">        int index=0;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            while(deque.size()!=0 &amp;&amp; nums[i]&gt;nums[deque.peekLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            if(i-deque.peekFirst()+1&gt;k)&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&gt;=k-1) res[index++]= nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315. Count of Smaller Numbers After Self."></a>Leetcode 315. Count of Smaller Numbers After Self.</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p>这道题可以用不同的方式来做， 比如说建树， merge sort， binarySearch等等， 这里我们使用建树和binarySearch两种方式来做。</p>
<h4 id="buildTree"><a href="#buildTree" class="headerlink" title="buildTree:"></a>buildTree:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        int val;</span><br><span class="line">        int size; // to kept the size node on his left;</span><br><span class="line">        int duplicate;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.size=0;</span><br><span class="line">            this.duplicate=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(nums.length==0) return res;</span><br><span class="line">        TreeNode root= new TreeNode(nums[nums.length-1]);</span><br><span class="line">        res.add(0);</span><br><span class="line">        for(int i=nums.length-2; i&gt;=0; i--)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(nums[i]);</span><br><span class="line">            insert(root, node, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode insert(TreeNode root, TreeNode node, int curr, List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.val&gt;root.val)&#123;</span><br><span class="line">            curr+=root.size+root.duplicate;</span><br><span class="line">            root.right=insert(root.right, node, curr, res);</span><br><span class="line">        &#125;else if(node.val==root.val)&#123;</span><br><span class="line">            root.duplicate++;</span><br><span class="line">            res.add(root.size+curr);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root.size++;</span><br><span class="line">            root.left=insert(root.left, node, curr, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= nums.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">            int index= findIndex(list, nums[i]);</span><br><span class="line">            //System.out.println(index);</span><br><span class="line">            res.add(index);</span><br><span class="line">            if(index==list.size()) list.add(nums[i]);</span><br><span class="line">            else list.add(index, nums[i]);</span><br><span class="line">            //System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findIndex(List&lt;Integer&gt; list, int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= list.size()-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+(hi- lo)/2;</span><br><span class="line">            if(list.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种做法可以延伸至 reverse pairs 这一道题目。</p>
<h3 id="Leetcode-312-Burst-Balloons"><a href="#Leetcode-312-Burst-Balloons" class="headerlink" title="Leetcode 312. Burst Balloons"></a>Leetcode 312. Burst Balloons</h3><p>注意思维方式： 我们关注的是最后一个爆掉的气球。 关于dp的话， 注意边界和构造就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int[] arr= new int[nums.length+2];</span><br><span class="line">        arr[0]=1;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            arr[i+1]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[nums.length+1]=1;</span><br><span class="line">        int[][] dp= new int[arr.length][arr.length];</span><br><span class="line">        for(int len=2;  len&lt;=arr.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len&lt;arr.length; i++)&#123;</span><br><span class="line">                int start= i;</span><br><span class="line">                int end=i+len;</span><br><span class="line">                for(int j= start+1; j&lt;end; j++)&#123;</span><br><span class="line">                    dp[start][end]= Math.max(dp[start][j]+ dp[j][end]+ arr[start]*arr[end]*arr[j], dp[start][end]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set-Intersection-Size-At-least-Two"><a href="#Set-Intersection-Size-At-least-Two" class="headerlink" title="Set Intersection Size At least Two"></a>Set Intersection Size At least Two</h3><p>An integer interval {a, b}( for integers a&lt;b) is a set of all consecutive integers from a to b, including a and b.</p>
<p>Find the minimum size of a set S such that for every integer intervals A in intervals, the intersection of S with A has size at east 2.</p>
<p>Example 1:</p>
<p>Input: intervals[[1, 3], [1, 4], [2, 5], [3,5]]</p>
<p>Output: 3</p>
<p>思路， 在选择区间中的元素时， 我们可以随意选， 但随意选的后果就是不能让set最优， 所以可以从侧面反映出如果有规则的选择， 可能达到全局最优。 一个思路： 对end进行排序， 这样我们就能根据end进行规则的选择了。</p>
<ol>
<li>很明显， 对于待选区间， 如果之前没有元素被选择过， 那么一定选择最后两个元素， 这样能够覆盖的后续区间最多， 不过这个时候需要判断一下， 选择两个元素之后， 后续区间是否都包含该两个元素。 包含一个+1， 包含两个+2， 不包含则跳出。</li>
<li>对于一个元素被选择了， 我们依旧选取当前区间的最后一个元素，不过此时只选择了一个， 所以只需要测试后续区间是否包含该元素即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class P implements Comparable&lt;P&gt;&#123;</span><br><span class="line">  int s;</span><br><span class="line">  int e;</span><br><span class="line">  int c;</span><br><span class="line">  P(int s, int e)&#123;</span><br><span class="line">    this.s= s;</span><br><span class="line">    this.e= e;</span><br><span class="line">    this.c=0;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int compareTo(P o)&#123;</span><br><span class="line">    return this.e- o.e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public int intersectionSizeTwo(int[][] intervals)&#123;</span><br><span class="line">  List&lt;P&gt; ps= new ArrayList&lt;&gt;();</span><br><span class="line">  int n= intervals.length;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    ps.add(new P(intervals[i][0], intervals[i][1]));</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(ps);</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    P inter= ps.get(i);</span><br><span class="line">    if(inter.c==0)&#123;</span><br><span class="line">      int pos= i+1;</span><br><span class="line">      // the first point we choose the end of curr</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;=inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++; </span><br><span class="line">        if(ps.get(pos).s&lt;=inter.e-1)&#123;</span><br><span class="line">          ps.get(pos).c++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res+=2;</span><br><span class="line">    &#125;else if(inter.c==1)&#123;</span><br><span class="line">      int pos=i+1;</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;= inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是之前intervals问题的推广版本， 我们每次选点都要求局部最优， 也就是选择最后两个点， 然后排除之后的点再次进行选择。 还是很具有价值的一道题目。</p>
<h3 id="Leetcode-173-Binary-Search-Tree-Iterator"><a href="#Leetcode-173-Binary-Search-Tree-Iterator" class="headerlink" title="Leetcode 173. Binary Search Tree Iterator"></a>Leetcode 173. Binary Search Tree Iterator</h3><p>Implement an iterator over a binary search tree(BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.</p>
<p>next() and hasNext() should run in average O(1) and uses O(h) memory, where h is the height of the tree.</p>
<h3 id="Leetcode-285-Inorder-Successor-in-BST"><a href="#Leetcode-285-Inorder-Successor-in-BST" class="headerlink" title="Leetcode 285. Inorder Successor in BST"></a>Leetcode 285. Inorder Successor in BST</h3><p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>If the given node has no in-order successor in the tree, return null.</p>
<p>MySolution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;</span><br><span class="line">        if(root==null) return null;</span><br><span class="line">        if(p.right!=null)&#123;</span><br><span class="line">            TreeNode node= p.right;</span><br><span class="line">            while(node.left!= null)&#123;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;       </span><br><span class="line">        TreeNode node= root;</span><br><span class="line">        TreeNode prev= null;</span><br><span class="line">        while(node!= null)&#123;</span><br><span class="line">            if(node.val&lt;=p.val)&#123;</span><br><span class="line">                node=node.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                prev= node;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Successor"><a href="#Successor" class="headerlink" title="Successor"></a>Successor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode successor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&lt;=p.val)&#123;</span><br><span class="line">    return successor(root.right, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode left= successor(root.left, p);</span><br><span class="line">    return( left!= null)? left: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Predecessor"><a href="#Predecessor" class="headerlink" title="Predecessor"></a>Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode predecessor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&gt;= p.val)&#123;</span><br><span class="line">    return predecessor(root.left, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode right= predecessor(root.right, p);</span><br><span class="line">    return (right!= null) ? right: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/算法(二)/" data-id="cjd8d3nyh0009cuzhggqn32gl" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试中的随机算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/面试中的随机算法/" class="article-date">
  <time datetime="2018-02-04T05:43:32.052Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Common-Random-Algorithm"><a href="#Common-Random-Algorithm" class="headerlink" title="Common Random Algorithm"></a>Common Random Algorithm</h1><p><strong> 2017-11-23 | </strong> <a href="http://lic128.me/categories/algorithm/" target="_blank" rel="noopener">algorithm</a></p>
<h2 id="随机算法总结"><a href="#随机算法总结" class="headerlink" title="随机算法总结"></a>随机算法总结</h2><blockquote>
<p>下文所有用到的随机函数都假定它能随机的产生范围[1, b]内的整数， 即产生每个整数的概率相等。</p>
</blockquote>
<h3 id="随机排列数组"><a href="#随机排列数组" class="headerlink" title="随机排列数组"></a>随机排列数组</h3><p>假设给定一个数组A， 它包含元素1到N， 我们的目标是构造这个数组的一个随机排列。</p>
<p>一个常用的方法是 原地排列给定数组， 可以在O(N)的时间内完成， 伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZE-IN-PLACE ( A , n ) for i ←1 to n do swap A[i] ↔ A[RANDOM(i , n )]</span><br></pre></td></tr></table></figure>
<p>对于该算法的正确性的证明， 戳这里： <a href="http://www.jianshu.com/p/f8e7070c1c6b" target="_blank" rel="noopener">here</a></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static shuffle(int[] nums)&#123;</span><br><span class="line">    Random random= new Random();</span><br><span class="line">  	for(int i= nums.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        int next=random.nextInt(i+1);</span><br><span class="line">      	swap(nums, next, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int temp= nums[i];</span><br><span class="line">  	nums[i]= nums[j];</span><br><span class="line">  	nums[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机选取一个数字"><a href="#随机选取一个数字" class="headerlink" title="随机选取一个数字"></a>随机选取一个数字</h3><p>给定一个未知长度的整数流， 如何随机选取一个数？（所谓随机就是保证每个数被选取的概率相等）</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>如果数据流不是很长， 可以存在数组中， 然后再从数组中随机选取。 当然题目说的是未知长度， 所以如果长度很大不足以保存在内存中的话会很麻烦。 这种解法有其局限性。</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>如果数据流在第一个数字后结束， 那么必选第一个数字。</p>
<p>如果数据流在第二个数字后结束， 那么我们选第二个数字的概率为1/2， 我们以1/2 的概率用第二个数字替换前面选的随机数， 得到新的随机数。</p>
<p>………………………….</p>
<p>如果数据流在第n个数字后结束， 那么我们选择第n个数字的概率为1/n， 即我们以1/n的概率用第n个数字替换前面选的随机数， 得到新的随机数。</p>
<p>一个简单的方法就是使用随机函数 bigrand()%n, 其中 bigrand() 返回很大的随机整数， 当数据流到第n个数时， 如果f(n)==0, 则替换前面的已经选的随机数， 这样可以保证每个数字被选中的概率都是1/n。</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int getRand(int[] nums)// here we don&apos;t know the size of the array</span><br><span class="line">&#123;	</span><br><span class="line">	int count=0;</span><br><span class="line">	int candidate=-1;</span><br><span class="line">	Random random= new Random();</span><br><span class="line">   	for(int num: nums)&#123;</span><br><span class="line">      	int next= random.next(count+1);</span><br><span class="line">      	if(next==0)&#123;</span><br><span class="line">          	candidate= num;</span><br><span class="line">      	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   	return candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机选取M个数字"><a href="#随机选取M个数字" class="headerlink" title="随机选取M个数字"></a>随机选取M个数字</h3><p>随机抽样问题表示如下：</p>
<p>要求从N个元素中随机的抽取k个元素， 其中N无法确定。</p>
<p>这种应用的场景一般是在数据流的情况下， 由于数据只能被读取一次， 而且数据量很大， 并不能全部保存， 因此数据量N是无法在抽样开始时确定的； 但又要保持随机性， 于是有了这个问题。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>解决方案就是蓄水库抽样(Reservoid sampling). 主要思想就是保持一个集合， 作为一个蓄水池， 依次遍历所有数据的时候以一定概率替换这个蓄水池中的数字。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Init: a reservior with the size: k</span><br><span class="line">	for i= k+1 to N</span><br><span class="line">		M= rand(1, i);</span><br><span class="line">		if(M&lt;K)</span><br><span class="line">			SWAP the Mth value and ith value</span><br><span class="line">	end for</span><br></pre></td></tr></table></figure>
<p>证明方法：</p>
<p><a href="http://blog.csdn.net/hackbuteer1/article/details/7971328" target="_blank" rel="noopener">归纳法</a></p>
<h3 id="已知-rand-n-，-求出rand-m"><a href="#已知-rand-n-，-求出rand-m" class="headerlink" title="已知 rand(n) ， 求出rand(m)"></a>已知 rand(n) ， 求出rand(m)</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>已知一个函数rand7() 能够生成1~7 的随机数，请给出一个函数， 该函数能够生成1-10的随机数。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>假如已知一个函数能够生成1-49 的随机数， 那么如何以此生成1-10 的随机数呢》</p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>该解法基于一种叫做拒绝采样的方法。主要思想是只要产生一个目标范围内的随机数， 则直接返回。 如果产生的随机数不在目标范围内， 则丢弃该值， 重新取样。 由于目标范围内的数字被选中的概率相等， 这样一个均匀的分布生成了。</p>
<p>显然rand7至少需要执行两次， 否则产生不了1~10的数字。 通过运行rand7两次， 可以生成1~49的整数。</p>
<p>由于49 不是10 的倍数， 所以我们需要丢弃一些值， 我们想要的数字范围为1~40， 不在此范围则丢弃并重新取样。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int rand10()&#123;</span><br><span class="line">  	int row, col, idx;</span><br><span class="line">  	do&#123;</span><br><span class="line">      	row= rand7();</span><br><span class="line">      	col= rand7();</span><br><span class="line">      	idx= col+(row-1)*7;</span><br><span class="line">  	&#125;while(idx&gt;40);</span><br><span class="line">  	return 1+ (idx-1)%10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>上面的方法大概需要2.45次调用才能得到1个1~10 范围内的数， 下面可以进行再度优化。</p>
<p>对于大于40的数， 我们不必马上丢弃， 可以对41~49的数减去40可得到1-9 的随机数， 而rand7可生成1-7的随机数， 这样可以生成1-63的随机数。 对于1-60我们可以直接返回， 而61-63则丢弃， 这样需要丢弃的数只有3个， 相比前面的9个， 效率有所提高。 而对于61-63的数， 减去60之后为1-3， rand7产生1-7， 这样可以再度利用产生1-21的数， 对于1-20 我们则直接返回， 对于21 则丢弃。 这时， 丢弃的数就只有1个了， 优化再进一步。 当然这里对于rand7的调用次数也是增加了。</p>
<p>优化了之后我们大概需要调用2.21次。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/sgbfblog/article/details/7753012" target="_blank" rel="noopener">已知一个函数rand7()</a></p>
<h2 id="加权随机算法"><a href="#加权随机算法" class="headerlink" title="加权随机算法"></a>加权随机算法</h2><p>加权随机算法一般应用在一下场景： 有一个集合S, 里面比如有A，B， C， D这四项。 这时我们想随机从中抽取一项， 但是抽取的概率不同， 比如我们希望抽到A的概率是50%， 抽到B和C的概率是20%， D的概率是10%。 一般来说， 我们可以给各项附一个权重， 抽取的概率正比于这个权重。 那么上述集合就成了：<code>{A:5, B:2, C:2, D:1}</code></p>
<h3 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a>Solution 1：</h3><p>扩展这个集合， 使每一项出现的次数与其权重正相关。 在上述例子这个集合扩展成：</p>
<p><code>{A, A, A, A, A, B, B, C, C, D}</code></p>
<p>然后就可以用均匀随机算法来从中选取。</p>
<ul>
<li>pros: 选取的时间复杂度为O(1)， 算法简单。</li>
<li>cons： 空间占用极大。 另外如果权重数字位数较大， 例如<code>{A: 49.1，B: 50.9}</code>的时候， 就会产生巨大的空间浪费。</li>
</ul>
<h3 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a>Solution 2：</h3><p>计算权重总和sum， 然后在1到sum之间随机选择一个数R， 之后遍历整个集合， 统计遍历的项的权重之和， 如果大于等于R， 就停止遍历， 选择遇到的项。</p>
<p>还是以上面的集合为例， sum等于10， 如果随机到1-5，则会在遍历第一个数字的时候就退出遍历。 符合所选取的概率。</p>
<ul>
<li>Pros： 没有额外的空间占用， 算法也比较简单。</li>
<li>cons： 选取的时候要遍历集合， 时间复杂度是O(n)。</li>
</ul>
<h3 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a>Solution 3：</h3><p>可以对方法二进行优化， 对项目集按照权重排序， 这样遍历的时候， 概率高的项可以很快遇到， 减少遍历的项。</p>
<p>进一步优化， 可以使用数组+ 二分查找来实现。</p>
<ul>
<li>Pros: 提高了平均选取速度。</li>
<li>cons：需要进行排序， 并且不易添加删除修改项。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/面试中的随机算法/" data-id="cjd8d3nyb0007cuzhiy2uhmrm" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/03/Behavior Question/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Intro to Python/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Java Generics简介/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Java中HashMap的实现机制/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Java线程简介/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>