<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Resume Review" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Resume Review/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Resume Review/">关于简历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Resume-review"><a href="#Resume-review" class="headerlink" title="Resume review"></a>Resume review</h1><h1 id="Shopping-Website-Design-and-Development"><a href="#Shopping-Website-Design-and-Development" class="headerlink" title="Shopping Website Design and Development"></a>Shopping Website Design and Development</h1><p>Well, I built this project in the summer.</p>
<p>This is a project which is a web application based on mongodb, express, and node.js. As you know, as an international student, sometimes we have to move often, and every time we move, we might need to sell something.So I built this website to works as a platform for student to sell used items to other. You can register, login and post, delete and comment on the website. The frontend of the website is based on bootstrap and the backend is based on mongodb and node.js. And now the project is deployed on Heroku, and I’m still working on it to add more new features. If you are interested, I can send you a link to the website.</p>
<h2 id="What-did-you-learned-from-the-process"><a href="#What-did-you-learned-from-the-process" class="headerlink" title="What did you learned from the process."></a>What did you learned from the process.</h2><p>well, before building this project, I have no experience in mean stack. And through building this project, I have a through understanding of how node.js works, and build some frontend page, which is quiet interesting.</p>
<h2 id="Difficulty"><a href="#Difficulty" class="headerlink" title="Difficulty"></a>Difficulty</h2><p>Well, as I have said, I have no experience in building website before, and in the meantime, node.js is quiet new for me, so problem occurs a lot in the process. Like how different middleware works, and how to add register and login function. So to solve those problems, I spent a lot of time searching on the website and ask friend who have experience in mean stack for help. And in the last, the problem was solved.</p>
<h1 id="Customer-Relationship-Management-System-Design-and-Development"><a href="#Customer-Relationship-Management-System-Design-and-Development" class="headerlink" title="Customer Relationship Management System Design and Development."></a>Customer Relationship Management System Design and Development.</h1><p>Actually, this is a basic management system to record the membership of one application, like class or something. It’s just like a to-do app which involves basic frontend and database, you can like add different member and record the information of the member.</p>
<p>This is a quiet simple application, I build this project just to have some experience in Java web, and it indeed help me to understand how the basic logic works behind the web.</p>
<p>The frontend was based on servlet, jsp, and the backend was based on mySQL;</p>
<h1 id="Development-of-Recommender-System-based-on-reviews-from-Amazon"><a href="#Development-of-Recommender-System-based-on-reviews-from-Amazon" class="headerlink" title="Development of Recommender System based on reviews from Amazon."></a>Development of Recommender System based on reviews from Amazon.</h1><p><a href="http://www.cnblogs.com/loujiayu/p/3859076.html" target="_blank" rel="noopener">参考资料</a></p>
<p>This is a course project, and our professor gives us dataset which contains 200000(two hundred thousand) reviews from amazon, and every review contains like the rating, the name and all kinds of information. And our job is to predict the helpfulness of one review and using latent factor algorithm to recommend items to the user. And the professor creates a competition on the Kaggle for us to upload different.</p>
<p>So in the first part, we just use different regression models to predict the helpfulness, like linear, Ridge, lasso and SVM, we even try to dive into the text of the review to gain more information, but due to the time reason, I didn’t get a good result, and now I think maybe I should try gradient boosting or random forest to get a better result.</p>
<p>And in the second part, we are given the user id and item id, and our job is to predict the rating of one item and based on the rating to recommend similar items to the user.</p>
<p>The latent factor algorithm is just like singular value decomposition. We are given the user-item-rating matrix, say a m*n matrix, and we are going to break the matrix to the form of two matrix multiplication like (m, k) and (k, n), and the k is the latent class, and the left matrix can explained as the user’s preference toward item, and the right matrix can explained as the characteristic matrix of item in the latent area. And our job is to find such composition.</p>
<p>user’s interest</p>
<p>item’s characteristic</p>
<p>下面我们简要介绍以下Latent Factor模型：</p>
<p>给定一个给定的用户行为数据集， 数据集包含的是所有的user， 所有的item， 以及每个user有过行为的item列表， 使用LFM对其建模后， 我们可以得到如下图所示的模型：</p>
<p><a href="http://img.blog.csdn.net/20130812142043312" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20130812142043312" alt="img"></a></p>
<p>R矩阵是user-item矩阵， 矩阵值表示的user i 对于 item j的兴趣度， 这正是我们要求的值。 对于一个user来说， 当计算出他对所有item的兴趣度后， 就可以进行排序并作出推荐。 LFM算法从数据集中抽出若干主题， 作为user和item之间连接的桥梁， 将R矩阵表示为P矩阵与Q矩阵的相乘。 其中P矩阵是user-class矩阵， 矩阵值Pij代替的是user i对 class j的兴趣度； Q矩阵是class-item矩阵， 矩阵值表示的是item j在class i中的权重， 权重越高越能作为此类的代表。 所以LFM根据如下公式来计算用户U对物品I的兴趣度：</p>
<p><a href="http://img.blog.csdn.net/20130812142048593" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20130812142048593" alt="img"></a></p>
<p>我们发现使用LFM后：</p>
<ol>
<li>我们不需要关心分类的角度， 结果都是基于用户行为统计自动聚类的， 全拼数据自己说了算。</li>
<li>不需要关心分类细度的问题， 通过设置LFM的最终分类数就可以控制粒度， 分类数越大， 粒度越细。</li>
<li>对于一个item， 并不是明确的划分到某一类， 而是计算其属于某一类的概率， 是一种标准的软分类。</li>
<li>对于一个user， 我们可以得到他对于每一类的兴趣度， 而不是只关心可见列表中的那几个类。</li>
<li>对于每一个class， 我们可以得到类中每个item的权重， 越能代表这个类的item， 权重越高。</li>
</ol>
<p>那么， 接下来的问题就是如何计算矩阵P和矩阵Q中参数值。 一般做法就是最优化损失函数来求参数， 在定义损失函数之前， 我们需要准备以下数据集并对兴趣度的取值做一说明。</p>
<h2 id="Difficulties"><a href="#Difficulties" class="headerlink" title="Difficulties"></a>Difficulties</h2><p>The optimization of the parameter, and the implementation of the whole project. And it takes like half an hour to run this algorithm locally.</p>
<h1 id="Boosting-Algorithm"><a href="#Boosting-Algorithm" class="headerlink" title="Boosting Algorithm"></a>Boosting Algorithm</h1><p>two main ideas:</p>
<ol>
<li>A combination of basic model can form a good-performance model.</li>
<li>Learn from error, using the recursion to reduce the rate of error.</li>
</ol>
<p>强学习算法： 存在一个多项式时间的学习算法以识别一组概念， 且识别的正确率很高；</p>
<p>弱学习算法： 识别一组概念的正确率仅比随机猜测策略好；</p>
<p>Boosting算法， 通过一系列的迭代来优化分类结果， 没迭代一次引入一个弱分类器， 来克服现在已经存在的弱分类器组合的shortcomings</p>
<p>在 Adaboosting算法中， 这个shortcomings的表征就是权值高的样本点， 而在gradient boosting算法中， 这个shortcomings的表征就是梯度。</p>
<h2 id="Adaboosting"><a href="#Adaboosting" class="headerlink" title="Adaboosting"></a>Adaboosting</h2><p>在整个训练集上维护一个分布权值向量W， 用赋予权重的训练集通过若分类算法产生假设（基学习器） y（x）， 然后计算错误率， 用得到的错误率去更新分布权值向量W， 对错误分类的样本分配更大的权值， 正确分类的样本赋予更小的权值。 每次更新后用相同的弱分类算法产生新的分类假设， 这些分类假设的序列构成多分类器， 对这些多分类器用加权的方法进行联合， 最后得到决策结果。</p>
<p><a href="https://images2015.cnblogs.com/blog/708708/201601/708708-20160129193753052-665222274.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/708708/201601/708708-20160129193753052-665222274.png" alt="img"></a></p>
<p>前一个学习器改变权重W， 然后再经过下一个学习器， 最终所有的学习器共同组成最后的学习器。</p>
<p>如果一个样本在前一个学习器中被误分， 那么它对应的权重会被加重， 相应地， 被正确分类的样本的权重会降低。</p>
<p>这里主要设计到两个权重的计算问题：</p>
<ol>
<li>样本的权值<ul>
<li>没有先验知识的情况下， 初始的分布应该为等概率分布， 样本数目为n， 权值为1/n;</li>
<li>每一次的迭代更新权值， 提高分错样本的权重。</li>
</ul>
</li>
<li>弱学习器的权重<ul>
<li>最后的强学习器是通过多个基学习器通过权值组合得到的。</li>
<li>通过权值体现不同基学习器的影响， 正确率高的基学习器权重高。 实际上是分类误差的一个函数。</li>
</ul>
</li>
</ol>
<h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>和Ada boosting不同， GradientBoosting在迭代的时候选择梯度下降的方向来保证最后的结果最好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Resume Review/" data-id="cjd8dst4s0009auzhxairf1gt" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/算法(一)/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/算法(一)/">算法(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="LeetCode-146-LRU-Cache"><a href="#LeetCode-146-LRU-Cache" class="headerlink" title="LeetCode 146. LRU Cache"></a>LeetCode 146. LRU Cache</h3><p>Design and implement a data structure for Lease Recently Used cache. It should support the following operations:<code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        int key;</span><br><span class="line">        int val;</span><br><span class="line">        public Node(int key, int val)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">            this.val= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head=null;</span><br><span class="line">    Node tail=null;</span><br><span class="line">    public void removeTail()&#123;</span><br><span class="line">        Node node= tail.pre.pre;</span><br><span class="line">        node.next=tail;</span><br><span class="line">        tail.pre= node;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addToHead(Node node)&#123;</span><br><span class="line">        Node next= head.next;</span><br><span class="line">        next.pre= node;</span><br><span class="line">        node.next= next;</span><br><span class="line">        node.pre= head;</span><br><span class="line">        head.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    public void moveToHead(Node node)&#123;</span><br><span class="line">        Node next= node.next;</span><br><span class="line">        Node pre= node.pre;</span><br><span class="line">        pre.next= next;</span><br><span class="line">        next.pre=pre;</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    private Map&lt;Integer, Node&gt; map= new HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    private int capacity;</span><br><span class="line">    private int count;</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.capacity= capacity;</span><br><span class="line">        head=new Node(0, 0);</span><br><span class="line">        tail=new Node(0, 0);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre= head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if(!map.containsKey(key))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node node= map.get(key);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            return node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if(map.containsKey(key))&#123;</span><br><span class="line">            Node node= map.get(key);</span><br><span class="line">            node.val= value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node node= new Node(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            count++;</span><br><span class="line">            if(count&gt;capacity)&#123;</span><br><span class="line">                map.remove(tail.pre.key);</span><br><span class="line">                removeTail();</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-199-Evaluate-Division"><a href="#leetcode-199-Evaluate-Division" class="headerlink" title="leetcode 199. Evaluate Division"></a>leetcode 199. Evaluate Division</h3><p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p><strong>Example:</strong><br>Given <code>a / b = 2.0, b / c = 3.0.</code><br>queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code><br>return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector&lt;double&gt;</code>.</p>
<p>According to the example above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values = [2.0, 3.0],</span><br><span class="line">queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<h4 id="Solution-1-dumb-dfs"><a href="#Solution-1-dumb-dfs" class="headerlink" title="Solution 1: dumb dfs"></a>Solution 1: dumb dfs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; map= new HashMap&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, Double&gt; dict= new HashMap&lt;String, Double&gt;();</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p= equations[i][0];</span><br><span class="line">            String q= equations[i][1];</span><br><span class="line">            double val= values[i];</span><br><span class="line">            if(!map.containsKey(p)) map.put(p, new HashSet&lt;String&gt;());</span><br><span class="line">            if(!map.containsKey(q)) map.put(q, new HashSet&lt;String&gt;());</span><br><span class="line">            map.get(p).add(q);</span><br><span class="line">            map.get(q).add(p);</span><br><span class="line">            dict.put(p+&quot;/&quot;+q, val);</span><br><span class="line">            dict.put(q+&quot;/&quot;+p, 1/val);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        Set&lt;String&gt; visited;</span><br><span class="line">        for(int i=0; i&lt;queries.length; i++)&#123;</span><br><span class="line">            String p= queries[i][0];</span><br><span class="line">            String q= queries[i][1];</span><br><span class="line">            if(!map.containsKey(p) || !map.containsKey(q))&#123;</span><br><span class="line">                res[i]=-1.0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            visited= new HashSet&lt;String&gt;();</span><br><span class="line">            visited.add(p);</span><br><span class="line">            res[i]= isConnected(p, q, map, dict, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public double isConnected(String p, String q, Map&lt;String, Set&lt;String&gt;&gt; map, Map&lt;String, Double&gt; dict, Set&lt;String&gt; visited)&#123;</span><br><span class="line">        String equ= p+ &quot;/&quot;+q;</span><br><span class="line">        String rev_equ=q+&quot;/&quot;+p;</span><br><span class="line">        if(dict.containsKey(equ)) return dict.get(equ);</span><br><span class="line">        for(String next: map.get(p))&#123;</span><br><span class="line">            if(visited.contains(next)) continue;</span><br><span class="line">            visited.add(next);</span><br><span class="line">            double res= dict.get(p+&quot;/&quot;+ next);</span><br><span class="line">            double residual= isConnected(next, q, map, dict, visited);</span><br><span class="line">            if(residual==-1.0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dict.put(equ, res*residual);</span><br><span class="line">            dict.put(rev_equ, 1/(res*residual));</span><br><span class="line">            return res*residual;</span><br><span class="line">        &#125;</span><br><span class="line">        dict.put(equ, -1.0);</span><br><span class="line">        dict.put(rev_equ, -1.0);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-2-union-find-algorithm"><a href="#Solution-2-union-find-algorithm" class="headerlink" title="Solution 2: union-find algorithm"></a>Solution 2: union-find algorithm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">    Map&lt;String, String&gt; parent= new HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Double&gt; weight= new HashMap&lt;&gt;();// parent/son</span><br><span class="line">    // here we use weight to record the quotient between the root  and the child;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries)&#123;</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String[] eq= equations[i];</span><br><span class="line">            initialize(eq[0]);</span><br><span class="line">            initialize(eq[1]);</span><br><span class="line">            union(eq[0], eq[1], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        for(int i=0; i&lt;queries.length; i++)&#123;</span><br><span class="line">            res[i]= getProduct(queries[i][0], queries[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private void initialize(String a)&#123;</span><br><span class="line">        if(!parent.containsKey(a))&#123;</span><br><span class="line">            parent.put(a, a);</span><br><span class="line">            weight.put(a, 1d);// sufix d after number means double, sufix f means float;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void union(String a, String b, double quotient)&#123;</span><br><span class="line">        String aRoot= find(a);</span><br><span class="line">        String bRoot= find(b);</span><br><span class="line">        if(!aRoot.equals(bRoot))&#123;</span><br><span class="line">            parent.put(bRoot, aRoot);</span><br><span class="line">            weight.put(bRoot, quotient*weight.get(a)/weight.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private String find(String a)&#123;</span><br><span class="line">        if(parent.get(a).equals(a))&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        String oldRoot= parent.get(a);</span><br><span class="line">        String root= find(oldRoot);</span><br><span class="line">        if(!oldRoot.equals(root))&#123;</span><br><span class="line">            parent.put(a, root);</span><br><span class="line">            weight.put(a, weight.get(oldRoot)*weight.get(a));// here is important, we use the recursive thought to override the previous value of the record;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    private double getProduct(String a, String b)&#123;</span><br><span class="line">        if(!parent.containsKey(a) || !parent.containsKey(b))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        String aRoot= find(a);</span><br><span class="line">        String bRoot= find(b);</span><br><span class="line">        if(!aRoot.equals(bRoot))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return weight.get(b)/weight.get(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种方式的Union-find:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // Using union-find to solve the problem;</span><br><span class="line">    // or we can use bfs/dfs, which will take a lot time;</span><br><span class="line">    Map&lt;String, String&gt; id= new HashMap&lt;String, String&gt;();</span><br><span class="line">    Map&lt;String, Double&gt; dict=new HashMap&lt;String, Double&gt;();</span><br><span class="line">    public String find(String p)&#123;</span><br><span class="line">        while(!p.equals(id.get(p)))&#123;</span><br><span class="line">            p=id.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getValue(String p)&#123;</span><br><span class="line">        double res= 1.0;</span><br><span class="line">        while(!p.equals(id.get(p)))&#123;</span><br><span class="line">            double mult=dict.get(p+&quot;/&quot;+id.get(p));</span><br><span class="line">            res*=mult;</span><br><span class="line">            p=id.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public double cal(String p, String q)&#123;</span><br><span class="line">        if(!id.containsKey(p) || !id.containsKey(q)) return -1;</span><br><span class="line">        String p_root= find(p);</span><br><span class="line">        String q_root= find(q);</span><br><span class="line">        if(!p_root.equals(q_root)) return -1;</span><br><span class="line">        double p_res= getValue(p);</span><br><span class="line">        double q_res= getValue(q);</span><br><span class="line">        return p_res/q_res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(String p, String q, double value)&#123;</span><br><span class="line">        String p_root= find(p);</span><br><span class="line">        String q_root= find(q);</span><br><span class="line">        double p_val= getValue(p);</span><br><span class="line">        double q_val= getValue(q);</span><br><span class="line">        id.put(p_root, q_root);</span><br><span class="line">        dict.put(p_root+&quot;/&quot;+ q_root, value*q_val/p_val);</span><br><span class="line">        // when we union here, we also need to update the edges;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries)&#123;</span><br><span class="line">        for(int i= 0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p= equations[i][0];</span><br><span class="line">            String q=equations[i][1];</span><br><span class="line">            double val= values[i];</span><br><span class="line">            id.put(p, p);</span><br><span class="line">            id.put(q, q);</span><br><span class="line">            dict.put(p+&quot;/&quot;+ q, val);</span><br><span class="line">            dict.put(q+&quot;/&quot;+ p, 1/val);</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(&quot;done!&quot;);</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p=equations[i][0];</span><br><span class="line">            String q=equations[i][1];</span><br><span class="line">            union(p, q, values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(&quot;done!&quot;);</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        for(int i=0; i&lt;res.length; i++)&#123;</span><br><span class="line">            //System.out.println(queries[i][0]);</span><br><span class="line">            //System.out.println(queries[i][1]);</span><br><span class="line">            res[i]=cal(queries[i][0], queries[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-628-Maximum-Product-of-Three-Numbers"><a href="#Leetcode-628-Maximum-Product-of-Three-Numbers" class="headerlink" title="Leetcode 628. Maximum Product of Three Numbers"></a>Leetcode 628. Maximum Product of Three Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximumProduct(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res=0;</span><br><span class="line">        int first= nums[0]*nums[1]*nums[nums.length-1];</span><br><span class="line">        int last= nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3];</span><br><span class="line">        return Math.max(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or we can just find the corresponding 5 value using one-pass scan:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int maximumProduct(int[] nums) &#123;</span><br><span class="line">       int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">       for (int n : nums) &#123;</span><br><span class="line">           if (n &gt; max1) &#123;</span><br><span class="line">               max3 = max2;</span><br><span class="line">               max2 = max1;</span><br><span class="line">               max1 = n;</span><br><span class="line">           &#125; else if (n &gt; max2) &#123;</span><br><span class="line">               max3 = max2;</span><br><span class="line">               max2 = n;</span><br><span class="line">           &#125; else if (n &gt; max3) &#123;</span><br><span class="line">               max3 = n;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (n &lt; min1) &#123;</span><br><span class="line">               min2 = min1;</span><br><span class="line">               min1 = n;</span><br><span class="line">           &#125; else if (n &lt; min2) &#123;</span><br><span class="line">               min2 = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return Math.max(max1*max2*max3, max1*min1*min2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="leetcode 159. Longest Substring with At Most Two Distinct Characters"></a>leetcode 159. Longest Substring with At Most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>
<p>For example, Given s = <code>“eceba”</code>,</p>
<p>T is “ece” which its length is 3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map= new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        int left=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int right=0; right&lt;s.length(); right++)&#123;</span><br><span class="line">            char ch= s.charAt(right);</span><br><span class="line">            map.put(ch, map.getOrDefault(ch, 0)+1);</span><br><span class="line">            while(map.size()&gt;2)&#123;</span><br><span class="line">                char delete=s.charAt(left);</span><br><span class="line">                map.put(delete, map.get(delete)-1);</span><br><span class="line">                if(map.get(delete)==0) map.remove(delete);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res, right-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This Solution can be extended to the general k-different solutions;</p>
<h3 id="leetcode-465-Optimal-Account-Balancing"><a href="#leetcode-465-Optimal-Account-Balancing" class="headerlink" title="leetcode 465. Optimal Account Balancing"></a>leetcode 465. Optimal Account Balancing</h3><p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill’s lunch for 10. Then later Chris gave Alice 5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person’s ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>
<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>
<p><strong>Note:</strong></p>
<ol>
<li>A transaction will be given as a tuple (x, y, z). Note that <code>x ≠ y</code> and <code>z &gt; 0</code>.</li>
<li>Person’s IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,10], [2,0,5]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Person #0 gave person #1 $10.</span><br><span class="line">Person #2 gave person #0 $5.</span><br><span class="line"></span><br><span class="line">Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Person #0 gave person #1 $10.</span><br><span class="line">Person #1 gave person #0 $1.</span><br><span class="line">Person #1 gave person #2 $5.</span><br><span class="line">Person #2 gave person #0 $5.</span><br><span class="line"></span><br><span class="line">Therefore, person #1 only need to give person #0 $4, and all debt is settled.</span><br></pre></td></tr></table></figure>
<p>题目属于NPC问题， 在这种情况下， 进行暴力解就好， 解法： 借西墙补东墙，将位于第一位的数字放入可以放入的其他位中， 然后将第一位清零， 进行下一次更替。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minTransfers(int[][] transactions) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(int i=0; i&lt;transactions.length; i++)&#123;</span><br><span class="line">            int give=transactions[i][0];</span><br><span class="line">            int take=transactions[i][1];</span><br><span class="line">            int val= transactions[i][2];</span><br><span class="line">            map.put(give, map.getOrDefault(give, 0)-val);</span><br><span class="line">            map.put(take, map.getOrDefault(take, 0)+val);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; debts= new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int debt: map.values())&#123;</span><br><span class="line">            if(debt!=0)&#123;</span><br><span class="line">                debts.add(debt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(debts);</span><br><span class="line">        return helper(0, 0, debts);</span><br><span class="line">    &#125;</span><br><span class="line">    private int helper(int pos, int count, List&lt;Integer&gt; debts)&#123;</span><br><span class="line">        while(pos&lt;debts.size() &amp;&amp; debts.get(pos)==0) pos++;</span><br><span class="line">        if(pos==debts.size()) return count;</span><br><span class="line">        int val= debts.get(pos);</span><br><span class="line">        int res=Integer.MAX_VALUE;</span><br><span class="line">        for(int i= pos+1; i&lt;debts.size(); i++)&#123;</span><br><span class="line">            if(debts.get(i)*val&lt;0)&#123;</span><br><span class="line">                while(i+1&lt;debts.size() &amp;&amp; debts.get(i)==debts.get(i+1)) i++;</span><br><span class="line">                debts.set(i, debts.get(i)+ val);</span><br><span class="line">                res=Math.min(res, helper(pos+1, count+1, debts));</span><br><span class="line">                debts.set(i, debts.get(i)-val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-464-Can-I-Win"><a href="#Leetcode-464-Can-I-Win" class="headerlink" title="Leetcode 464. Can I Win"></a>Leetcode 464. Can I Win</h3><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p><strong>Example</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">No matter which integer the first player choose, the first player will lose.</span><br><span class="line">The first player can choose an integer from 1 up to 10.</span><br><span class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</span><br><span class="line">The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</span><br><span class="line">Same with other integers chosen by the first player, the second player will always win.</span><br></pre></td></tr></table></figure>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h4><p>很经典的Backtracking+ Game Theory+ Hash的题目， 我们要做的就是考虑下一步的反面就好了， 如果下一步的对手不能赢， 说明我们这一步就可以赢。</p>
<p>需要注意的是优化， 这里采用的是hash+memorization， 但是效果可能不是特别好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; map= new HashMap&lt;String, Boolean&gt;();</span><br><span class="line">    public boolean canIWin(int maxChoosableInteger, int desiredTotal) &#123;</span><br><span class="line">        int sum=(maxChoosableInteger+1)*maxChoosableInteger/2;</span><br><span class="line">        if(sum&lt;desiredTotal) return false;</span><br><span class="line">        if(desiredTotal&lt;=0) return true;</span><br><span class="line">        boolean[] visited= new boolean[maxChoosableInteger+1];</span><br><span class="line">        return canIWin(visited, desiredTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean canIWin(boolean[] visited, int desiredTotal)&#123;</span><br><span class="line">        if(desiredTotal&lt;=0) return false;</span><br><span class="line">        String key= encode(visited);</span><br><span class="line">        if(map.containsKey(key)) return map.get(key);</span><br><span class="line">        for(int i=1; i&lt;visited.length; i++)&#123;</span><br><span class="line">            if(visited[i]) continue;</span><br><span class="line">            visited[i]= true;</span><br><span class="line">            if(!canIWin(visited, desiredTotal-i))&#123;// if the remaining one cannot win, then we say we can win.</span><br><span class="line">                map.put(key, true);</span><br><span class="line">                visited[i]=false;//here we need to refresh the visited;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public String encode(boolean[] visited)&#123;</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        for(int i=0; i&lt;visited.length; i++)&#123;</span><br><span class="line">            if(visited[i])&#123;</span><br><span class="line">                sb.append(1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sb.append(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#leetcode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="leetcode 297. Serialize and Deserialize Binary Tree"></a>leetcode 297. Serialize and Deserialize Binary Tree</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>
<p>as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<p>, just the same as</p>
<p>how LeetCode OJ serializes a binary tree</p>
<p>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目也很经典啊， 利用preorder对tree进行遍历， 然后利用相同的过程进行重建。 具体看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line"></span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    public String serialize(TreeNode root) &#123;</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    // preorder traverse the tree</span><br><span class="line">    public void serialize(TreeNode root, StringBuilder sb)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            sb.append(&quot;,null&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;,&quot;).append(root.val);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        String[] tokens= data.split(&quot;,&quot;);</span><br><span class="line">        Queue&lt;String&gt; queue= new LinkedList&lt;String&gt;();</span><br><span class="line">        for(int i=0; i&lt;tokens.length; i++)&#123;</span><br><span class="line">            if(tokens[i].length()==0 || tokens[i].equals(&quot;,&quot;))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(tokens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return buildTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode buildTree(Queue&lt;String&gt; queue)&#123;</span><br><span class="line">        if(queue.size()==0) return null;</span><br><span class="line">        String val= queue.poll();</span><br><span class="line">        if(val.equals(&quot;null&quot;)) return null;</span><br><span class="line">        TreeNode root= new TreeNode(Integer.valueOf(val));</span><br><span class="line">        root.left = buildTree(queue);</span><br><span class="line">        root.right= buildTree(queue);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-339-Nested-List-Weight-Sum"><a href="#leetcode-339-Nested-List-Weight-Sum" class="headerlink" title="leetcode 339. Nested List Weight Sum"></a>leetcode 339. Nested List Weight Sum</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>10</strong>. (four 1’s at depth 2, one 2 at depth 1)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>27</strong>. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>典型的DFS题目， 记录每一层的深度， 然后乘其数值即可得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *     // Constructor initializes an empty nested list.</span><br><span class="line"> *     public NestedInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Constructor initializes a single integer.</span><br><span class="line"> *     public NestedInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a single integer.</span><br><span class="line"> *     public void setInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span><br><span class="line"> *     public void add(NestedInteger ni);</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(NestedInteger i: nestedList)&#123;</span><br><span class="line">            sum+=dfs(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfs(NestedInteger num, int depth)&#123;</span><br><span class="line">        if(num.isInteger())&#123;</span><br><span class="line">            return num.getInteger()*depth;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int sum=0;</span><br><span class="line">            List&lt;NestedInteger&gt; list= num.getList();</span><br><span class="line">            for(NestedInteger i: list)&#123;</span><br><span class="line">                sum+=dfs(i, depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-364-Nested-List-Weight-Sum-II"><a href="#Leetcode-364-Nested-List-Weight-Sum-II" class="headerlink" title="Leetcode 364. Nested List Weight Sum II"></a>Leetcode 364. Nested List Weight Sum II</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the <a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">previous question</a> where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>8</strong>. (four 1’s at depth 1, one 2 at depth 2)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>17</strong>. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *     // Constructor initializes an empty nested list.</span><br><span class="line"> *     public NestedInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Constructor initializes a single integer.</span><br><span class="line"> *     public NestedInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a single integer.</span><br><span class="line"> *     public void setInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span><br><span class="line"> *     public void add(NestedInteger ni);</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; level= new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(NestedInteger i: nestedList)&#123;</span><br><span class="line">            getRank(level, i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int maxLevel=0;</span><br><span class="line">        for(int i: level.keySet())&#123;</span><br><span class="line">            maxLevel= Math.max(maxLevel, i);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i: level.keySet())&#123;</span><br><span class="line">            sum+=(maxLevel-i+1)*level.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getRank(Map&lt;Integer, Integer&gt; level, NestedInteger num, int depth)&#123;</span><br><span class="line">        if(num.isInteger())&#123;</span><br><span class="line">            level.put(depth, level.getOrDefault(depth, 0)+ num.getInteger());</span><br><span class="line">            return;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list= num.getList();</span><br><span class="line">            for(NestedInteger i: list)&#123;</span><br><span class="line">                getRank(level, i, depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-405-Convert-a-Number-to-Hexadecimal"><a href="#leetcode-405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="leetcode 405. Convert a Number to Hexadecimal"></a>leetcode 405. Convert a Number to Hexadecimal</h3><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">two’s complement</a> method is used.</p>
<p><strong>Note:</strong></p>
<ol>
<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>
<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>&#39;0&#39;</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>进制转换， 也算比较不错的一道题目了， 需要注意的是16进制向 2进制的转换， 以及map的这个操作。</p>
<p>Basic idea: each time we take a look at the last four digits of binary version of input, and maps that to a hex char, shift the input to the right by 4 bits, do it again until input becomes 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    //</span><br><span class="line">    public String toHex(int num) &#123;</span><br><span class="line">        char[] map = new char[]&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line">        if(num==0) return &quot;0&quot;;</span><br><span class="line">        String result= &quot;&quot;;</span><br><span class="line">        while(num!=0)&#123;</span><br><span class="line">            result= map[(num&amp;15)] + result;</span><br><span class="line">            num= (num&gt;&gt;&gt;4);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-Find-Leaves-of-Binary-Tree"><a href="#leetcode-Find-Leaves-of-Binary-Tree" class="headerlink" title="leetcode: Find Leaves of Binary Tree"></a>leetcode: Find Leaves of Binary Tree</h3><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<p>Example:<br>Given binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>Returns [4, 5, 3], [2], [1].</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>这道题给了我们一个二叉树， 让我们返回其每层的叶节点， 就像剥洋葱一样， 将这个二叉树一层层剥掉， 最后一个剥掉根节点。 思路是这样的， 每一个节点从左子节点和右子节点分开走可以得到两个深度， 由于成为叶节点的条件是左右子结点都为空， 所以我们取左右子节点中较大值加1 为当前节点的深度值， 知道了深度值就可以将节点值加入到结果res中的正确位置了。</p>
<p>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">	public static List&lt;List&lt;Integer&gt;&gt; findLeaves&#123;</span><br><span class="line">     	List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      	getDepth(root, res);</span><br><span class="line">      	return res;</span><br><span class="line">    &#125;</span><br><span class="line">  public static int getDepth(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root)&#123;</span><br><span class="line">      	if(root==null) return 0;</span><br><span class="line">    	int left= getDepth(res, root.left);</span><br><span class="line">    	int right= getDepth(res, root.right);</span><br><span class="line">    	int depth= Math.max(left, right)+1;</span><br><span class="line">    	while(res.size()&lt;depth)&#123;</span><br><span class="line">        	res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    	&#125;</span><br><span class="line">    	res.get(depth-1).add(root.val);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解法， 使用naive的一层层剥离的方法， 思路是遍历二叉树， 找到叶节点， 将其值赋值为null， 然后加入leaves中， 这样一层层剥离就可以得到最终结果了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">	public static List&lt;List&lt;Integer&gt;&gt; findLeaves&#123;</span><br><span class="line">     	List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      	while(root!=null)&#123;</span><br><span class="line">          	List&lt;Integer&gt; leaves= new ArrayList&lt;Integer&gt;()</span><br><span class="line">            removeLeave(root, leaves);</span><br><span class="line">          res.add(leaves);</span><br><span class="line">        &#125;</span><br><span class="line">      	return res;</span><br><span class="line">    &#125;</span><br><span class="line">  public static TreeNode removeLeave(TreeNode root, List&lt;Integer&gt; leaves)&#123;</span><br><span class="line">      	if(root==null) return null;</span><br><span class="line">    	if(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            leaves.add(root.val);</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">    	root.left= removeLeave(root.left, leaves);</span><br><span class="line">    	root.right= removeLeave(root.right, leaves);</span><br><span class="line">    	return root;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15: 3Sum"></a>Leetcode 15: 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>总的来说， 两个知识点的考察： 1. two pointers; 2. 如何去重。</p>
<p>这里我们主要的难点就是对于去重： 如何高效地去重。</p>
<p>这里我们直接看代码进行理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0; i&lt;nums.length-2; i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            //if(res.size()&gt;0 &amp;&amp; res.get(res.size()-1).get(0)==nums[i]) continue;</span><br><span class="line">            int target= -nums[i];</span><br><span class="line">            int left= i+1;</span><br><span class="line">            int right=nums.length-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                if(nums[left]+nums[right]==target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp= new ArrayList&lt;Integer&gt;();</span><br><span class="line">                    temp.add(-target);</span><br><span class="line">                    temp.add(nums[left]);</span><br><span class="line">                    temp.add(nums[right]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    while(++left&lt;right &amp;&amp; nums[left]==nums[left-1]);</span><br><span class="line">                    while(--right&gt;left &amp;&amp; nums[right]==nums[right+1]);</span><br><span class="line">                &#125;else if(nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i+1&lt;nums.length-2 &amp;&amp; nums[i]==nums[i+1]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-33-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode 33. Search in Rotated Sorted Array"></a>Leetcode 33. Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>无比经典的题目， 主要考察的是对binary search的理解。 这里search的array被分为两个部分， 而两个部分都是递增的， 比较直观的解释便是先判断mid处于哪一个部分， 然后再判断target处于哪一个part。具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">  public int search(int[] nums, int target)&#123;</span><br><span class="line">    if(nums.length==0) return -1;</span><br><span class="line">    int left=0;</span><br><span class="line">    int right=nums.length-1;</span><br><span class="line">    while(left&lt;=right)&#123;</span><br><span class="line">      int mid= left+(right-left)/2;</span><br><span class="line">      if(nums[mid]==target)&#123;</span><br><span class="line">        return mid;</span><br><span class="line">      &#125;</span><br><span class="line">      if(nums[mid]&gt;=nums[left])&#123;//  judge which part does mid fall into</span><br><span class="line">        if(target&lt;nums[mid] &amp;&amp; target&gt;= nums[left]) right= mid-1;</span><br><span class="line">        else left= mid+1;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if(target&gt;nums[mid] &amp;&amp; target&lt;= nums[right]) left= mid+1;</span><br><span class="line">        else right=mid-1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-Up-1-what-if-there-are-duplicate-exists"><a href="#Follow-Up-1-what-if-there-are-duplicate-exists" class="headerlink" title="Follow-Up 1, what if there are duplicate exists?"></a>Follow-Up 1, what if there are duplicate exists?</h4><p>The only difference is that due to the existence of duplicates, we can have nums[left]==nums[mid] and in that case, the first half could be out of order(i.e. NOT in the ascending order, e.g.[3,1,2,3,3,3,3]) and we have to deal with this case separately. In that case, it’s guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]==nums[left]==nums[right] before the original logic, if so, we can move left and right both towards the middle by 1. and repeat</p>
<h4 id="follow-up-solution-1"><a href="#follow-up-solution-1" class="headerlink" title="follow-up solution 1"></a>follow-up solution 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right =  nums.size()-1, mid;</span><br><span class="line">        </span><br><span class="line">        while(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; 1;</span><br><span class="line">            if(nums[mid] == target) return true;</span><br><span class="line"></span><br><span class="line">            // the only difference from the first one, trickly case, just updat left and right</span><br><span class="line">            if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125;</span><br><span class="line"></span><br><span class="line">            else if(nums[left] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1;</span><br><span class="line">                else left = mid + 1; </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+1;</span><br><span class="line">                else right = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="follow-up-solution-2"><a href="#follow-up-solution-2" class="headerlink" title="follow-up solution 2"></a>follow-up solution 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">     public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums.length==0) return false;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=nums.length-1;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]==target) return true;</span><br><span class="line">            if(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">               if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">                   right=mid-1;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   left=mid+1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;else if(nums[mid]&lt;nums[left])&#123;</span><br><span class="line">               if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right])&#123;</span><br><span class="line">                   left=mid+1;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   right=mid-1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Follow-up 2 Find Minimum in Rotated Sorted Array"></a>Follow-up 2 Find Minimum in Rotated Sorted Array</h4><p>In such condition, we try to maintain the structure of the array, and delete part of it when we find mid, the most important case is that when the left pointer is already in the right part, which means we can stop the finding process.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMin(int[] nums) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right= nums.length-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(nums[left]&lt;nums[right]) return nums[left];</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]&gt;=nums[left])&#123;// mid fall into the left part</span><br><span class="line">                left=mid+1;// then we can just move to the right</span><br><span class="line">            &#125;else&#123;// else if mid fall into the right part</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-up-3-What-if-there-are-duplicates-in-follow-up-2"><a href="#Follow-up-3-What-if-there-are-duplicates-in-follow-up-2" class="headerlink" title="Follow-up 3 What if there are duplicates in follow-up 2"></a>Follow-up 3 What if there are duplicates in follow-up 2</h4><p>Things become easy since we have solved problem 2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMin(int[] nums) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right= nums.length-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(nums[left]&lt;nums[right]) return nums[left];</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">                left=mid+1;</span><br><span class="line">            &#125;else if(nums[mid]&lt;nums[left])&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when completed the three follow-up, things become easy when we want to find the median/max:</p>
<p>we just find the minimum, and then find it’s index, then we know the turn point, by which we can know the original structure of the array.</p>
<h3 id="Leetcode-72"><a href="#Leetcode-72" class="headerlink" title="Leetcode 72"></a>Leetcode 72</h3><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>典型的DP问题， 解决一道题解决所有题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][] dp= new int[word1.length()+1][word2.length()+1];</span><br><span class="line">        for(int i=0; i&lt;=word1.length(); i++)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0; j&lt;=word2.length(); j++)&#123;</span><br><span class="line">            dp[0][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=word1.length(); i++)&#123;</span><br><span class="line">            for(int j=1; j&lt;=word2.length(); j++)&#123;</span><br><span class="line">                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    int delete=Math.min(dp[i][j-1], dp[i-1][j])+1;</span><br><span class="line">                    int replace=dp[i-1][j-1]+1;</span><br><span class="line">                    dp[i][j]=Math.min(delete, replace);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如： leetcode 712. Minimum ASCII Delete Sum for Two Strings</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minimumDeleteSum(String s1, String s2) &#123;</span><br><span class="line">        int[][] dp= new int[s1.length()+1][s2.length()+1];</span><br><span class="line">        int min=Integer.MAX_VALUE;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0; i&lt;=s1.length(); i++)&#123;</span><br><span class="line">            dp[i][0]=(i&gt;0? dp[i-1][0]+s1.charAt(i-1):0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0; j&lt;=s2.length(); j++)&#123;</span><br><span class="line">            dp[0][j]=(j&gt;0? dp[0][j-1]+s2.charAt(j-1):0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=s1.length(); i++)&#123;</span><br><span class="line">            for(int j=1; j&lt;=s2.length(); j++)&#123;</span><br><span class="line">                if(s1.charAt(i-1)==s2.charAt(j-1)) dp[i][j]= dp[i-1][j-1];</span><br><span class="line">                else dp[i][j]=Math.min(dp[i][j-1]+ s2.charAt(j-1), dp[i-1][j]+s1.charAt(i-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-324-Wiggle-Sort-II"><a href="#Leetcode-324-Wiggle-Sort-II" class="headerlink" title="Leetcode 324. Wiggle Sort II"></a>Leetcode 324. Wiggle Sort II</h3><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>这道题被categorized as medium， 但是实际上到达了hard的难度， 我们如何在O(n)的事件复杂度里面解决该题呢，基本的思想是， 我们要先找到array中的中位数， 然后依据该中位数进行排列， 使得排列后的数列满足我们的条件。</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void wiggleSort(int[] nums) &#123;</span><br><span class="line">        int median=findKthLargest(nums, (nums.length+1)/2);</span><br><span class="line">        // here we just try to solve it in O(n);</span><br><span class="line">        int[] temp= new int[nums.length];</span><br><span class="line">        int s=0, t= nums.length-1, mid_index=(nums.length+1)&gt;&gt;1;</span><br><span class="line">      //when we find the median,we try to rearrange the array to satisified the requirement.</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(nums[i]&lt;median) temp[s++]= nums[i];</span><br><span class="line">            else if(nums[i]&gt;median) temp[t--]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        while(s&lt;mid_index) temp[s++]= median;</span><br><span class="line">        while(t&gt;=mid_index) temp[t--]= median;</span><br><span class="line">      // after three-way partition</span><br><span class="line">        t= nums.length;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            nums[i]=(i&amp;1)==0? temp[--s]: temp[--t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int idx= partition(nums, lo, hi);</span><br><span class="line">            if(idx&gt;k)&#123;</span><br><span class="line">                hi= idx-1;</span><br><span class="line">            &#125;else if(idx&lt;k)&#123;</span><br><span class="line">                lo= idx+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    private int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        if(lo&gt;=hi) return lo;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key=nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int tmp= nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-215-Kth-Largest-Element-in-An-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-An-Array" class="headerlink" title="Leetcode 215 . Kth Largest Element in An Array"></a>Leetcode 215 . Kth Largest Element in An Array</h3><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>The smart approach for this problem is to use the selection algorithm, based on the partition method - the same one as used in quicksort</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int idx= partition(nums, lo, hi);</span><br><span class="line">            if(idx&gt;k)&#123;</span><br><span class="line">                hi= idx-1;</span><br><span class="line">            &#125;else if(idx&lt;k)&#123;</span><br><span class="line">                lo= idx+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    private int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        if(lo&gt;=hi) return lo;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key=nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int tmp= nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-376-Wiggle-Subsequence"><a href="#Leetcode-376-Wiggle-Subsequence" class="headerlink" title="Leetcode. 376 Wiggle Subsequence"></a>Leetcode. 376 Wiggle Subsequence</h3><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题一开始用的是很蠢的dp； 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public int wiggleMaxLength(int[] nums)&#123;</span><br><span class="line">        if(nums.length==0) return 0;</span><br><span class="line">        if(nums.length==1) return 1;</span><br><span class="line">        int[] decrease= new int[nums.length];// the previous is decrease</span><br><span class="line">        int[] increase= new int[nums.length];// the previous is increase</span><br><span class="line">        int res=0;</span><br><span class="line">        increase[0]=1;</span><br><span class="line">        decrease[0]=1;</span><br><span class="line">        for(int i=1; i&lt;nums.length; i++)&#123;</span><br><span class="line">            increase[i]=1;</span><br><span class="line">            decrease[i]=1;</span><br><span class="line">            for(int j=0; j&lt;i; j++)&#123;</span><br><span class="line">                if(nums[i]&gt;nums[j])</span><br><span class="line">                    increase[i]=Math.max(decrease[j]+1, increase[i]);</span><br><span class="line">                if(nums[i]&lt;nums[j])</span><br><span class="line">                    decrease[i]=Math.max(increase[j]+1, decrease[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(increase[i], res);</span><br><span class="line">            res=Math.max(decrease[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(n^2)，属于能解出来但是没能对问题有深入理解的：</p>
<p>我们没有必要去追溯之前的每一个值， 只要最近的一个， 也就是i-1就可以了。画个图我们就能理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums)&#123;</span><br><span class="line">        if(nums.length&lt;2) return nums.length;</span><br><span class="line">      int down=1, up=1;</span><br><span class="line">      for(int i=1; i&lt;nums.length; i++)&#123;</span><br><span class="line">          if(nums[i]&gt;nums[i-1]) up=down+1;</span><br><span class="line">        else if(nums[i]&lt;nums[i-1])</span><br><span class="line">          down=up+1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.max(down, up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-227-Basic-Calculator"><a href="#Leetcode-227-Basic-Calculator" class="headerlink" title="Leetcode 227. Basic Calculator"></a>Leetcode 227. Basic Calculator</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>如何将中缀表达式转换为后缀表达式：</p>
<ol>
<li>当遇到数字直接送至输出队列中；</li>
<li>当读到运算符t时：<ol>
<li>将栈中所有优先级高于或等于t的运算符弹出， 送到输出队列中（aka, 从栈顶开始， 依次弹出比当前处理的运算符优先级高的运算符， 直到一个比他优先级低的或者遇到了一个左括号就停止）。</li>
<li>t进栈</li>
</ol>
</li>
</ol>
<ol>
<li>读到左括号时总是将它压入栈中；</li>
<li>读到右括号时， 将靠近栈顶的第一个左括号上面的运算符全部依次弹出， 送至输出队列后， 再丢弃左括号。</li>
<li>中缀表达式全部读完后， 若栈中仍有运算符， 将其送到输出队列中。</li>
</ol>
<p>运用后缀表达式进行运算：</p>
<ol>
<li><p>建立一个栈S;</p>
</li>
<li><p>从左到右读后缀表达式， 读到数字就让它转换成数值压入栈S中， 读到运算符则从栈中依次弹出两个树分别到Y和X， 然后以“X运算符Y”的形式计算机出结果， 再压入栈S中；</p>
</li>
<li><p>如果后缀表达式未读完， 就重复上面过程， 最后输出栈顶的数值则为结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">while there are tokens to be read:</span><br><span class="line"></span><br><span class="line">read a token.</span><br><span class="line"></span><br><span class="line">if the token is a number, then push it to the output queue.</span><br><span class="line"></span><br><span class="line">if the token is an operator, then:</span><br><span class="line"></span><br><span class="line">    while there is an operator at the top of the operator stack with</span><br><span class="line">    	greater than or equal to precedence and the operator is left associative:</span><br><span class="line">    		pop operators from the operator stack, onto the output queue.</span><br><span class="line">    push the read operator onto the operator stack.</span><br><span class="line"></span><br><span class="line">if the token is a left bracket (i.e. &quot;(&quot;), then:</span><br><span class="line"></span><br><span class="line">    push it onto the operator stack.</span><br><span class="line"></span><br><span class="line">if the token is a right bracket (i.e. &quot;)&quot;), then:</span><br><span class="line"></span><br><span class="line">    while the operator at the top of the operator stack is not a left bracket:</span><br><span class="line">    	pop operators from the operator stack onto the output queue.</span><br><span class="line">    pop the left bracket from the stack.</span><br><span class="line">    /* if the stack runs out without finding a left bracket, then there are</span><br><span class="line">    mismatched parentheses. */</span><br><span class="line"></span><br><span class="line">if there are no more tokens to read:</span><br><span class="line"></span><br><span class="line">    while there are still operator tokens on the stack:</span><br><span class="line">    /* if the operator token on the top of the stack is a bracket, then</span><br><span class="line">    there are mismatched parentheses. */</span><br><span class="line">    pop the operator onto the output queue.</span><br><span class="line"></span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public  int calculate(String s)&#123;</span><br><span class="line">        s=s.replace(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        Stack&lt;String&gt; operators= new Stack&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; tokens= new ArrayList&lt;String&gt;();</span><br><span class="line">        // transfer to suffix expression</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            char ch= s.charAt(i);</span><br><span class="line">            if(ch==&apos;+&apos; || ch==&apos;-&apos;)&#123;</span><br><span class="line">                while(!operators.isEmpty())&#123;</span><br><span class="line">                    tokens.add(operators.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operators.push(String.valueOf(ch));</span><br><span class="line">            &#125;else if(ch==&apos;*&apos; || ch==&apos;/&apos;)&#123;</span><br><span class="line">                while(!operators.isEmpty() &amp;&amp; (operators.peek().equals(&quot;*&quot;)||operators.peek().equals(&quot;/&quot;)))&#123;</span><br><span class="line">                    tokens.add(operators.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operators.push(String.valueOf(ch));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                StringBuilder sb= new StringBuilder();</span><br><span class="line">                while(i&lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                    sb.append(s.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                tokens.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!operators.isEmpty())&#123;</span><br><span class="line">            tokens.add(operators.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        // calculate the suffix expression</span><br><span class="line">        Stack&lt;Integer&gt; nums= new Stack&lt;Integer&gt;();</span><br><span class="line">        for(String token: tokens)&#123;</span><br><span class="line">            if(Character.isDigit(token.charAt(0)))&#123;</span><br><span class="line">                nums.push(Integer.valueOf(token));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int num_2=nums.pop();</span><br><span class="line">                int num_1=nums.pop();</span><br><span class="line">                nums.push(cal(num_1,num_2, token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    private int cal(int num1, int num2, String token)&#123;</span><br><span class="line">        if(token.equals(&quot;+&quot;)) return num1+num2;</span><br><span class="line">        if(token.equals(&quot;*&quot;)) return num1*num2;</span><br><span class="line">        if(token.equals(&quot;-&quot;)) return num1-num2;</span><br><span class="line">        if(token.equals(&quot;/&quot;)) return num1/num2;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee"></a>Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</h3><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The maximum profit can be achieved by:</span><br><span class="line">Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure>
<h4 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h4><p>经典的状态机，Stock系列的新题， 但是基本上跟之前的题目差不多， 我们用两个状态 one and zero 来记录手上握有的股票数量， 利用更新dp公式进行两个状态的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int maxProfit(int[] prices, int fee)&#123;</span><br><span class="line">        // two state: one and zero;</span><br><span class="line">        if(prices.length&lt;=1) return 0;</span><br><span class="line">        long zero=0;</span><br><span class="line">        long one=Integer.MIN_VALUE;</span><br><span class="line">        for(int i=0; i&lt;prices.length; i++)&#123;</span><br><span class="line">            long zero_prev=zero;</span><br><span class="line">            long one_prev=one;</span><br><span class="line">            zero=Math.max(zero_prev, one_prev+prices[i]-fee);</span><br><span class="line">            one= Math.max(one_prev, zero_prev-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)Math.max(one, zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-609-Find-Duplicate-File-in-System"><a href="#Leetcode-609-Find-Duplicate-File-in-System" class="headerlink" title="Leetcode 609. Find Duplicate File in System"></a>Leetcode 609. Find Duplicate File in System</h3><h3 id="Leetcode-450-Delete-Node-in-a-BST"><a href="#Leetcode-450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode 450. Delete Node in a BST"></a>Leetcode 450. Delete Node in a BST</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root = [5,3,6,2,4,null,7]</span><br><span class="line">key = 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line"></span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   6</span><br><span class="line"> /     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">Another valid answer is [5,2,6,null,4,null,7].</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>
<h4 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h4><p>骚的要死的递归， 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key)&#123;</span><br><span class="line">        if(root==null) return null;</span><br><span class="line">        if(root.val&gt;key)&#123;</span><br><span class="line">            root.left=deleteNode(root.left, key);</span><br><span class="line">        &#125;else if(root.val&lt;key)&#123;</span><br><span class="line">            root.right= deleteNode(root.right, key);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root=deleteRoot(root);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode deleteRoot(TreeNode root)&#123;</span><br><span class="line">        if(root.left==null) return root.right;</span><br><span class="line">        if(root.right==null) return root.left;</span><br><span class="line">        TreeNode node= root.right;</span><br><span class="line">        while(node.left!=null)&#123;</span><br><span class="line">            node= node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.val=node.val;</span><br><span class="line">        root.right=deleteNode(root.right, root.val);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">      private TreeNode deleteRoot(TreeNode root) &#123;</span><br><span class="line">        ifs (root==null) return null;</span><br><span class="line">        if (root.right==null) return root.left;</span><br><span class="line">        TreeNode x=root.right; // root.right should be the new root</span><br><span class="line">        while (x.left!=null) x=x.left; // find the left-most node</span><br><span class="line">        x.left=root.left;</span><br><span class="line">        return root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-32-Longest-Valid-Parentheses"><a href="#Leetcode-32-Longest-Valid-Parentheses" class="headerlink" title="Leetcode 32. Longest Valid Parentheses"></a>Leetcode 32. Longest Valid Parentheses</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p>
<p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p>
<h4 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h4><p>对于这一类问题， 基本都是two-pass， 从左到右扫描一遍， 再从右到做扫描一遍。</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s)&#123;</span><br><span class="line">        int prev=-1;</span><br><span class="line">        int count=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.charAt(i)==&apos;(&apos;) count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&lt;0)&#123;</span><br><span class="line">                count=0;</span><br><span class="line">                prev=i;</span><br><span class="line">            &#125;else if(count==0)&#123;</span><br><span class="line">                res=Math.max(res, i-prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev=s.length();</span><br><span class="line">        count=0;</span><br><span class="line">        for(int i=s.length()-1; i&gt;=0; i--)&#123;</span><br><span class="line">            if(s.charAt(i)==&apos;)&apos;) count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&lt;0)&#123;</span><br><span class="line">                count=0;</span><br><span class="line">                prev=i;</span><br><span class="line">            &#125;else if(count==0)&#123;</span><br><span class="line">                res= Math.max(res, prev-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-34-Search-for-a-Range"><a href="#Leetcode-34-Search-for-a-Range" class="headerlink" title="Leetcode 34. Search for a Range"></a>Leetcode 34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>非常经典的一道binary search， 考察对二分搜索的理解程度， 这里我们先看一个链接<a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">二分搜索有几种方式</a>。</p>
<p>首先有几个数字要注意</p>
<p>中位数有两个，</p>
<ol>
<li>下位中位数， lowerMedian=(length-2)/2</li>
<li>上位中位数， upperMedian=length/2</li>
</ol>
<p>常用的是下位中位数， 通用的写法如下， 语言int经常自动向下取整，</p>
<blockquote>
<p>median=(length-1)/2</p>
</blockquote>
<p>指针的区间当然可以开区间，也可以闭区间， 也可以半开半闭。 但老老实实两头取闭区间总是不会错。 上面的中位数， 转换成两头闭区间就会变成这样：</p>
<blockquote>
<p>median=low+(hight-low)/2；</p>
</blockquote>
<p>另一个关键点是<strong>终止条件</strong>。</p>
<p>不要以low=high做终止条件，会被跳过的。</p>
<p>不相信在[1,5]里面找0试试？</p>
<p>正确的终止条件是：</p>
<blockquote>
<p>low&gt;high</p>
</blockquote>
<p>也就是搜索空间为空。</p>
<p>满足终止条件之后， 返回值完全不需要纠结， 直接返回地位low。</p>
<p>因为回过头去放慢镜头， 二分查找到的过程就是一个维护low的过程：</p>
<blockquote>
<p>low从0 开始， 只在中位数遇到确定小于目的数时才前进， 并且永不后退。 low一直在朝着第一个目标数的位置在逼近。 直到最后到达。</p>
</blockquote>
<p>至于高位high， 就放心大胆地缩小目标数组的空间吧。</p>
<p>所以最后的代码非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] nums, int target)&#123;</span><br><span class="line">    int low=0, high= nums.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">      int mid= low+(high-low)/2;</span><br><span class="line">    if(nums[mid]&lt;target)&#123;</span><br><span class="line">        low= mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(nums[mid]&gt;target)&#123;</span><br><span class="line">        high= mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(nums[mid]==target) return mid;</span><br><span class="line">  &#125;</span><br><span class="line">  return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上面的代码能正常工作，有一个前提条件：</p>
<p>元素空间没有重复值。</p>
<p>推广到有重复值的空间， 二分查找问题就变成：</p>
<p>寻找元素第一次出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int firstOccurrence(int[] nums, int target)&#123;</span><br><span class="line">    int low=0, high= nums.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">      int mid= low+(high-low)/2;</span><br><span class="line">    if(nums[mid]&lt;target) low=mid+1;</span><br><span class="line">    else high= mid-1;</span><br><span class="line">  &#125;</span><br><span class="line">  return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述讲解， 我们有下面两种代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        if(nums.length==0) return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        int left=searchInsertLo(nums, target);</span><br><span class="line">        if(left==nums.length || nums[left]!=target)&#123;</span><br><span class="line">            return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int right=searchInsertHi(nums, target);</span><br><span class="line">        return new int[]&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchInsertLo(int[] nums, int target) &#123;</span><br><span class="line">        if(target&gt;nums[nums.length-1]) return nums.length;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi)/2;</span><br><span class="line">            if(nums[mid]&gt;=target)&#123;</span><br><span class="line">                hi=mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                lo=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchInsertHi(int[] nums, int target)&#123;</span><br><span class="line">        if(target&gt;nums[nums.length-1]) return nums.length;</span><br><span class="line">        if(target&lt;nums[0]) return 0;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi+1)/2;</span><br><span class="line">            if(nums[mid]&gt;target)&#123;</span><br><span class="line">                hi=mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                lo=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target)&#123;</span><br><span class="line">        if(nums.length==0) return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        int left= searchLeft(nums, target);</span><br><span class="line">        if(left==nums.length || nums[left]!=target)&#123;</span><br><span class="line">            return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int right= searchLeft(nums, target+1)-1;</span><br><span class="line">        return new int[]&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchLeft(int[] nums, int key)&#123;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+(hi-lo)/2;</span><br><span class="line">            if(nums[mid]&lt;key)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(nums[mid]&gt;=key)&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Leetcode 114. Flatten Binary Tree to Linked List"></a>Leetcode 114. Flatten Binary Tree to Linked List</h3><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,</p>
<p>Given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<h4 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h4><p>这道题是很经典的关于Tree的遍历以及对tree结构的修改的题目， 这里我们先观察输出的结构， 发现它是遵循preorder的顺序的， 于是这里我们先利用preorder得出整个tree的结构， 然后在这个过程里面进行修改。</p>
<p>先看下面一种解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void flatten_stack(TreeNode root)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack= new Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node= root;</span><br><span class="line">        TreeNode prev= root;</span><br><span class="line">        while(!stack.isEmpty() || node!=null)&#123;</span><br><span class="line">            if(node!=null)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                prev= node;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                TreeNode pop= stack.pop();</span><br><span class="line">                node= node.right;</span><br><span class="line">                pop.right= null;</span><br><span class="line">                prev.left= node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node= root;</span><br><span class="line">        while(node!=null)&#123;</span><br><span class="line">            TreeNode left= node.left;</span><br><span class="line">            node.left= null;</span><br><span class="line">            node.right= left;</span><br><span class="line">            node= node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先把树输出为向左的linkedlist， 而后再reverse就好了。</p>
<p>这个也可以使用recursive完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        if(root.left==null)&#123;</span><br><span class="line">            flatten(root.right);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode left= root.left;</span><br><span class="line">        root.left= null;</span><br><span class="line">        TreeNode right= root.right;</span><br><span class="line">        TreeNode node= left;</span><br><span class="line">        while(node.right!=null)&#123;</span><br><span class="line">            node= node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root.right=left;</span><br><span class="line">        node.right= right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最神奇的做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode prev = null;</span><br><span class="line"></span><br><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = prev;</span><br><span class="line">    root.left = null;</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点讲解一下最后一个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode prev = null;</span><br><span class="line"></span><br><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构是典型的post-order遍历， 我们得到的序列是什么呢？</p>
<p>以上面的tree为例子： root的输出结果是： null, 6， 5，4，3，2,1,我们就是依靠root， prev的结果进行对树的机构进行重构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.right= prev;</span><br><span class="line">root.left = null;</span><br></pre></td></tr></table></figure>
<p>进行了上述结构之后， 我们就完成了重构。</p>
<h3 id="Leetcode-44-Wildcard-Matching"><a href="#Leetcode-44-Wildcard-Matching" class="headerlink" title="Leetcode 44. Wildcard Matching"></a>Leetcode 44. Wildcard Matching</h3><p>Implement wild card pattern matching with support for “?” and “*”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br><span class="line"></span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">The function prototype should be:</span><br><span class="line">bool isMatch(const char *s, const char *p)</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class="line">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;*&quot;) → true</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class="line">isMatch(&quot;ab&quot;, &quot;?*&quot;) → true</span><br><span class="line">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</span><br></pre></td></tr></table></figure>
<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>典型的dp问题， 比较tricky的一个点是如果碰到’*’怎么办， 这个时候， 我们采取回退的思想， 如果碰到的时候:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// when p.charAt(j)==&apos;*&apos;, we check if dp[i-1][j]; </span><br><span class="line">// 这里把疑问推给上一个问题， 比较巧妙。</span><br><span class="line">dp[i][j]= dp[i-1][j] || dp[i][j-1];</span><br></pre></td></tr></table></figure>
<p>code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s, String p)&#123;</span><br><span class="line">    boolean[][] dp= new boolean[s.length()+1][p.length()+1];</span><br><span class="line">  dp[0][0]= true;</span><br><span class="line">  for(int i=1; i&lt;= p.length(); i++)&#123;</span><br><span class="line">      if(p.charAt(i-1)==&apos;*&apos;) dp[0][i]= dp[0][j-1];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=s.length(); i++)&#123;</span><br><span class="line">      for(int j=1; j&lt;=p.length(); j++)&#123;</span><br><span class="line">          char ch= p.charAt(j-1);</span><br><span class="line">        if(ch==&apos;?&apos; || s.charAt(i-1)==ch) dp[i][j]= dp[i-1][j-1];</span><br><span class="line">        else if(ch==&apos;*&apos;)&#123;</span><br><span class="line">            dp[i][j]= dp[i][j-1] || dp[i-1][j];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dp[i][j]= false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10. Regular Expression Matching"></a>Leetcode 10. Regular Expression Matching</h3><p>Implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br><span class="line"></span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">The function prototype should be:</span><br><span class="line">bool isMatch(const char *s, const char *p)</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class="line">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;ab&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</span><br></pre></td></tr></table></figure>
<p>这道题和上面那道题目基本上是一样的， 所不同的是， 这次我们要把 a* 作为一个整体去考虑， 对于这样一个元素，我们可以匹配:</p>
<ol>
<li><p>空字符串。</p>
</li>
<li><p>a， 这个时候基本上就消除了*的影响。</p>
</li>
<li><p>多个a， 这个时候 * 还在起作用 我们像上一道题目一样惊醒回退。</p>
<p>​</p>
</li>
</ol>
<p>这里题目应该是假设字符串一定是合法的， 即不会出现*前面没有合法字符的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        if(s == null || p == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        state[0][0] = true;</span><br><span class="line">        // no need to initialize state[i][0] as false</span><br><span class="line">        // initialize state[0][j]</span><br><span class="line">        for (int j = 1; j &lt; state[0].length; j++) &#123;</span><br><span class="line">            if (p.charAt(j - 1) == &apos;*&apos;) &#123;</span><br><span class="line">                if (state[0][j - 1] || (j &gt; 1 &amp;&amp; state[0][j - 2])) &#123;</span><br><span class="line">                    state[0][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; state.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; state[0].length; j++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &apos;.&apos;) &#123;</span><br><span class="line">                    state[i][j] = state[i - 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (p.charAt(j - 1) == &apos;*&apos;) &#123;</span><br><span class="line">                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != &apos;.&apos;) &#123;</span><br><span class="line">                        state[i][j] = state[i][j - 2];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return state[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-222-Count-Complete-Tree-Nodes"><a href="#leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="leetcode 222. Count Complete Tree Nodes."></a>leetcode 222. Count Complete Tree Nodes.</h3><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h4 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题需要注意的是题目中给我们的是complete tree，which means， root.left 和 root.right中必定有一株树是满的， 而哪一个数是满的则需要看最后一个node是终止在哪里， 也就是说， height， 这里我们计算每棵树的height便可以解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int height(TreeNode root)&#123;</span><br><span class="line">        int h=-1;</span><br><span class="line">        TreeNode node =root;</span><br><span class="line">        while(node!= null)&#123;</span><br><span class="line">            node= node.left;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root== null) return 0;</span><br><span class="line">        int h= height(root);</span><br><span class="line">        int left= height(root.right);</span><br><span class="line">        if(left== h-1)&#123;</span><br><span class="line">            // the left tree is full tree;</span><br><span class="line">            return countNodes(root.right)+ (1&lt;&lt;h);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return countNodes(root.left)+ (1&lt;&lt;(h-1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-322-Coin-Change"><a href="#Leetcode-322-Coin-Change" class="headerlink" title="Leetcode 322. Coin Change"></a>Leetcode 322. Coin Change</h3><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p>
<p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p>
<p><strong>Note</strong>:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p>经典dp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        int[] dp= new int[amount+1];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[0]= 0;</span><br><span class="line">        for(int coin: coins)&#123;</span><br><span class="line">            for(int i=coin; i&lt;=amount; i++)&#123;</span><br><span class="line">                if(dp[i-coin]==Integer.MAX_VALUE) continue;</span><br><span class="line">                dp[i]=Math.min(dp[i- coin]+1, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount]==Integer.MAX_VALUE? -1: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-518-Coin-Change2"><a href="#Leetcode-518-Coin-Change2" class="headerlink" title="Leetcode 518 Coin Change2"></a>Leetcode 518 Coin Change2</h3><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p><strong>Note:</strong> You can assume that</p>
<ul>
<li>0 &lt;= amount &lt;= 5000</li>
<li>1 &lt;= coin &lt;= 5000</li>
<li>the number of coins is less than 500</li>
<li>the answer is guaranteed to fit into signed 32-bit integer</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 3, coins = [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 10, coins = [10] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-312-Burst-Ballons"><a href="#Leetcode-312-Burst-Ballons" class="headerlink" title="Leetcode 312. Burst Ballons"></a>Leetcode 312. Burst Ballons</h3><p>运用dp的做法， 逆向思维， 很骚。</p>
<h3 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143. Reorder List"></a>Leetcode 143. Reorder List</h3><hr>
<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p>
<p>典型的链表题， 快慢指针+ node的插入+list reverse.</p>
<h4 id="Solution-19"><a href="#Solution-19" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        // first reverse the listnode from middle;</span><br><span class="line">        if(head== null || head.next==null) return;</span><br><span class="line">        ListNode fast= head;</span><br><span class="line">        ListNode slow= head;</span><br><span class="line">        ListNode prev= head;</span><br><span class="line">        while(fast!= null &amp;&amp; fast.next!=null)&#123;</span><br><span class="line">            prev= slow;</span><br><span class="line">            slow= slow.next;</span><br><span class="line">            fast= fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail= slow;</span><br><span class="line">        while(tail.next!= null)&#123;</span><br><span class="line">            ListNode next= tail.next;</span><br><span class="line">            tail.next= next.next;</span><br><span class="line">            next.next= prev.next;</span><br><span class="line">            prev.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid= prev.next;</span><br><span class="line">        ListNode node= head;</span><br><span class="line">        while(node!=prev)&#123;</span><br><span class="line">            prev.next= mid.next;</span><br><span class="line">            mid.next= node.next;</span><br><span class="line">            node.next= mid;</span><br><span class="line">            node= node.next.next;</span><br><span class="line">            mid= prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92. Reverse Linked List II"></a>Leetcode 92. Reverse Linked List II</h3><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<h3 id="Solution-20"><a href="#Solution-20" class="headerlink" title="Solution"></a>Solution</h3><p>综合性的链表题目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">        ListNode dummy= new ListNode(0);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode prev= dummy;</span><br><span class="line">        for(int i=1; i&lt;m; i++)&#123;</span><br><span class="line">            prev= prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail= prev.next;</span><br><span class="line">        for(int i=0; i&lt;n-m; i++)&#123;</span><br><span class="line">            ListNode next= tail.next;</span><br><span class="line">            tail.next= next.next;</span><br><span class="line">            next.next= prev.next;</span><br><span class="line">            prev.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-274-H-Index"><a href="#Leetcode-274-H-Index" class="headerlink" title="Leetcode 274 H- Index"></a>Leetcode 274 H- Index</h3><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least*</strong>h<em>citations each, and the other </em>N − h<em> papers have <strong>no more than</strong> </em>h* citations each.”</p>
<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong><code>3</code>citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>
<p><strong>Note</strong>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>
<h4 id="Solution-21"><a href="#Solution-21" class="headerlink" title="Solution"></a>Solution</h4><p>感觉主要还是对于题意的理解， 对于这道题来说，对于一个长度为N的Array， 因为我们要求这么一个常数h， 使得大于等于h的个数要不小于h， 也就是说我们其实是可以先排序， 然后统计个数， 得到count以及该数字， 如果满足上述条件， 我们可以返回，得到当前数字。</p>
<p>需要注意的地方是count++， 以及if statement的顺序： 应该是if statement放在前面， 要不然可能会多算： ex: [1, 2];</p>
<p>Simple Version:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  // we simple count the two number, and when it meets the requirement, we output it and that is the answer, what need to notice is the order of if statement and increacement; </span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        // A scientist has index h if h of his/her papers have at least h citations each, and other N-h papers has no more than h citations each;</span><br><span class="line">        if(citations.length==0) return 0;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=citations.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">            if(citations[i]==0) continue;</span><br><span class="line">            if(count&gt;=citations[i]) return count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察到h最大只能是N， 我们可以用bucket sort 进行改善：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations)&#123;</span><br><span class="line">    int[] buckets= new int[citations.length+1];</span><br><span class="line">    for(int num: citations)&#123;</span><br><span class="line">        if(num&gt;= citations.length)&#123;</span><br><span class="line">            buckets[citations.length]++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            buckets[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i= buckets.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        count+=buckets[i];</span><br><span class="line">        if(count&gt;=i) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FollowUp"><a href="#FollowUp" class="headerlink" title="FollowUp"></a>FollowUp</h4><p>What if the citations array is sorted in ascending order? Could you optimize algorithm？</p>
<p>在这种情况下， 题目演变成一个binary search的题目： 我们需要找到的是 citations[mid]刚好小于len- mid的那一个点。(这个mid西需要尽量往左边移， 也就是标准的binary search)。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        int left=0, len = citations.size(), right= len-1,  mid;</span><br><span class="line">        while(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)&gt;&gt;1;</span><br><span class="line">            if(citations[mid]== (len-mid)) return citations[mid];</span><br><span class="line">            else if(citations[mid] &gt; (len-mid)) right = mid - 1;</span><br><span class="line">            else left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len - (right+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Leetcode 378. Kth Smallest Element in a Sorted Matrix"></a>Leetcode 378. Kth Smallest Element in a Sorted Matrix</h3><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h4 id="Solution-22"><a href="#Solution-22" class="headerlink" title="Solution"></a>Solution</h4><p>比较简单/ straightforward的方法是使用priorityqueue， 相当于进行了一次mergesort进行寻找， 这里我们直接贴出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private class Entry&#123;</span><br><span class="line">        int val;</span><br><span class="line">        int index_x;</span><br><span class="line">        int index_y;</span><br><span class="line">        public Entry(int val, int index_x, int index_y)&#123;</span><br><span class="line">            this.val= val;</span><br><span class="line">            this.index_x= index_x;</span><br><span class="line">            this.index_y= index_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int kthSmallest(int[][] matrix, int k) &#123;</span><br><span class="line">        PriorityQueue&lt;Entry&gt; pq= new PriorityQueue&lt;&gt;((e1, e2)-&gt;&#123;return e1.val- e2.val;&#125;);</span><br><span class="line">        for(int i=0; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            pq.offer(new Entry(matrix[i][0], i, 0));</span><br><span class="line">        &#125;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">            Entry e= pq.poll();</span><br><span class="line">            k--;</span><br><span class="line">            if(k==0) return e.val;</span><br><span class="line">            if(e.index_y+1&lt;matrix[0].length)&#123;</span><br><span class="line">                pq.offer(new Entry(matrix[e.index_x][e.index_y+1], e.index_x, e.index_y+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们讲解一个更加快的方法： BinarySearch， 通常的二分搜索， 其搜索空间是在index上面对的，0~Arr.length;这里我们改变搜索空间， 变成min~ max.然后计算其排名。 代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int kthSmallest(int[][] a, int k) &#123;</span><br><span class="line">      int n = a.length;</span><br><span class="line">      int s = a[0][0]; // the smallest number</span><br><span class="line">      int b = a[n - 1][n - 1]; // the biggest number</span><br><span class="line">        </span><br><span class="line">      while(s &lt; b) &#123;</span><br><span class="line">          int mid = s + (b - s) / 2;</span><br><span class="line">          int temp = 0;</span><br><span class="line">          for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">              temp += bs(a[i], n, mid);</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt; k) &#123;</span><br><span class="line">              s = mid + 1;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              b = mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      return s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private int bs(int row[], int right, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        //int pos = right + 1;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if(row[mid] &lt;= target) &#123;</span><br><span class="line">                //pos = mid;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想法：</p>
<p>Let’s binary search for the answer A.</p>
<p>Say enough(x) is true iff there are k or more values in the multiplication table that are less than or equal to x, Colloquially, enough describes whether x is large enough to be the k-th value in the multiplication table.</p>
<p>Then(for our answer A), whenever x&gt;= A, enough(X) is True, and whenever x&lt;A, enough(x) is false.</p>
<p>In our binary search, our loop invariant is that enough(x) is True. More specifically, if we were to apply enough onto each argument in the interval [lo. hi], we would see 0 or more False, followed by 1 or more True. Once lo==hi, we know that enough(lo)=True, and it must have been the smallest such one, because lo must have been hi-1 or hi-2 at some point, and mi= hi-1 would have been checked.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public int findKthNumber(int m, int n, int k)&#123;</span><br><span class="line">        int low=1, high= m*n+1;</span><br><span class="line">      while(lo&lt;high)&#123;</span><br><span class="line">          int mid= low+(high-low)/2;</span><br><span class="line">        int c= count(mid, m, n);</span><br><span class="line">        if(c&gt;= k) high= mid;</span><br><span class="line">        else low= mid+1;</span><br><span class="line">      &#125;</span><br><span class="line">      return high;</span><br><span class="line">    &#125;</span><br><span class="line">  private int count(int v, int m, int n)&#123;</span><br><span class="line">      int count=0;</span><br><span class="line">    for(int i=1; i&lt;= m; i++)&#123;</span><br><span class="line">        int temp= Math.min(v/i, n);</span><br><span class="line">      	count+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthNumber(int m, int n, int k) &#123;</span><br><span class="line">        int low=1, high= m*n;</span><br><span class="line">        while(low&lt;=high)&#123;</span><br><span class="line">            int mid= low+(high-low)/2;</span><br><span class="line">            int c= count(mid, m, n);// calculate the rank </span><br><span class="line">            if(c&gt;=k) high= mid-1; // if rank&gt;= k, means we can still push to left;</span><br><span class="line">            else low= mid+1;// else </span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">    private int count(int v, int m, int n)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)&#123;</span><br><span class="line">            int temp= Math.min(v/i, n);</span><br><span class="line">            count+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Where-和-having-区别"><a href="#Where-和-having-区别" class="headerlink" title="Where 和 having 区别"></a>Where 和 having 区别</h3><p>在select语句中可以使用group by子句将行划分成较小的组， 然后， 使用聚组函数返回每一个组的汇总信息， 另外， 可以使用having子句限制返回的结果集。</p>
<p>在带有group by子句的查询语句中， 在select列表中指定的列要么是group by子句中指定的列， 要么包含聚组函数。</p>
<p>select max(sal), job emp group by job;</p>
<p>当在group by子句中使用having子句时， 查询结果只返回满足having条件的组。</p>
<p>where子句的作用时在查询结果进行分组前， 将不符合where条件的行去掉， 即在分组之前过滤数据， 条件中不能包含聚组函数， 使用where条件显示特定的行。</p>
<p>having子句的作用时筛选满足条件的组， 即在分组之前过滤数据， 条件中经常包含聚组函数， 使用having条件显示特定的组， 也可以使用多个分组标准进行分组。</p>
<p>如果你对何时应该使用WHERE，何时使用HAVING仍旧很迷惑，请遵照下面的说明：</p>
<p>　　WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。</p>
<p>　　HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。</p>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>对于一个长度为n的已排序数列a, 如果n为奇数， 中位数为a[n/2+1]， 若n为偶数， 则中位数(a[n / 2] + a[n / 2 + 1]) / 2; 如果我们可以在两个数列中求取第K小的元素， 便可以解决该问题； 不妨设数列A元素个数为n， 数列B元素个数为m， 各自升序排列，求第k小元素； 取A[k/2] B[k/2]比较； 如果 A[k/2]&gt; B[k/2] 那么， 所求的元素必然不在B的前k/2个元素中；反之， 必然不在A的前k/2个元素中， 于是我们可以将A或B数列的前k/2元素删去， 于是我们得到了数据规模变小的同类问题， 递归解决；</p>
<h3 id="Leetcode-136-Single-Number"><a href="#Leetcode-136-Single-Number" class="headerlink" title="Leetcode 136. Single Number"></a>Leetcode 136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>极度高频题， 记住就是了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(int[] A, int n)&#123;</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    result^=A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a>Roman to Integer</h3><h3 id="Leetcode-204-Count-Primes"><a href="#Leetcode-204-Count-Primes" class="headerlink" title="Leetcode 204. Count Primes"></a>Leetcode 204. Count Primes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countPrimes(int n) &#123;</span><br><span class="line">        if(n&lt;2) return 0;</span><br><span class="line">        if(n==2) return 1;</span><br><span class="line">        boolean[] dp= new boolean[n];</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=2; i&lt;n; i++)&#123;</span><br><span class="line">            if(!dp[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                for(int j=1; j*i&lt;n; j++)&#123;</span><br><span class="line">                    dp[j*i]= true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用-Array实现一个Queue"><a href="#用-Array实现一个Queue" class="headerlink" title="用 Array实现一个Queue"></a>用 Array实现一个Queue</h3><h3 id="背包问题Review"><a href="#背包问题Review" class="headerlink" title="背包问题Review"></a>背包问题Review</h3><h3 id="Java中对JSON文件的读取"><a href="#Java中对JSON文件的读取" class="headerlink" title="Java中对JSON文件的读取"></a>Java中对JSON文件的读取</h3><p>JSON语法是JavaScript对象表示法语法的子集：</p>
<ul>
<li>数据在名称/值 对中</li>
<li>数据由括号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h3 id="Leetcode-68-Text-Justification"><a href="#Leetcode-68-Text-Justification" class="headerlink" title="Leetcode 68. Text Justification"></a>Leetcode 68. Text Justification</h3><p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line, Pad extra spaces ‘’ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<h4 id="Solution-23"><a href="#Solution-23" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目其实满傻逼的….硬算，保持一个index， 每次长度超过L的时候停止， 处理这一行的情况。</p>
<p>注意两种情况：</p>
<ol>
<li>if last line(last==words.length) or the number of words in the line is 1(diff==0) 在这种情况下， 我们需要left-Justify： 添加单词， 添加单词之间的空格， 增加单词之后的空格使得长度为L；</li>
<li>通常情况： middle justify， 在这种情况下， 我们要使得单词之间的空格尽可能均匀， 如果还有空格多的话， 尽量放在左边， 也就是说前面的多放一个空格： 我们把多余的空格数量标记为r， if r&gt;0 我们在需要增加的空格数字加一， 否则直接就是当前空格数。当然， 这种情况下不允许出现最后一个单词之后还有空格。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; fullJustify(String[] words, int L)&#123;</span><br><span class="line">    List&lt;String&gt; lines= new ArrayList&lt;String&gt;();</span><br><span class="line">    int index=0;</span><br><span class="line">    while(index&lt;words.length)&#123;</span><br><span class="line">        int count= words[index].length();</span><br><span class="line">        int last= index+1;</span><br><span class="line">        while(last&lt;words.length)&#123;</span><br><span class="line">            if(words[last].length()+ count+1&gt; L) break;</span><br><span class="line">            count+=words[last].length()+1;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder builder= new StringBuilder();</span><br><span class="line">        int diff= last- index-1;</span><br><span class="line">        // if last line or number of words in the line is 1, left-justified</span><br><span class="line">        if(last==words.length || diff==0)&#123;</span><br><span class="line">            for(int i= index; i&lt;last; i++)&#123;</span><br><span class="line">                builder.append(words[i] +&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.deleteCharAt(builder.length()-1);</span><br><span class="line">            for(int i= builder.length(); i&lt;L; i++)&#123;</span><br><span class="line">                builder.append(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // middle justified</span><br><span class="line">            int spaces= (L- count)/diff;</span><br><span class="line">            int r=(L- count)% diff;</span><br><span class="line">            for(int i= index; i&lt;last; i++)&#123;</span><br><span class="line">                builder.append(words[i]);</span><br><span class="line">                if(i&lt;last-1)&#123;</span><br><span class="line">                    for(int j=0; j&lt;=(spaces+((i-index)&lt;r?1: 0)); j++)&#123;</span><br><span class="line">                        builder.append(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lines.add(builder.toString());</span><br><span class="line">        index= last;</span><br><span class="line">    &#125;</span><br><span class="line">    return lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MapReduce-入门"><a href="#MapReduce-入门" class="headerlink" title="MapReduce 入门"></a>MapReduce 入门</h3><p>给你很多String IDS， 然后用hadoop， mapreduce给这些String IDs assign long int numerical IDs</p>
<h3 id="Find-the-row-with-maximum-number-of-1s"><a href="#Find-the-row-with-maximum-number-of-1s" class="headerlink" title="Find the row with maximum number of 1s"></a>Find the row with maximum number of 1s</h3><p>Given a boolean 2D array, where each row is sorted. Find the row with the maximum number of 1s;</p>
<p>Actually, this is a problem like find the max number in a Array;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int rowWithMax1s(bool mat[R][C])</span><br><span class="line">&#123;</span><br><span class="line">    // Initialize first row as row with max 1s</span><br><span class="line">    int max_row_index = 0;</span><br><span class="line"> </span><br><span class="line">    // The function first() returns index of first 1 in row 0.</span><br><span class="line">    // Use this index to initialize the index of leftmost 1 seen so far</span><br><span class="line">    int j = first(mat[0], 0, C-1);</span><br><span class="line">    if (j == -1) // if 1 is not present in first row</span><br><span class="line">      j = C - 1;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // Move left until a 0 is found</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; mat[i][j] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">           j = j-1;  // Update the index of leftmost 1 seen so far</span><br><span class="line">           max_row_index = i;  // Update max_row_index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_row_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h3><p>There is a maze of size n*n. Tom is sitting at (0,0). Jerry is sitting in another cell(the position of Jerry is input). Then there are k pieces of cheese placed in k different cells(k&lt;=10). Sine cells are blocked while some are not. Tom can move to 4 cells at any point of time(left, right, top, down one position). Tom has to collect all the pieces of cheese and then reach to Jerry’s cell. You need to print the minimum no of steps to required to do so.</p>
<p><a href="https://ide.geeksforgeeks.org/TtAvXJ" target="_blank" rel="noopener">link</a></p>
<h3 id="Diamond"><a href="#Diamond" class="headerlink" title="Diamond"></a>Diamond</h3><p>Diamond Mine is your new favorite game. It;s map is represented as n*n matrix, and the value of each cell corresponds to some property of the map:</p>
<ul>
<li>A value&gt;=0 represent a path.</li>
<li>A value of 1 represents a diamond in a path that can be picked up by the player.</li>
<li>A value of -1 represents a wall;</li>
</ul>
<p>The basic rules for playing Diamond Mine are as follows:</p>
<ul>
<li>The player starts at (0,0) and reaches(n-1, n-1), by moving right or down through valid path cells;</li>
<li>After reaching (n-1, n-1), the player must travel to (0, 0) by moving left or up through valid path cells.</li>
<li>When passing through a path cell containing a diamond, the diamond is picked up. Once picked up, the cell becomes an empty path cell(meaning you cannot pick up the same diamond twice).</li>
<li>If there is no valid path between (0,0) and(n-1, n-1), then no diamonds can be collected.</li>
<li>A player wins the game by collecting the maximum number of diamonds possible when following the above rules.</li>
</ul>
<p>Output the largest number.</p>
<h4 id="格子取数问题"><a href="#格子取数问题" class="headerlink" title="格子取数问题"></a>格子取数问题</h4><p>有n*n个格子， 每个格子里有正数或者0， 从最左上角往最右下角走， 只能向下和向右， 一共走两次， 把所有经过的格子的数加起来， 求最大值SUM， 且两次如果经过同一个格子， 则最后总和SUM中该格子的计数只加一次。</p>
<p>初看到此题目， 因为要让每次走下来的路径和最大， 读者可能最初想到的思路是让每一次的路径都是最优的， 即不顾全局， 只看局部， 让第一次和第二次的路径都是最优。 但问题马上来了， 虽然局部最优， 但是全局却不一定是最优。</p>
<p>上面的题目其实就是我们说的格子取数问题；</p>
<p>DP解法：</p>
<ol>
<li><p>设计态： f(i, j, h, k);// 表示两条路同时走， 第一条路径走到（i, j）时， 第二条路走到(h, k)时的最大数字和；</p>
</li>
<li><p>初始状态： f(0, 0, 0, 0)=0; 最终状态： f(n, n, n, n);</p>
</li>
<li><p>状态转移方程： 当i==h &amp;&amp; j==k 时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j);</p>
<p>当两者不相同时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j)+ Arr(h, k);</p>
</li>
</ol>
<p>但是其实这里我们可以直接化解成三维的问题， 因为上面我们肯定满足 i+j==h+k, 所以我们可以直接步数+ 第一个人目前行数+ 第二个人目前行数进行解决。</p>
<h3 id="OfferUp-Sumologic-Quantcast-公司投递"><a href="#OfferUp-Sumologic-Quantcast-公司投递" class="headerlink" title="OfferUp. Sumologic, Quantcast 公司投递"></a>OfferUp. Sumologic, Quantcast 公司投递</h3><h3 id="K-Sorted-Array"><a href="#K-Sorted-Array" class="headerlink" title="K Sorted Array"></a>K Sorted Array</h3><p><a href="https://practice.geeksforgeeks.org/problems/k-sorted-array/0" target="_blank" rel="noopener">Link</a></p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>we can use Insertion Sort to sort the elements efficiently. Following is the code for standard Insertion Sort.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(int A[], int size)&#123;</span><br><span class="line">  int i, key, j;</span><br><span class="line">  for(i=1; i&lt;size; i++)&#123;</span><br><span class="line">    key= A[i];</span><br><span class="line">    j= i-1;</span><br><span class="line">    /**Move elements of A[0...i-1], that are greater than position ahead of their current position. This loop will run at most k times**/</span><br><span class="line">    while(j&gt;=0 &amp;&amp; A[j]&gt; key)&#123;</span><br><span class="line">      A[j+1]= A[j];</span><br><span class="line">      j= j-1;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+1]= key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The inner loop will run at most k times. To move every element to its correct place, at most k elements need to be moved, so over all complexity will be O(nk).</p>
<h4 id="Solution2-maintain-a-k-1-size-priorityQueue"><a href="#Solution2-maintain-a-k-1-size-priorityQueue" class="headerlink" title="Solution2: maintain a (k+1) size priorityQueue"></a>Solution2: maintain a (k+1) size priorityQueue</h4><h3 id="Is-this-a-tree"><a href="#Is-this-a-tree" class="headerlink" title="Is this a tree?"></a>Is this a tree?</h3><p>You are given a binary tree as a sequence of parent-child pairs. For example, the tree represented by the node pairs below:</p>
<p>(A, B) (A, C) (B, G) (C, H) (E, F) (B, D) (C, E)</p>
<p>…</p>
<p>This tree can be represented in a S-expression in multiple ways. The lexicographically smallest way of expressing this as follows:</p>
<p>(A(B(D)(G))(C(E(F))(H)))</p>
<p>We need to translate the node-pair representation into an S-expression(lexicographically smallest one), and report any errors that do not conform to the definition of a binary tree.</p>
<p>The list of errors with their codes is as follows:</p>
<ul>
<li>E1: More than 2 children</li>
<li>E2： Duplicate Edges</li>
<li>E3: Cycle present</li>
<li>E4: Multiple roots</li>
<li>E5: Any other error</li>
</ul>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuanRVVDd1aWhLZzQ/view" target="_blank" rel="noopener">link_1</a></p>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuOHVSMF9qMW5IZkk/view" target="_blank" rel="noopener">link_2</a></p>
<p>见下面的validTree我们已经对普通tree的方法进行了解决。</p>
<h3 id="Leetcode-261-Valid-Tree"><a href="#Leetcode-261-Valid-Tree" class="headerlink" title="Leetcode 261. Valid Tree"></a>Leetcode 261. Valid Tree</h3><p>三种做法各做一遍。</p>
<p>见 外部博文， 在graph中如何检测是否有圈存在。</p>
<h3 id="Binary-Search-找距离最近的数字。"><a href="#Binary-Search-找距离最近的数字。" class="headerlink" title="Binary Search 找距离最近的数字。"></a>Binary Search 找距离最近的数字。</h3><p>经典的题目；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    static int[] nums= new int[]&#123;1,2,3,4,5,8,12&#125;;</span><br><span class="line">    public static int getMinDiff(int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;= hi)&#123;</span><br><span class="line">            int mid= lo+(hi-lo)/2;</span><br><span class="line">            if(target&lt;=nums[mid])&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                lo = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;// the number before lo is smaller than target;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int target=10;</span><br><span class="line">        int idx= getMinDiff(target);</span><br><span class="line">        if(idx==0)&#123;</span><br><span class="line">            System.out.println(Math.abs(nums[idx]-target));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Math.min(Math.abs(nums[idx]-target), Math.abs(nums[idx-1]-target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；"><a href="#flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；" class="headerlink" title="flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；"></a>flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；</h3><p>所以如果shallow的话，我们在碰到第一层的时候直接将该层里面的元素输出就好了， 这个时候就能够不用递归或者stack进行解决， 如果是要将所有的都进行flatten的话：</p>
<ol>
<li>递归</li>
<li>Stack， 从后往前进行存储</li>
</ol>
<p>可以借助instance of 来判断遇到的Object 是 Integer or List。</p>
<p>相关问题：</p>
<h4 id="leetcode-341-Flatten-Nested-List-Iterator"><a href="#leetcode-341-Flatten-Nested-List-Iterator" class="headerlink" title="leetcode 341. Flatten Nested List Iterator"></a>leetcode 341. Flatten Nested List Iterator</h4><p>这道题直接利用一个辅助的结构去进行存储就好了， 这里我们选用stack， 每次查看stack最上面的一个元素去进行取next；</p>
<h4 id="leetcode-251-Flatten-2D-vector"><a href="#leetcode-251-Flatten-2D-vector" class="headerlink" title="leetcode 251 Flatten 2D vector"></a>leetcode 251 Flatten 2D vector</h4><p>对于251 这里我们来一个比较具有启发性的答案：</p>
<p>Q:</p>
<p>Implement an iterator to flatten a 2d vector.</p>
<p>For example, Given 2d vector=[[1,2], [3], [4,5,6]];</p>
<p>By calling next repeatedly until hasNext returns false. the order of elements returned by next should be [1,2,3,4,5,6];</p>
<p>Follow up:</p>
<p>As an added challenge, try to code it using only iterators in Java</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Vector2D implements Iterator&lt;Integer&gt;&#123;</span><br><span class="line">  Iterator&lt;List&lt;Integer&gt;&gt; itrs;</span><br><span class="line">  Iterator&lt;Integer&gt; row;</span><br><span class="line">  public Vector 2D(List&lt;List&lt;Integer&gt;&gt; vec2d)&#123;</span><br><span class="line">    if(vec2d==null || vec2d.size()==0) return;</span><br><span class="line">    itrs= vec2d.iterator();</span><br><span class="line">    row= itrs.next().iterator();</span><br><span class="line">    getNextRow();</span><br><span class="line">  &#125;</span><br><span class="line">  private void getNextRow()&#123;</span><br><span class="line">    while(!row.hasNext() &amp;&amp; itrs.hasNext()) row= itrs.next().iterator();</span><br><span class="line">  &#125;</span><br><span class="line">  @ Override</span><br><span class="line">  public Integer next()&#123;</span><br><span class="line">    int next= row.next();</span><br><span class="line">    getNextRow();</span><br><span class="line">    return next;</span><br><span class="line">  &#125;</span><br><span class="line">  @ Override</span><br><span class="line">  public boolean hasNext()&#123;</span><br><span class="line">    return row!=null&amp;&amp; row.hasNext();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class NestedIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        System.out.println(flatten_recurrsive(nestedList));</span><br><span class="line">        for(int i = nestedList.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            stack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">        Stack&lt;NestedInteger&gt; newStack= new Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= nestedList.size()-1; i&gt;=0; i--)&#123;</span><br><span class="line">            newStack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        while(!newStack.isEmpty())&#123;</span><br><span class="line">            if(newStack.peek().isInteger())&#123;</span><br><span class="line">                res.add(newStack.pop().getInteger());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;NestedInteger&gt; curr=newStack.pop().getList();</span><br><span class="line">            for(int i=curr.size()-1; i&gt;=0; i--)&#123;</span><br><span class="line">                newStack.push(curr.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; flatten_recurrsive(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(NestedInteger e: nestedList)&#123;</span><br><span class="line">            if(e.isInteger())&#123;</span><br><span class="line">                res.add(e.getInteger());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.addAll(flatten_recurrsive(e.getList()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer next() &#123;</span><br><span class="line">        return stack.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        while(!stack.isEmpty()) &#123;</span><br><span class="line">            NestedInteger curr = stack.peek();</span><br><span class="line">            if(curr.isInteger()) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">            for(int i = curr.getList().size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                stack.push(curr.getList().get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Leetcode-385-Mini-Parser"><a href="#Leetcode-385-Mini-Parser" class="headerlink" title="Leetcode 385. Mini Parser"></a>Leetcode 385. Mini Parser</h4><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list– whose elements may also be integers or other lists.</p>
<p>很愚蠢并且很容易错的一道题目：</p>
<p>自己写的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public NestedInteger deserialize(String s) &#123;</span><br><span class="line">        // categorized with [  and without [</span><br><span class="line">        if(s.charAt(0)!=&apos;[&apos;)&#123;</span><br><span class="line">            return new NestedInteger(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">        //s= s.substring(1, s.length()-1);</span><br><span class="line">        NestedInteger res= new NestedInteger();</span><br><span class="line">        int index=1;</span><br><span class="line">        while(index&lt;s.length()-1)&#123;</span><br><span class="line">            char ch= s.charAt(index);</span><br><span class="line">            if(ch==&apos;[&apos;)&#123;</span><br><span class="line">                int count=0;</span><br><span class="line">                int start= index;</span><br><span class="line">                while(index&lt;s.length()-1)&#123;</span><br><span class="line">                    if(s.charAt(index)==&apos;[&apos;) count++;</span><br><span class="line">                    if(s.charAt(index)==&apos;]&apos;) count--;</span><br><span class="line">                    index++;</span><br><span class="line">                    if(count==0)&#123;</span><br><span class="line">                        res.add(deserialize(s.substring(start, index)));</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(Character.isDigit(ch) || ch==&apos;-&apos;)&#123;</span><br><span class="line">                int sign=1;</span><br><span class="line">                if(ch==&apos;-&apos;)&#123;</span><br><span class="line">                    sign=-1;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder sb= new StringBuilder();</span><br><span class="line">                while(index&lt;s.length()-1 &amp;&amp; Character.isDigit(s.charAt(index)))&#123;</span><br><span class="line">                    sb.append(s.charAt(index));</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(new NestedInteger(Integer.valueOf(sb.toString())*(sign)));</span><br><span class="line">            &#125;else if(ch==&apos;,&apos;)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别人的想法：</p>
<ol>
<li>If encounters ‘[‘, push current NestedInteger to stack and start a new one.</li>
<li>If encounters ‘]’, end current NestedInteger and pop a NestedInteger from stack to continue;</li>
<li>If encounters ‘,’, append a new number to curr NestedInteger, if this comma is not right after a brackets.</li>
<li>Update index l and r, where I shall point to the start of a integer substring, while r shall points to the end+1 of substring;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public NestedInteger deserialize(String s) &#123;</span><br><span class="line">        if(s.isEmpty()) return null;</span><br><span class="line">        if(s.charAt(0)!=&apos;[&apos;) return new NestedInteger(Integer.valueOf(s));</span><br><span class="line">        Stack&lt;NestedInteger&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        NestedInteger curr= null;</span><br><span class="line">        int l=0;</span><br><span class="line">        for(int r=0; r&lt;s.length(); r++)&#123;</span><br><span class="line">            char ch= s.charAt(r);</span><br><span class="line">            if(ch==&apos;[&apos;)&#123;</span><br><span class="line">                if(curr!= null)&#123;</span><br><span class="line">                    stack.push(curr);</span><br><span class="line">                &#125;</span><br><span class="line">                curr= new NestedInteger();</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;else if(ch==&apos;]&apos;)&#123;</span><br><span class="line">                String num= s.substring(l, r);</span><br><span class="line">                if(!num.isEmpty()) curr.add(new NestedInteger(Integer.valueOf(num)));</span><br><span class="line">                if(!stack.isEmpty())&#123;</span><br><span class="line">                    NestedInteger pop= stack.pop();</span><br><span class="line">                    pop.add(curr);</span><br><span class="line">                    curr= pop;</span><br><span class="line">                &#125;</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;else if(ch==&apos;,&apos;)&#123;</span><br><span class="line">                if(s.charAt(r-1)!= &apos;]&apos;)&#123;</span><br><span class="line">                    String num= s.substring(l, r);</span><br><span class="line">                    curr.add(new NestedInteger(Integer.valueOf(num)));</span><br><span class="line">                &#125;</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Find-the-intersection-of-two-lists"><a href="#Find-the-intersection-of-two-lists" class="headerlink" title="Find the intersection of two lists"></a>Find the intersection of two lists</h3><p>这道题目有两种做法， 第一种找到各条链的长度， 然后使用快慢指针。这里主要是第二种做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    ListNode nodeA= headA;</span><br><span class="line">    ListNode nodeB= headB;</span><br><span class="line">    while(nodeA!= nodeB)&#123;</span><br><span class="line">        nodeA= (nodeA==null)?headB: nodeA.next;</span><br><span class="line">        nodeB= (nodeB==null)?headA: nodeB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodeA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要要注意的一点就是对于null的处理， 如果两者不相交的话，会出现什么情况， 所以这里我们让nodeA和nodeB再取一次null来消除这种情况， 也就是说nodeA==null 的时候， 我们再进行第二次遍历。</p>
<h3 id="Abstract-class-interface-and-threading-issues"><a href="#Abstract-class-interface-and-threading-issues" class="headerlink" title="Abstract class, interface and threading issues."></a>Abstract class, interface and threading issues.</h3><p>concurrent issues.</p>
<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><h3 id="More-about-drawbridge"><a href="#More-about-drawbridge" class="headerlink" title="More about drawbridge"></a>More about drawbridge</h3><p>1st round phone interview: write a function that finds substrings that contains only consecutive repeating characters and return a list of characters that form the substrings. For example, input “thiisiissaa”, returns i i s a, input “thiiissisa” returns i, input “abcde” returns a b c d e.<br>There were three rounds of interview in the 2-hour skype interview that followed the initial phone interview. 1st round, given an unsorted array of integers, sort the array such that the numbers in it form the largest possible number, for example, given [3, 30, 9, 14, 1], the array should be sorted into [9, 3, 30, 14, 1] because 9330141 is the largest number you can form from the numbers in the array. 2nd round, implement a queue using an array. 3rd round, given a list of cities, each city has a population value, write a function that returns a city in the input list. The probability of returning a specific city should be proportional to the population of the city. For example, if the list contains city1 with 15 pop value and city2 with 5 pop value, then if you call the function 4 times, on average it should return city1 for 3 times and city2 once.</p>
<h3 id="Knight’s-travel"><a href="#Knight’s-travel" class="headerlink" title="Knight’s travel"></a>Knight’s travel</h3><h3 id="Leetcode-Frog-Jump"><a href="#Leetcode-Frog-Jump" class="headerlink" title="Leetcode Frog Jump"></a>Leetcode Frog Jump</h3><p>比较straightforward的做法：</p>
<p>利用map记录每个stone上面能跳的jump；</p>
<p>DFS-Version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canCross(int[] stones) &#123;</span><br><span class="line">        if (stones.length == 0) return false;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; stones.length; i++) &#123;</span><br><span class="line">            if (stones[i] - stones[i - 1] &gt; i) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(set, 0, 0, stones[stones.length - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean helper(Set&lt;Integer&gt; set, int step, int currStone, int lastStone) &#123;</span><br><span class="line">        if (currStone == lastStone) return true;</span><br><span class="line">        for (int i = step + 1; i &gt;= Math.max(1, step - 1); i--) &#123;</span><br><span class="line">            if (set.contains(currStone + i) &amp;&amp; helper(set, i, currStone + i, lastStone))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map-Version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canCross(int[] stones) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        map.put(0, new HashSet&lt;Integer&gt;());</span><br><span class="line">        map.get(0).add(1);</span><br><span class="line">        for(int i=0; i&lt;stones.length; i++)&#123;</span><br><span class="line">            if(map.containsKey(stones[i]))&#123;</span><br><span class="line">                for(int step: map.get(stones[i]))&#123;</span><br><span class="line">                    int next= step+ stones[i];</span><br><span class="line">                    if(next== stones[stones.length-1]) return true;</span><br><span class="line">                    if(!map.containsKey(next))&#123;</span><br><span class="line">                        map.put(next, new HashSet&lt;Integer&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.get(next).add(step+1);</span><br><span class="line">                    if(step-1&gt;0) map.get(next).add(step-1);</span><br><span class="line">                    map.get(next).add(step);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jump-Game-I-amp-amp-II"><a href="#Jump-Game-I-amp-amp-II" class="headerlink" title="Jump Game I &amp;&amp; II"></a>Jump Game I &amp;&amp; II</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>Solution:</p>
<p>这道题我们可以用bfs去解决， 每一次跳相当于从上一层跳到下一层， 每次我们遍历完上一层， 下一层的currentMax也就确定了， 直到遍历到尽头， 得到层数， 就是我们要的答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0 || nums.length==1) return 0;</span><br><span class="line">    int currentMax=0;</span><br><span class="line">    int nextMax=0;</span><br><span class="line">    int index=0;</span><br><span class="line">    int level=0;</span><br><span class="line">    while(index&lt;=currentMax)&#123;//  traversal the current </span><br><span class="line">        level++;</span><br><span class="line">        while(index&lt;= currentMax)&#123;</span><br><span class="line">            nextMax= Math.max(nextMax, index+ nums[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        currentMax=nextMax;</span><br><span class="line">        if(currentMax&gt;=nums.length-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] A)&#123;</span><br><span class="line">    // 每次到上一层的尽头， 下一层的尽头也就确定了： e: previous Max, max: current Max;</span><br><span class="line">    int sc=0;</span><br><span class="line">    int e=0;</span><br><span class="line">    int max=0;</span><br><span class="line">    for(int i=0; i&lt;A.length-1; i++)&#123;</span><br><span class="line">        max= Math.max(max, i+ A[i]);</span><br><span class="line">        if(i==e)&#123;</span><br><span class="line">            sc++;</span><br><span class="line">            e= max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>follow-up: how to find the path</p>
<p>解决路径问题的话， 大概就是找到每一层能跳到max的就好了， 找到这样的元素， 我们也就找到了一条路径， 实际上这样的路径应该有很多条（每一层的元素数量相乘）。</p>
<h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a>Verify Preorder Serialization of a Binary Tree</h3><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSerialization(String preorder) &#123;</span><br><span class="line">        String[] nodes= preorder.split(&quot;,&quot;);</span><br><span class="line">        Stack&lt;String&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        for(String node: nodes)&#123;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;) &amp;&amp; node.equals(&quot;#&quot;))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                if(stack.isEmpty()) return false;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.size()==1 &amp;&amp; stack.peek().equals(&quot;#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h3 id="Check-whether-a-given-array-is-a-k-sorted-array-or-not"><a href="#Check-whether-a-given-array-is-a-k-sorted-array-or-not" class="headerlink" title="Check whether a given array is a k sorted array or not."></a>Check whether a given array is a k sorted array or not.</h3><p>Given an array of n distinct elements, Check whether the given array is a k sorted array or not. A k sorted array is an array where each element is at most k distance away from its target position in the sorted array;</p>
<p>For example, let us consider k is 2, an element at index 7 in the sorted array, can be indexes 5, 6, 7, 8,9 in the given array;</p>
<p>这道题目的做法很straight forward， 我们可以直接排序， 然后寻找原来的顺序就好了， 我们着重要讲的是是下面这个问题：</p>
<p>如何在O(n logk)时间内将k sorted array进行排序。</p>
<p>We can sort such arrays more efficiently with the help of Heap data structure.</p>
<ol>
<li>Create a Min Heap of size k+1 with first k+1 elements. This will take O(k) time;</li>
<li>One by one remove min element from heap, put it in the result array, and add a new element to heap from remaining elements.</li>
</ol>
<p>Basically we keep a window of k+1 elements in a minHeap as any element is at most k distance away from the target position. So if an element is the smallest of the group then we extract the element for the window.</p>
<p>The fact： smallest element(first element of sorted out o/p) will always be in first K+1 elements as it can only move k places away from its original position and of course it will be the root element of minheap.</p>
<h3 id="如何计算数据的方差"><a href="#如何计算数据的方差" class="headerlink" title="如何计算数据的方差"></a>如何计算数据的方差</h3><p>有variable A, B, 问A和B的方差是否等于Var(A)+Var(B)<br>如果A, B是独立的就相等，要不不相等</p>
<h3 id="很多数，-找到k个最大的数，-stream操作。"><a href="#很多数，-找到k个最大的数，-stream操作。" class="headerlink" title="很多数， 找到k个最大的数， stream操作。"></a>很多数， 找到k个最大的数， stream操作。</h3><h3 id="很大个文本如何应用mapreduce，-找到anagram"><a href="#很大个文本如何应用mapreduce，-找到anagram" class="headerlink" title="很大个文本如何应用mapreduce， 找到anagram"></a>很大个文本如何应用mapreduce， 找到anagram</h3><h3 id="mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。"><a href="#mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。" class="headerlink" title="mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。"></a>mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。</h3><p>Maybe the data is skew.</p>
<p>reduce执行很慢的一个原因是数据分桶不均导致个别reduce节点的数据量远大于其他节点。 解决方案是检查分桶是否混匀， 如果不均匀考虑使用自定义的Partitioner(使用IntHashPartitioner/MapintPartitioner) 可以根据int前缀/后缀决定分到哪个桶， 如果均匀考虑单个reduce的数据里是否过大， 如果单个reduce的数据量过大则应该考虑增加reduce的量。</p>
<p>哪个key到哪个Reducer的分配过程， 是由Partitioner规定的， 它只有一个办法， 输入的是Map的结果对和reducer的数目， 输出则是分配的Reducer。 就是指定Mapper输出的键值对到哪一个reducer上去， 这样保证如果由相同的key值， 肯定被分配到同一个reducer上。 如果有N个reducer， 编号就是0，1，2，3…(N-1)</p>
<h3 id="public-static-void-main-String-args-为啥要用static。"><a href="#public-static-void-main-String-args-为啥要用static。" class="headerlink" title="public static void main (String[] args) 为啥要用static。"></a>public static void main (String[] args) 为啥要用static。</h3><p>正因为main 方法是静态的， JVM调用这个方法就不需要创建任何包含这个main方法的实例。如果JVM就没法确定调用哪个main方法。</p>
<p>静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的， 那么它就会被加载到JVM上下文成为可执行的方法。</p>
<p>如果JVM找不到main方法就会抛出 NoSuchMethodError：main异常。</p>
<p>main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</p>
<h3 id="如果不用static-是否能够通过？"><a href="#如果不用static-是否能够通过？" class="headerlink" title="如果不用static 是否能够通过？"></a>如果不用static 是否能够通过？</h3><p>编译能过， 但是不能运行。</p>
<h3 id="最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。"><a href="#最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。" class="headerlink" title="最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。"></a>最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            int idx= binarySearch(list, nums[i]);</span><br><span class="line">            if(idx&lt;list.size())&#123;</span><br><span class="line">                list.set(idx, nums[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    public int binarySearch(List&lt;Integer&gt; nums, int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= nums.size()-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi)/2;</span><br><span class="line">            if(nums.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java-heap和stack都分别存什么"><a href="#Java-heap和stack都分别存什么" class="headerlink" title="Java heap和stack都分别存什么"></a>Java heap和stack都分别存什么</h3><p><a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java Heap Space vs Stack- Memory Allocation in Java</a></p>
<h4 id="Java-Heap-Space"><a href="#Java-Heap-Space" class="headerlink" title="Java Heap Space"></a>Java Heap Space</h4><ol>
<li>Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.</li>
<li>Garbage Collection runs on the heap memory to free the memory used by objects that doesn’t have any reference. Any object created in the heap has global access and can be referenced from anywhere of the application.</li>
</ol>
<h4 id="Java-Stack-Memory"><a href="#Java-Stack-Memory" class="headerlink" title="Java Stack Memory"></a>Java Stack Memory</h4><ol>
<li>Java Stack memory is used for execution of a thread. They contain method specific values that are short lived and references to other objects in the heap that are getting referred from the method.</li>
<li>Stack memory is always referenced in LIFO order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.</li>
<li>As soon as method ends, the block becomes unused and become available for next method.</li>
<li>Stack memory size is very less compared to Heap memory.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.test;</span><br><span class="line"></span><br><span class="line">public class Memory &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123; // Line 1</span><br><span class="line">		int i=1; // Line 2</span><br><span class="line">		Object obj = new Object(); // Line 3</span><br><span class="line">		Memory mem = new Memory(); // Line 4</span><br><span class="line">		mem.foo(obj); // Line 5</span><br><span class="line">	&#125; // Line 9</span><br><span class="line"></span><br><span class="line">	private void foo(Object param) &#123; // Line 6</span><br><span class="line">		String str = param.toString(); //// Line 7</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125; // Line 8</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Below image shows the stack and heap memory with reference to above program and how they are being used to store primitive, Objects and reference variables.</p>
<p><a href="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png" alt="img"></a></p>
<p>Let’s go through the steps of execution of the program.</p>
<ul>
<li>As soon as we run the program, it loads all the Runtime classes into the Heap space. When main() method is found at line 1, Java Runtime creates stack memory to be used by main() method thread.</li>
<li>We are creating primitive local variable at line 2, so it’s created and stored in the stack memory of main() method.</li>
<li>Since we are creating an Object in line 3, it’s created in Heap memory and stack memory contains the reference for it. Similar process occurs when we create Memory object in line 4.</li>
<li>Now when we call foo() method in line 5, a block in the top of the stack is created to be used by foo() method. Since Java is pass by value, a new reference to Object is created in the foo() stack block in line 6.</li>
<li>A string is created in line 7, it goes in the <a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">String Pool</a> in the heap space and a reference is created in the foo() stack space for it.</li>
<li>foo() method is terminated in line 8, at this time memory block allocated for foo() in stack becomes free.</li>
<li>In line 9, main() method terminates and the stack memory created for main() method is destroyed. Also the program ends at this line, hence Java Runtime frees all the memory and end the execution of the program.</li>
</ul>
<h3 id="Difference-between-Java-Heap-Space-and-Stack-Memory"><a href="#Difference-between-Java-Heap-Space-and-Stack-Memory" class="headerlink" title="Difference between Java Heap Space and Stack Memory"></a>Difference between Java Heap Space and Stack Memory</h3><p>Based on the above explanations, we can easily conclude following differences between Heap and Stack memory.</p>
<ol>
<li>Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.</li>
<li>Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.</li>
<li>Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.</li>
<li>Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at <a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">Java Garbage Collection</a>.</li>
<li>Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.</li>
<li>We can use <strong>-Xms</strong> and <strong>-Xmx</strong> JVM option to define the startup size and maximum size of heap memory. We can use <strong>-Xss</strong> to define the stack memory size.</li>
<li>When stack memory is full, Java runtime throws <code>java.lang.StackOverFlowError</code> whereas if heap memory is full, it throws <code>java.lang.OutOfMemoryError: Java Heap Space</code> error.</li>
<li>Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.</li>
</ol>
<p>That’s all for <strong>Java Heap Space vs Stack Memory</strong> in terms of java application, I hope it will clear your doubts regarding memory allocation when any java program is executed.</p>
<p>Static methods(in fact all methods) as well as static variables are stored in the PermGen section of the heap, since they are part of the reflection data(class related data, not instance related).</p>
<p>Note that only the variables and their technical values(primitives and references) are stored in PermGen space.</p>
<p>If your static variable is a reference to an object that object itself is stored in the normal sections of the heap. Those objects(unless they are internal objects like classes etc.) are not stored in PermGen space.</p>
<h3 id="SQL有几种join，-join的内部实现，-sql-index内部实现。"><a href="#SQL有几种join，-join的内部实现，-sql-index内部实现。" class="headerlink" title="SQL有几种join， join的内部实现， sql index内部实现。"></a>SQL有几种join， join的内部实现， sql index内部实现。</h3><p>SQL有inner join， left join， right join, full outer join 各种join</p>
<p>Or natural join and theta join;</p>
<p>总的来说， 四种JOIN的使用/区别可以描述为：</p>
<ol>
<li>left join 会从左表那里返回所有的记录， 即使在右表中没有匹配的行。</li>
<li>right outer join右连接， 返回右表中的所有记录， 即使在做表中没有记录与它匹配。</li>
<li>full outer join 全连接， 返回左右表中的所有记录。</li>
<li>在表中存在至少一个匹配时， inner join返回行。 关键字inner 可省略。</li>
</ol>
<p>join 的内部实现(重要的技巧: external sort)：</p>
<ol>
<li><p>Three primary techniques:</p>
<p>Sorting， Hashing， Indexing；</p>
</li>
<li><p>Three degrees of difficulty:</p>
<p>data small enough to fit in memory</p>
<p>too large to fit in main memory but small enough to be handled by a two-pass algorithm</p>
</li>
</ol>
<p>Iteration Join: conceptually- without taking into account disk block issues.</p>
<p>Merge join: Sort the two table and using merge sort;</p>
<p>Join with index: Using index;</p>
<p>Hash join: hash R1 tuples into G buckets, hash R2 tuples into H buckets and match every bucket;</p>
<h3 id="What’s-the-difference-between-B-Tree-and-B-Tree"><a href="#What’s-the-difference-between-B-Tree-and-B-Tree" class="headerlink" title="What’s the difference between B Tree and B+ Tree."></a>What’s the difference between B Tree and B+ Tree.</h3><p>In a b- tree you can store both keys and data in the internal and leaf nodes, but in a b+ tree you have to store the data in the leaf nodes only;</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys(not pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<p>Advantages of B+ trees:</p>
<ul>
<li>Because B+ tree don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.</li>
<li>The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.</li>
</ul>
<p>Advantage of B trees:</p>
<ul>
<li>Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.</li>
</ul>
<p><a href="https://i.stack.imgur.com/l6UyF.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/l6UyF.png" alt="B and B+ tree"></a></p>
<p>The principal advantage of B+ trees over B trees is they allow you to pack in more pointers to other nodes by removing pointers to data, thus increasing the fanout and potentially decreasing the depth of the tree.The disadvantage is that there are no early outs when you might have found a match in an internal node. But since both data structures have huge fanouts, the vast majority of your matches will be on leaf nodes anyway, making on average the B+ tree more efficient.</p>
<h3 id="Overfitting-如何处理"><a href="#Overfitting-如何处理" class="headerlink" title="Overfitting 如何处理"></a>Overfitting 如何处理</h3><p>Overfitting is that your model get good result on your training data, but can not generalize to the usual data set.</p>
<p>过度拟合的模型往往不能进行一般化推广。</p>
<ol>
<li>Cross Validation</li>
<li>Train with more data</li>
<li>Remove features.</li>
<li>Early Stopping</li>
<li>Regularization</li>
</ol>
<h3 id="count-min-sketch-数据结构"><a href="#count-min-sketch-数据结构" class="headerlink" title="count-min-sketch 数据结构"></a>count-min-sketch 数据结构</h3><p>Ref: 系统设计</p>
<p>主要的意思就是使用 bloom fliter来记录每个元素出现的频率， 然后以频率来代替次数。</p>
<h3 id="A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。"><a href="#A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。" class="headerlink" title="A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。"></a>A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。</h3><p>一个auction无限轮，A，B，C参加bid，一个operator宣布结果，赢者付其他竞价中的最高值（即第二高bid），但是operator可以作假报高价，BC want to get high profit, 给出A可以用什么策略发现A作假</p>
<h3 id="cc-150上-4-8-subtree那道题"><a href="#cc-150上-4-8-subtree那道题" class="headerlink" title="cc 150上 4.8 subtree那道题"></a>cc 150上 4.8 subtree那道题</h3><p>You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to that value. note that it can be any path in the tree– it does not have to start at the root.</p>
<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>Lets’s approach this problem by simplifying it. What if the path had to start at the root?</p>
<p>对于这道题， 其实我们可以采用 leetcode 437的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        map.put(0, 1);</span><br><span class="line">        backTrack(root, sum, map, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTrack(TreeNode root, int target, Map&lt;Integer, Integer&gt; map, int sum)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        if(map.containsKey(sum-target))&#123;</span><br><span class="line">            res+=map.get(sum-target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(sum, map.getOrDefault(sum, 0)+1);</span><br><span class="line">        backTrack(root.left, target, map, sum);</span><br><span class="line">        backTrack(root.right, target, map, sum);</span><br><span class="line">        map.put(sum, map.get(sum)-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        findSum(root, sum, new ArrayList&lt;&gt;(), 0);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        pathSum(root, sum, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void pathSum(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        findPath(root, sum,0, new ArrayList&lt;&gt;(), res);</span><br><span class="line">        pathSum(root.left, sum, res);</span><br><span class="line">        pathSum(root.right, sum, res);</span><br><span class="line">    &#125;</span><br><span class="line">    // if the path was not restricted to the from root to leaf;</span><br><span class="line">    public void findPath(TreeNode root, int target, int sum,  List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        if(sum== target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        findPath(root.left, target, sum, path, res);</span><br><span class="line">        findPath(root.right, target, sum, path, res);</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    // what if we just want to print the path;</span><br><span class="line">    public void findSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; unit, int level)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        int tmp= sum;</span><br><span class="line">        unit.add(root.val);</span><br><span class="line">        for(int i=level; i&gt;-1; i--)&#123;</span><br><span class="line">            tmp-= unit.get(i);</span><br><span class="line">            if(tmp==0) print(unit, i, level);</span><br><span class="line">        &#125;</span><br><span class="line">        findSum(root.left, sum, unit, level+1);</span><br><span class="line">        findSum(root.right, sum, unit, level+1);</span><br><span class="line">        unit.remove(unit.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    void print(ArrayList&lt;Integer&gt; buffer, int level, int i2)&#123;</span><br><span class="line">        for(int i= level; i&lt;= i2; i++)&#123;</span><br><span class="line">            System.out.print(buffer.get(i)+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode：-Largest-Number"><a href="#Leetcode：-Largest-Number" class="headerlink" title="Leetcode： Largest Number"></a>Leetcode： Largest Number</h3><p>这道题目只需要实现一个Comparator就可以了。</p>
<h3 id="SQL刷题。"><a href="#SQL刷题。" class="headerlink" title="SQL刷题。"></a>SQL刷题。</h3><h3 id="Move-zeros"><a href="#Move-zeros" class="headerlink" title="Move zeros"></a>Move zeros</h3><p>input: [0,2,0,-3,5,7,9,0,7,0]<br>output: [2,-3,5,7,9,7,0,0,0,0]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int index=0;</span><br><span class="line">        while(index&lt; nums.length)&#123;</span><br><span class="line">            if(nums[index]!=0)&#123;</span><br><span class="line">                swap(nums, index, start);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int temp= nums[i];</span><br><span class="line">        nums[i]= nums[j];</span><br><span class="line">        nums[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones"><a href="#From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones" class="headerlink" title="From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones."></a>From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones.</h3><p>Test Input: [4, 8], [3, 5], [-1 2], [10, 12]</p>
<p>Test output: [-1, 8], [10,12]</p>
<p>Merge Intervals;</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>三个table, salesman， customer，orders</p>
<p>a. The names of all sales people that have an order with Panasung(one customer’s name).</p>
<p>b. The names of salespeople that have 2 or more orders.</p>
<p>Select salespeople.name from orders group by name having count(*)&gt;=2</p>
<h3 id="strstr变形"><a href="#strstr变形" class="headerlink" title="strstr变形"></a>strstr变形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle)&#123;</span><br><span class="line">  if(needle.length()==0) return 0;</span><br><span class="line">  if(haystack.length()==0) reuturn -1;</span><br><span class="line">  int index=0;</span><br><span class="line">  while(index+needle.length()&lt;= haystack.length())&#123;</span><br><span class="line">    int i= index;</span><br><span class="line">    int j=0;</span><br><span class="line">    while(haystack.charAt(i)== needle.charAt(j))&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">      if(j== needle.length()) return index;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="merge-two-BST"><a href="#merge-two-BST" class="headerlink" title="merge two BST"></a>merge two BST</h3><h3 id="group-anagram"><a href="#group-anagram" class="headerlink" title="group anagram"></a>group anagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(String str: strs)&#123;</span><br><span class="line">            String s= hashStr(str);</span><br><span class="line">            if(!map.containsKey(s))&#123;</span><br><span class="line">                map.put(s, new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        for(List&lt;String&gt; list: map.values())&#123;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public String hashStr(String str)&#123;</span><br><span class="line">        char[] ch=str.toCharArray();</span><br><span class="line">        Arrays.sort(ch);</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        for(char c: ch)&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级"><a href="#给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级" class="headerlink" title="给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级"></a>给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级</h3><p>感觉可能要使用和之前质数一样的方式去进行计算。</p>
<p>Maybe we should use the inclusion-exclusion principle to calculate;</p>
<h3 id="two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？"><a href="#two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？" class="headerlink" title="two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？"></a>two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？</h3><ol>
<li>maybe we ignore some feature, since there may be some feature in A, and no such feature in B, and the model is based on the existence of feature.</li>
<li>Shuffle the dataset A and B. and check if it is still the case.</li>
</ol>
<h3 id="use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego"><a href="#use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego" class="headerlink" title="use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]"></a>use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class subsetCheck &#123;</span><br><span class="line">    public static List&lt;String&gt; getList(Set&lt;String&gt; dict, String s)&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(String word: dict)&#123;</span><br><span class="line">            if(check(word, map))&#123;</span><br><span class="line">                res.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean check(String s, Map&lt;Character, Integer&gt; map)&#123;</span><br><span class="line">        boolean flag= true;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)-1);</span><br><span class="line">            if(map.get(s.charAt(i))&lt;0) flag= false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        HashSet&lt;String&gt; dict= new HashSet&lt;&gt;();</span><br><span class="line">        dict.add(&quot;go&quot;);</span><br><span class="line">        dict.add(&quot;ego&quot;);</span><br><span class="line">        dict.add(&quot;gap&quot;);</span><br><span class="line">        dict.add(&quot;dog&quot;);</span><br><span class="line">        String word=&quot;ogeg&quot;;</span><br><span class="line">        System.out.println(getList(dict, word));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash-IP-address"><a href="#hash-IP-address" class="headerlink" title="hash IP address"></a>hash IP address</h3><p>input String=&gt; long int</p>
<p>String: 123.39.255.0</p>
<h3 id="Partition-Array"><a href="#Partition-Array" class="headerlink" title="Partition Array"></a>Partition Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class kthLargest &#123;</span><br><span class="line">    public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= partition(nums, lo, hi);</span><br><span class="line">            if(mid&lt;k)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(mid==k) return nums[mid];</span><br><span class="line">            else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key= nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;=key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j] &gt;=key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int temp= nums[i];</span><br><span class="line">        nums[i]= nums[j];</span><br><span class="line">        nums[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] nums=new int[]&#123;3,2,1,5,6,4&#125;;</span><br><span class="line">        for(int i=1; i&lt;=nums.length; i++)&#123;</span><br><span class="line">            System.out.println(findKthLargest(nums,i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-721-Accounts-Merge"><a href="#Leetcode-721-Accounts-Merge" class="headerlink" title="Leetcode 721. Accounts Merge"></a>Leetcode 721. Accounts Merge</h3><p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code>is a <em>name</em>, and the rest of the elements are <em>emails</em> representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in any order.</p>
<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>这道题目比较骚， 我们可以把他转换成一道graph的题目。具体来说，题目相当于给定了一个group，然后我们需要把这些小的group来merge成一个比较大的group。</p>
<p>可以用union find 或者dfs来做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; accountMerge(List&lt;List&lt;String&gt;&gt; acts)&#123;</span><br><span class="line">  Map&lt;String, String&gt; root= new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;String, String&gt; owner= new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;String, TreeSet&lt;String&gt;&gt; components= new HashMap&lt;&gt;();</span><br><span class="line">  // here is just initialization</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    for(int i=1; i&lt;a.size(); i++)&#123;</span><br><span class="line">      root.put(a.get(i), a.get(i));</span><br><span class="line">      owner.put(a.get(i), a.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // here we just union all the node connected;</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    String root_p= find(a.get(1), root);</span><br><span class="line">    for(int i=2; i&lt;a.size(); i++)&#123;</span><br><span class="line">      root.put(find(a.get(i), root), root_p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // here we get the group of node;</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    String root_p= find(a.get(1), root);</span><br><span class="line">    if(!components.containsKey(root_p)) components.put(root_p, new TreeSet&lt;&gt;());</span><br><span class="line">    for(int i=1; i&lt;a.size(); i++)&#123;</span><br><span class="line">    	components.get(root_p).add(a.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // find Res and return</span><br><span class="line">  List&lt;List&lt;String&gt;&gt; res= new Arrayist&lt;&gt;();</span><br><span class="line">  for(String key: components.keySet())&#123;</span><br><span class="line">    List&lt;String&gt; e= new ArrayList&lt;&gt;(components.get(key));</span><br><span class="line">    e.add(0, owner.get(key));</span><br><span class="line">    res.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">private String find(String key, Map&lt;String, String&gt; root)&#123;</span><br><span class="line">  while(key!= root.get(key))&#123;</span><br><span class="line">    root.put(key, root.get(key));</span><br><span class="line">    key= root.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="海量数据如何去重"><a href="#海量数据如何去重" class="headerlink" title="海量数据如何去重"></a>海量数据如何去重</h3><p>Just using mapreduce to sort.</p>
<p>现在有2T的数据， 其中有重复， 我们需要去除这些重复的值， 内存只有1G， 我们应该怎么做？</p>
<ol>
<li>文件分块， 每次读入1G的文件， 将这些文件进行hash， 进行排序（Treeset）， 并进行初步的去重(Set的特殊性);</li>
<li>在完成第一步之后， 我们得到若干份有序的文件堆。在每个堆之中取第一个文件， 进行merge。</li>
</ol>
<p>剩下的就很好理解了。</p>
<p>有两种方式， 第一种就是上面说的：</p>
<ol>
<li>split and sort, then merge;</li>
<li>如果只需要去重， 不需要排序， 还有另外一种思路，对文件的每一行计算hash值， 按照hash值把该行内容放在某个小文件中， 假设需要分词100个文件， 则可以按照(hash%100)来分发文件内容， 然后再小文件中进行去重就可以了。</li>
</ol>
<h3 id="Find-K-th-Smallest-Pair-Distance"><a href="#Find-K-th-Smallest-Pair-Distance" class="headerlink" title="Find K-th Smallest Pair Distance"></a>Find K-th Smallest Pair Distance</h3><p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<p>Naive Method is to find all the n*(n-1)/2 possible absolute differences in O(n^2) and store them in an array. Then sort this array and print the kth minimum value from this array.</p>
<p>An Efficient Solution is based on Binary Search.</p>
<ul>
<li><p>Sort the given array a[].</p>
</li>
<li><p>We can easily find the least possible absolute difference in O(n) after sorting. The largest possible difference will be a[n-1]-a[0] after sorting the array. Let low= minimum_difference and high= maximum_difference.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while low&lt; high:</span><br><span class="line">	mid=(low+ high)/2;</span><br><span class="line">	if((number of pairs with absolute difference&lt;=mid)&lt; k):</span><br><span class="line">		low= mid+1</span><br><span class="line">	else:</span><br><span class="line">		high= mid</span><br><span class="line">return low</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/算法(一)/" data-id="cjd8dst5e000xauzhaweixooj" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java，-Algorithm/">Java， Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/算法(二)/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/算法(二)/">算法(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-Part-2"><a href="#Algorithm-Part-2" class="headerlink" title="Algorithm Part 2"></a>Algorithm Part 2</h1><p>** 2018-01-02</p>
<h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root==p || root==q || root==null) return root;</span><br><span class="line">        TreeNode left= lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right= lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left!=null &amp;&amp; right!=null ) return root;</span><br><span class="line">        if(left==null) return right;</span><br><span class="line">        if(right==null) return left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        int min=Math.min(p.val, q.val);</span><br><span class="line">        int max=Math.max(p.val, q.val);</span><br><span class="line">        if(root.val&lt;min)  return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(root.val&gt;max)  return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if(x==0) return 0;</span><br><span class="line">        if(x&lt;=3) return 1;</span><br><span class="line">        int lo=2;</span><br><span class="line">        int hi=x/2;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+ (hi-lo)/2;</span><br><span class="line">            if(mid&lt; x/mid)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(mid== x/mid) return mid;</span><br><span class="line">            else hi= mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Left Table: Transaction Table</span><br><span class="line">Left Mapper: </span><br><span class="line">the transaction map() reads(transaction_id, product_id, user_id, quantity, amout) and emits a key-value pair composed of (user_id, product_id);</span><br><span class="line"></span><br><span class="line">Right Table: User Table</span><br><span class="line">Right Mapper:</span><br><span class="line">the user map() reads(user_id, location_id) and emits a key-value pair composed of (user_id, location_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Transaction mapper</span><br><span class="line">map(key value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String productID=tokens[1];</span><br><span class="line">  String userID= tokens[2];</span><br><span class="line">  outputKey= Pair(userID, 2);</span><br><span class="line">  outputValue= Pair(&quot;P&quot;, productID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// User mapper</span><br><span class="line">map(key, value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String userID= tokens[0];</span><br><span class="line">  String locationID= tokens[1];</span><br><span class="line">  outputKey= Pair(userID, 1);// make sure location shows before produ</span><br><span class="line">  outputValue=Pair(&quot;L&quot;, locationID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// values=List&lt;&gt;&#123;</span><br><span class="line">  Pair&lt;&quot;L&quot;, locationID&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID1&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID2&gt;,</span><br><span class="line">&#125;</span><br><span class="line">reduce(key, values)&#123;</span><br><span class="line">  locationID=&quot;undefined&quot;;</span><br><span class="line">  for(Pair&lt;left, right&gt; value: values)&#123;</span><br><span class="line">    if(value.left.equals(&quot;L&quot;))&#123;</span><br><span class="line">      locationID= value.right;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    productID= value.right;</span><br><span class="line">    emit(productID, locationID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的意思就是要设置label。</p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash.</li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int num: nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int num: nums2)&#123;</span><br><span class="line">            if(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)-1);</span><br><span class="line">                if(map.get(num)==0)&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125; </span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr= new int[res.size()];</span><br><span class="line">        for(int i=0; i&lt;res.size(); i++)&#123;</span><br><span class="line">            arr[i]= res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static double closestToT(double[] x, double t)&#123;</span><br><span class="line">    double prefix=0;</span><br><span class="line">  TreeSet&lt;Double&gt; set= new TreeSet&lt;&gt;();</span><br><span class="line">  set.add(prefix);</span><br><span class="line">  double leastDiff= Double.MAX_VALUE;</span><br><span class="line">  for(double i: x)&#123;</span><br><span class="line">      prefix+=i;</span><br><span class="line">    double rest= prefix-t;</span><br><span class="line">    // the next step is binary search, we can coporate the tree set api into it to solve this.</span><br><span class="line">    if(set.first()&lt;= rest)&#123;</span><br><span class="line">        double theSum= prefix- set.floor(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">    if(set.last()&gt; last)&#123;</span><br><span class="line">        double theSum= prefix- set.ceiling(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set.add(prefix);</span><br><span class="line">&#125;</span><br><span class="line">return leastDiff;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(int[] nums)&#123;</span><br><span class="line">    int ifRobbedPrevious= 0;</span><br><span class="line">  	int ifDidntRobPrevious=0;</span><br><span class="line">  	for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        int currRobbed= ifDidntRobPrevious+nums[i];</span><br><span class="line">      int currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);</span><br><span class="line">      </span><br><span class="line">      ifDidntRobPrevious= currNotRobbed;</span><br><span class="line">      ifRobbedPrevious= currRobbed;</span><br><span class="line">    &#125;</span><br><span class="line">  return Math.max(ifRobbedPrevious, ifDidntRobPrevious);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[][] direction= new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    public int longestIncreasingPath(int[][] matrix) &#123;</span><br><span class="line">        if(matrix.length==0 || matrix[0].length==0) return 0;</span><br><span class="line">        int[][] len= new int[matrix.length][matrix[0].length];</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int i=0; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;matrix[0].length; j++)&#123;</span><br><span class="line">                if(len[i][j]==0) dfs(i, j, len, matrix);</span><br><span class="line">                res= Math.max(res, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfs(int x, int y, int[][] len, int[][] matrix)&#123;</span><br><span class="line">        if(len[x][y]!=0) return len[x][y];</span><br><span class="line">        len[x][y]=1;</span><br><span class="line">        for(int i=0; i&lt;direction.length; i++)&#123;</span><br><span class="line">            int newX= x+ direction[i][0];</span><br><span class="line">            int newY= y+ direction[i][1];</span><br><span class="line">            if(newX&gt;=0 &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=0 &amp;&amp; newY&lt;matrix[0].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y])&#123;</span><br><span class="line">                len[x][y]= Math.max(len[x][y], 1+ dfs(newX, newY, len, matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param n: an integer</span><br><span class="line">     * @return: a boolean which equals to true if the first player will win</span><br><span class="line">     */</span><br><span class="line">    public boolean firstWillWin(int n) &#123;</span><br><span class="line">        if (n % 3 == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values) &#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    if(values.length==0) return false;</span><br><span class="line">    if(values.length&lt;3) return true;</span><br><span class="line">    // so here we are get to take number from left, so what happens h</span><br><span class="line">    // dp[i] means the max value we can get from i~end;</span><br><span class="line">    </span><br><span class="line">    // choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);</span><br><span class="line">    // choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);</span><br><span class="line">    int[] dp=new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        dp[i]=Math.max(values[i]+ Math.min((i+2&lt;dp.length?dp[i+2]:0),(i+3&lt;dp.length?dp[i+3]:0)), values[i]+ (i+1&lt;values.length? values[i+1]: 0)+ Math.min((i+3&lt;dp.length?dp[i+3]:0), (i+4&lt;dp.length?dp[i+4]:0)));</span><br><span class="line">    &#125;</span><br><span class="line">    //print(dp);</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int num: values)&#123;</span><br><span class="line">        sum+= num;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0]&gt;sum- dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values)&#123;</span><br><span class="line">    // dp[i]= sum[i]-max(dp[i-1], dp[i-2]);</span><br><span class="line">    int[] sum= new int[values.length];</span><br><span class="line">    int[] dp= new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        sum[i]= (i+1&lt;values.length?sum[i+1]:0)+values[i];</span><br><span class="line">        dp[i]= sum[i]- Math.min((i+1&lt;dp.length?dp[i+1]:0), (i+2&lt;dp.length?dp[i+2]:0));</span><br><span class="line">        //System.out.println(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum[0]-dp[0]&lt;dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Merge second and third piles =&gt; [4, 2, 4], score +2</span><br><span class="line">2. Merge the first two piles =&gt; [6, 4]，score +6</span><br><span class="line">3. Merge the last two piles =&gt; [10], score +10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class stonegame &#123;</span><br><span class="line">    public static int getMaxScore(int[] nums)&#123;</span><br><span class="line">        int[][] dp= new int[nums.length][nums.length];</span><br><span class="line">        //int[][] sum= new int[nums.length][nums.length];</span><br><span class="line">        int[] sum= new int[nums.length];</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum[i]= (i&gt;0?sum[i-1]:0)+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int len=1; len&lt;=nums.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len-1&lt;nums.length; i++)&#123;</span><br><span class="line">                int left= i;</span><br><span class="line">                int right= i+len-1;</span><br><span class="line">                if(left!=right)</span><br><span class="line">                    dp[left][right]=Integer.MAX_VALUE;</span><br><span class="line">                for(int mid= left; mid&lt;right; mid++)&#123;</span><br><span class="line">                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+1][right]+sum[right]-(left&gt;0?sum[left-1]:0), dp[left][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] nums= new int[]&#123;4,4,5,9&#125;;</span><br><span class="line">        System.out.println(getMaxScore(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h3><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class minAdjustCost &#123;</span><br><span class="line">    /**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个</span><br><span class="line">     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价</span><br><span class="line">     * 之和最小是多少。**/</span><br><span class="line">    public int MinAdjustmentCost(ArrayList&lt;Integer&gt;A, int target)&#123;</span><br><span class="line">        int n= A.size();</span><br><span class="line">        int[][] f= new int[n+1][101];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;</span><br><span class="line">            f[0][i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;=100; j++)&#123;</span><br><span class="line">                if(f[i-1][j]!= Integer.MAX_VALUE)&#123;// if the previous is restricted to the condition;</span><br><span class="line">                    for(int k=0; k&lt;=100; k++)&#123;</span><br><span class="line">                        if(Math.abs(j-k)&lt;= target)&#123;</span><br><span class="line">                            if(f[i][k]&gt; f[i-1][j]+Math.abs(A.get(i-1)-k))</span><br><span class="line">                                f[i][k] = f[i-1][j] + Math.abs(A.get(i-1)-k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt;= 100; ++i)</span><br><span class="line">            if (f[n][i] &lt; ans)</span><br><span class="line">                ans = f[n][i];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int nthUglyNumber(int n) &#123;</span><br><span class="line">        int[] dp= new int[n];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        int index_2= 0;</span><br><span class="line">        int index_3= 0;</span><br><span class="line">        int index_5= 0;</span><br><span class="line">        // we say it&apos;s a merge process;</span><br><span class="line">        for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">            int candidate_2=2* dp[index_2];</span><br><span class="line">            int candidate_3=3* dp[index_3];</span><br><span class="line">            int candidate_5=5* dp[index_5];</span><br><span class="line">            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);</span><br><span class="line">            if(dp[i]== candidate_2) index_2++;</span><br><span class="line">            if(dp[i]== candidate_3) index_3++;</span><br><span class="line">            if(dp[i]== candidate_5) index_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param root: param root: The root of the binary search tree</span><br><span class="line">     * @param k1: An integer</span><br><span class="line">     * @param k2: An integer</span><br><span class="line">     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span><br><span class="line">     */</span><br><span class="line">    // public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">    //     // write your code here</span><br><span class="line">    //     if(root==null) return new ArrayList&lt;&gt;();</span><br><span class="line">    //     if(k2&lt;root.val) return searchRange(root.left, k1, k2);</span><br><span class="line">    //     if(k1&gt;root.val) return searchRange(root.right,k1, k2);</span><br><span class="line">    //     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">    //     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);</span><br><span class="line">    //     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);</span><br><span class="line">    //     res.addAll(left);</span><br><span class="line">    //     res.add(root.val);</span><br><span class="line">    //     res.addAll(right);</span><br><span class="line">    //     return res;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, k1, k2, result);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void helper(TreeNode root, int k1, int k2, ArrayList&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line"></span><br><span class="line">        // in-order binary tree iteration</span><br><span class="line">        helper(root.left, k1, k2, result);</span><br><span class="line">        if (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k1, k2, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; majorityElement(int[] nums)&#123;</span><br><span class="line">    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  if(nums.length==0) return res;</span><br><span class="line">  int candidate_1= nums[0];</span><br><span class="line">  int candidate_2= nums[0];</span><br><span class="line">  int count_1=0;</span><br><span class="line">  int count_2=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">	if(nums[i]==candidate_1)&#123;</span><br><span class="line">        count_1++;</span><br><span class="line">    &#125;else if(nums[i]== candidate_2)&#123;</span><br><span class="line">        count_2++;</span><br><span class="line">    &#125;else if(count_1==0)&#123;</span><br><span class="line">        count_1=1;</span><br><span class="line">      	candidate_1=nums[i];</span><br><span class="line">    &#125;else if(count_2==0)&#123;</span><br><span class="line">        count_2=1;</span><br><span class="line">      	candidate_2= nums[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        count_1--;</span><br><span class="line">      	count_2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count_1=0;</span><br><span class="line">  count_2=0;</span><br><span class="line">  for(int num: nums)&#123;</span><br><span class="line">      if(num==candidate_1) count_1++;</span><br><span class="line">    else if(num==candidate_2) count_2++;</span><br><span class="line">  &#125;</span><br><span class="line">  if(count_1&gt; nums.length/3) res.add(candidate_1);</span><br><span class="line">  if(count_2&gt; nums.length/3)</span><br><span class="line">    res.add(candidate_2);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices)&#123;</span><br><span class="line">    int firstBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int firstSell=0;</span><br><span class="line">  	int secondBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int secondSell= 0;</span><br><span class="line">  	for(int price: prices)&#123;</span><br><span class="line">        secondSell= Math.max(secondBuy+price, secondSell);</span><br><span class="line">      	secondBuy= Math.max(firstSell- price, secondBuy);</span><br><span class="line">      	firstSell= Math.max(firstBuy+price, firstSell);</span><br><span class="line">      	firstBuy= Math.max(firstBuy, -price);</span><br><span class="line">    &#125;</span><br><span class="line">  return secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // state 1: after buy;</span><br><span class="line">        // state 2: after sell;</span><br><span class="line">        // buy[i] means until day i, the last action is buy, the max profit;</span><br><span class="line">        // buy[i]=sell[i-2]-price[i];</span><br><span class="line">        // sell[i] means until day j, the last action is sell, the max profit;</span><br><span class="line">        // sell[i]=buy[i-1]+ price[i];</span><br><span class="line">        if(prices.length==0) return 0;</span><br><span class="line">        int[] buy= new int[prices.length];</span><br><span class="line">        int[] sell= new int[prices.length];</span><br><span class="line">        buy[0]= -prices[0];</span><br><span class="line">        for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">            buy[i]= Math.max(buy[i-1], (i&gt;=2?sell[i-2]:0)-prices[i]);</span><br><span class="line">            sell[i]= Math.max(sell[i-1], buy[i-1]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell[prices.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices, int fee)&#123;</span><br><span class="line">    int[] buy= new int[prices.length];</span><br><span class="line">  	int[] sell= new int[prices.length];</span><br><span class="line">  	buy[0]= -prices[0];</span><br><span class="line">  	sell[0]= 0;</span><br><span class="line">  	for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">        buy[i]= Math.max(sell[i-1]-prices[i], buy[i-1]);</span><br><span class="line">      	sell[i]= Math.max(buy[i-1]+prices[i]- fee, sell[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">  	return sell[prices.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros &amp;&amp; Sort Colors"></a>Move zeros &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums)&#123;</span><br><span class="line">    int p1= 0;</span><br><span class="line">  	int p2= nums.length-1;</span><br><span class="line">  	int index=0;</span><br><span class="line">  	while(index&lt; nums.length)&#123;</span><br><span class="line">        if(nums[index]==0 &amp;&amp; index&gt; p1)&#123;</span><br><span class="line">            swap(p1, index, nums);</span><br><span class="line">          	p1++;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	if(nums[index]==2 &amp;&amp; index&lt;p2)&#123;</span><br><span class="line">            swap(p2, index, nums);</span><br><span class="line">          	p2--;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	index++;</span><br><span class="line">    &#125;</span><br><span class="line">  	public void swap(int p1, int p2, int nums)&#123;</span><br><span class="line">        int temp= nums[p1];</span><br><span class="line">      	nums[p1]= nums[p2];</span><br><span class="line">      	nums[p2]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>
<p>这里还有一道follow up：</p>
<p>Given an array of integers, remove the duplicate number in it. You should:</p>
<ol>
<li>Do it in place in the array.</li>
<li>Move the unique numbers to the front of the array</li>
<li>Return the total number of the unique numbers.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int deduplicatation(int[] nums)&#123;</span><br><span class="line">  if(nums.length==0) return 0;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  int len=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= nums[len])&#123;</span><br><span class="line">      swap(i, ++len, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-220-Contains-Duplicate"><a href="#Leetcode-220-Contains-Duplicate" class="headerlink" title="Leetcode 220. Contains Duplicate"></a>Leetcode 220. Contains Duplicate</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k;</p>
<p>这道题其实是一道很不错的题目， 对于这道题目， 我们可以有两个解法。</p>
<p>解法1： 利用TreeSet, 维持一个k大小的TreeSet， 每次进行查看， 复杂度 O(n lgk);</p>
<p>解法2： 利用bucket sort，限制bucket的大小， 使得处于一个bucket内的两个数字之差不能大于t, 这里我们选取t+1为bucket size， 而后每次查看前后两个两个bucket是否存在符合条件的点（因为两个相邻bucket之间也有可能存在的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">        if(k&lt;1 || t&lt;0) return false;</span><br><span class="line">        Map&lt;Long, Long&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            long remappedNum= (long) nums[i]- Integer.MIN_VALUE;</span><br><span class="line">            long bucket= remappedNum/((long) t +1);</span><br><span class="line">            if(map.containsKey(bucket)</span><br><span class="line">                    || (map.containsKey(bucket-1) &amp;&amp; remappedNum- map.get(bucket-1)&lt;=t)</span><br><span class="line">                    || (map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1)-remappedNum&lt;=t))</span><br><span class="line">                return true;</span><br><span class="line">            if(map.entrySet().size()&gt;=k)&#123;</span><br><span class="line">                long lastBucket=((long) nums[i-k]- Integer.MIN_VALUE)/((long) t+1);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Solution 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">  // floor(x) is the maximum number but still &lt;x</span><br><span class="line">  // ceiling(x) is the minimum number but still&gt;x</span><br><span class="line">    if(nums==null || nums.length==0 || k&lt;=0)  return false;</span><br><span class="line">  final TreeSet&lt;Integer&gt; values= new TreeSet&lt;&gt;();</span><br><span class="line">  for(int ind=0; ind&lt;nums.length; ind++)&#123;</span><br><span class="line">      final Integer floor= values.floor(nums[ind]+ t);</span><br><span class="line">    final Integer ceil= values.ceiling(nums[ind]-t);</span><br><span class="line">    if((floor!=null &amp;&amp; floor&gt;nums[ind])  || (ceil!=null &amp;&amp; ceil&lt;=nums[ind]))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    values.add(nums[ind]);</span><br><span class="line">            if (ind &gt;= k) &#123;</span><br><span class="line">                values.remove(nums[ind - k]);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287. Find the Duplicate Number"></a>Leetcode 287. Find the Duplicate Number</h3><p>Given an array nums containing n+1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int findDuplicate(int[] nums)&#123;</span><br><span class="line">  	int slow= nums[0];</span><br><span class="line">  	int fast= nums[nums[0]];</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">  	fast=0;</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">  	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有一些细节需要注意：</p>
<ol>
<li>对于slow和fast的初始化， 我们为什么要这么设；</li>
<li>在找到交点之后我们为什么又设置为0；</li>
</ol>
<p>以上两点都要从我们对于这道题目原理的理解进行出发开始解答， fast走了多远， slow走了多远， 把带环的linkedlist示意图画出来大概就能理解了。</p>
<h3 id="Leetcode-41-First-Missing-Positive"><a href="#Leetcode-41-First-Missing-Positive" class="headerlink" title="Leetcode 41. First Missing Positive"></a>Leetcode 41. First Missing Positive</h3><p>Given an unsorted integer array, find the first missing positive integer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums)&#123;</span><br><span class="line">  int end= nums.length -1;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">     if(nums[i]==i+1) continue;</span><br><span class="line">     int index= nums[i]-1;</span><br><span class="line">     if(index&gt;=0 &amp;&amp; index&lt;nums.length &amp;&amp; nums[index]!= nums[i])&#123;</span><br><span class="line">       swap(index, i, nums);</span><br><span class="line">       i--;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= i+1) return i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums.length+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两边扫描的方法， 第一遍扫描， 将可以放入正确slot的值放入其正确的slot， 第二遍扫描， 找到第一个不属于自己地方的num。</p>
<h3 id="Find-Two-missing-numbers"><a href="#Find-Two-missing-numbers" class="headerlink" title="Find Two missing numbers"></a>Find Two missing numbers</h3><p>Given an array of n unique integers where each element in the array is in range(1, n). The array has all distinct elements and size of array is(n-2). Hence Two numbers from the range are missing from this array. Find the two missing numbers.</p>
<p>Below are steps:</p>
<ol>
<li><p>Find XOR of all array elements and natural numbers from 1 to n.</p>
</li>
<li><p>As per the property of XOR, same elements will cancel out and we will be left with the two missing numbers A XOR B. But we don’t know the exact numbers.</p>
</li>
<li><p>A bit is set in XOR only of corresponding bits in A and B are different. This is the crucial step to understand.</p>
</li>
<li><p>We take a set bit in XOR. Let us consider the rightmost set bit in XOR, for example , we miss 2 and 4 in {1, 3, 5, 6}. the OXR we get is 110, then set_bit_no= 010.</p>
</li>
<li><p>Now again if we XOR all the elements of arr[] and 1 to n that have rightmost bit set we will get one of the repeating numbers, say x.</p>
<p>Ex:</p>
<p>Elements in arr[] with bit set: {3, 6}</p>
<p>Elements from 1 to n with bit set {2, 3, 6}</p>
<p>Result of XOR all these is x=2;</p>
</li>
<li><p>Similarly, if we XOR all the elements of arr[] and 1 to n that have rightmost bit not set, we will get the other element, say y.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void findTwoMissingNumbers(int[] arr, int n)&#123;</span><br><span class="line">  int XOR= arr[0];</span><br><span class="line">  for(int i=1; i&lt;n-2; i++)&#123;</span><br><span class="line">    XOR^=arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    XOR^=i;</span><br><span class="line">  &#125;</span><br><span class="line">  //Get a set bit of XOR(we get the rightmost set bit)</span><br><span class="line">  int set_bit_no= XOR &amp; ~(XOR-1);</span><br><span class="line">  // now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element.</span><br><span class="line">  int x=0, y=0;</span><br><span class="line">  for(int i=0; i&lt;n-2; i++)&#123;</span><br><span class="line">    if((arr[i] &amp; set_bit_no)&gt; 0)&#123;</span><br><span class="line">      x= x^arr[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y ^arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    if((i&amp; set_bit_no)&gt;0)&#123;</span><br><span class="line">      x= x^i;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y^i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // Here we get x and y, which is the result;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><a href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。" class="headerlink" title="给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。"></a>给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</h3><p>For each node:</p>
<ol>
<li>add node to a HashSet</li>
<li>increment the block count by one.</li>
<li>If the node’s previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counter blocks.</li>
</ol>
<h3 id="What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><a href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists" class="headerlink" title="What’s the time complexity of merge k sorted linked lists;"></a>What’s the time complexity of merge k sorted linked lists;</h3><p>Given K sorted linked lists of size n each, merge them and print the sorted output.</p>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>A Simple Solution is to initialize result as first list. Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way. Time complexity of this solution is O(N2) where N is total number of nodes, i.e., N = kn.</p>
<h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>A better solution is to use Min Heap based solution. Time complexity of this solution would be O(nk Log k); n is the size of the list.</p>
<h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><p>Merge recursively, the time complexity is just like method 2;</p>
<h3 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472 Concatenated Words"></a>Leetcode472 Concatenated Words</h3><p>Given a list of words(without duplicates). Please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of least shorter words in the given array,</p>
<p>其实这道题目本质上就是wordbreak， 用wordbreak的思路就能做出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        if(words.length==0) return res;</span><br><span class="line">        Arrays.sort(words, (s1, s2)-&gt;&#123;</span><br><span class="line">            return s1.length()- s2.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        Set&lt;String&gt; dict= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;words.length; i++)&#123;</span><br><span class="line">            if(canForm(dict, words[i]))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dict.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean canForm(Set&lt;String&gt; dict, String word)&#123;</span><br><span class="line">        if(dict.size()==0) return false;</span><br><span class="line">        boolean[] dp= new boolean[word.length()+1];</span><br><span class="line">        dp[0]= true;</span><br><span class="line">        for(int i=1; i&lt;=word.length(); i++)&#123;</span><br><span class="line">            for(int j=i-1; j&gt;=0; j--)&#123;</span><br><span class="line">                if(!dp[j]) continue;</span><br><span class="line">                if(dict.contains(word.substring(j, i)))&#123;</span><br><span class="line">                    dp[i]= true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="491-Increasing-subsequence"><a href="#491-Increasing-subsequence" class="headerlink" title="491. Increasing subsequence"></a>491. Increasing subsequence</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.</p>
<p>这道题目， 属于对于去重的考察比较好的一道题目， 为了完成去重， 我们要确定， 每一次加进去的数字都是第一次被访问的。 并且， 这是一个未排序的数列， 所以只能用hashset来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        helper(0, nums, new ArrayList&lt;&gt;(), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void helper(int pos, int[] nums, List&lt;Integer&gt; unit, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(unit.size()&gt;=2)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(unit));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; used= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i= pos; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(used.contains(nums[i])) continue;</span><br><span class="line">            if(unit.size()==0 || unit.get(unit.size()-1)&lt;=nums[i])&#123;</span><br><span class="line">                used.add(nums[i]);</span><br><span class="line">                unit.add(nums[i]);</span><br><span class="line">                helper(i+1, nums, unit, res);</span><br><span class="line">                unit.remove(unit.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zuma-Game"><a href="#Zuma-Game" class="headerlink" title="Zuma Game"></a>Zuma Game</h3><p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>
<p>Each time, you may choose a ball in your hand, and insert it into the row(including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>
<p>Find the minimum balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&apos;t exceed 5&quot;</span><br><span class="line"></span><br><span class="line">public int findMinStep(String board, String hand) &#123;</span><br><span class="line">    int[] handCount = new int[26];</span><br><span class="line">    for (int i = 0; i &lt; hand.length(); ++i) ++handCount[hand.charAt(i) - &apos;A&apos;];</span><br><span class="line">    int rs = helper(board + &quot;#&quot;, handCount);  // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.</span><br><span class="line">    return rs == MAXCOUNT ? -1 : rs;</span><br><span class="line">&#125;</span><br><span class="line">private int helper(String s, int[] h) &#123;</span><br><span class="line">    s = removeConsecutive(s);     </span><br><span class="line">    if (s.equals(&quot;#&quot;)) return 0;</span><br><span class="line">    int  rs = MAXCOUNT, need = 0;</span><br><span class="line">    for (int i = 0, j = 0 ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        if (s.charAt(j) == s.charAt(i)) continue;</span><br><span class="line">        need = 3 - (j - i);     //balls need to remove current consecutive balls.</span><br><span class="line">        if (h[s.charAt(i) - &apos;A&apos;] &gt;= need) &#123;</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] -= need;</span><br><span class="line">            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] += need;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br><span class="line">//remove consecutive balls longer than 3</span><br><span class="line">private String removeConsecutive(String board) &#123;</span><br><span class="line">    for (int i = 0, j = 0; j &lt; board.length(); ++j) &#123;</span><br><span class="line">        if (board.charAt(j) == board.charAt(i)) continue;</span><br><span class="line">        if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));</span><br><span class="line">        else i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return board;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解， 每次计算需要多少个球进行一次消失， 然后对board进行更新。进行递归计算。</p>
<h3 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210. Course Schedule II"></a>Leetcode 210. Course Schedule II</h3><p>除了喜闻乐见的bfs（即 topologic sort）做法来完成这一道题， 还可以用dfs来做， 所不同的是， 我们在这里用stack进行递归， 这样保证， 如果p-&gt;q, 那么p肯定属于stack的外层， 也就是说 整个stack的结构肯定是符合Schedule的。 这个做法还是非常之骚气的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   boolean hasCycle=false;</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites)&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map= new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        for(int[] prerequisite: prerequisites)&#123;</span><br><span class="line">            int curr=prerequisite[0];</span><br><span class="line">            int prev=prerequisite[1];</span><br><span class="line">            if(!map.containsKey(prev))&#123;</span><br><span class="line">                map.put(prev, new ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(prev).add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int[] visited= new int[numCourses];</span><br><span class="line">        for(int i=0; i&lt;numCourses; i++)&#123;</span><br><span class="line">            dfs(i, visited, map, stack);</span><br><span class="line">            if(hasCycle) return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[stack.size()];</span><br><span class="line">        int index=0;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            res[index++]=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int curr,int[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; map, Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">        if(visited[curr]==1)&#123;</span><br><span class="line">            hasCycle=true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(visited[curr]==-1) return;</span><br><span class="line">        if(!map.containsKey(curr))&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            visited[curr]=-1;</span><br><span class="line">            return;</span><br><span class="line">            // we have find the terminate, which means the end of one chain;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[curr]=1;</span><br><span class="line">        List&lt;Integer&gt; next= map.get(curr);</span><br><span class="line">        for(int num: next)&#123;</span><br><span class="line">            dfs(num, visited, map, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curr);</span><br><span class="line"></span><br><span class="line">        // post order</span><br><span class="line">        visited[curr]=-1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-57-Insert-Interval"><a href="#Leetcode-57-Insert-Interval" class="headerlink" title="Leetcode 57. Insert Interval"></a>Leetcode 57. Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals(merge if necessary). You may assume that the intervals were initially sorted according to their start time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        List&lt;Interval&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        Interval prev= newInterval;</span><br><span class="line">        for(Interval curr: intervals)&#123;</span><br><span class="line">            if(prev==null)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.end&lt;prev.start)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.start&lt;=prev.end)&#123;</span><br><span class="line">                prev.start = Math.min(prev.start,curr.start);</span><br><span class="line">                prev.end= Math.max(prev.end, curr.end);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.add(prev);</span><br><span class="line">                res.add(curr);</span><br><span class="line">                prev= null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prev!=null) res.add(prev);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清楚思路， 对于这道题， 我们所要完成的功能是把interval插进去。</p>
<ol>
<li>interval 已经插入过了， 那么interval是null， 我们直接continue;</li>
<li>interval在左边， 我们插入interval， 插入当前， 然后将interval置为null,表示已经插入过了。</li>
<li>interval在右边， 我们将curr插入， 继续遍历。</li>
<li>interval和当前重叠， 我们将curr 与interval merge， 作为新的interval；</li>
</ol>
<h3 id="Leetcode-630-Course-Schedule-III"><a href="#Leetcode-630-Course-Schedule-III" class="headerlink" title="Leetcode 630 Course Schedule III"></a>Leetcode 630 Course Schedule III</h3><p>There are n different online courses numbered from 1 to n. Each course has some duration(course length) t, and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given n online courses represented by pairs(t, d), your task is to find the maximal number of courses that can be taken;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">  public int scheduleCourse(int[][] courses)&#123;</span><br><span class="line">    Arrays.sort(courses, (a, b)-&gt; a[1]-b[1]);// sort the courses by their deadlines. Greedy! We have to deal with courses with early deadlines first</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;&gt;((a, b)-&gt; b-a);</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int[] c: courses)&#123;</span><br><span class="line">      time+=c[0];</span><br><span class="line">      pq.add(c[0]);</span><br><span class="line">      if(time&gt;c[1]) time-=pq.poll();// if time exceeds, drop the previous course which costs the most time.</span><br><span class="line">    &#125;</span><br><span class="line">    return pq.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题算是比较蛋疼的了。 记住做法就是了， 每一步， 我们先放入队列中， 如果发现不能满足条件的话， 我们删除占用时间最多的， 这样的话得到的结果总是最好的。</p>
<p>其实还是比较intuitive的。</p>
<h3 id="Leetcode-621-Task-Scheduler"><a href="#Leetcode-621-Task-Scheduler" class="headerlink" title="Leetcode 621. Task Scheduler"></a>Leetcode 621. Task Scheduler</h3><p>其实这道题目， 如果能够理解题目的话， 并不难。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int leastInterval(char[] tasks, int n)&#123;</span><br><span class="line">  int[] c= new int[26];</span><br><span class="line">  for(char t: tasks)&#123;</span><br><span class="line">    c[t-&apos;A&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(c);</span><br><span class="line">  int i=25;</span><br><span class="line">  while(i&gt;=0 &amp;&amp; c[i]==c[25]) i--;</span><br><span class="line">  return Math.max(tasks.length, (c[25]-1)*(n+1)+25-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于形成了一个框架， 然后往这个框架里面放元素。</p>
<h3 id="Leetcode-546-Remove-Boxes"><a href="#Leetcode-546-Remove-Boxes" class="headerlink" title="Leetcode 546. Remove Boxes"></a>Leetcode 546. Remove Boxes</h3><p>Given several boxes with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color(composed of k boxes, k&gt;=1), remove them and get k*k points.</p>
<p>Find the maximum points you can get.</p>
<p>暴力 backtracking 做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeBoxes(int[] boxes) &#123;</span><br><span class="line">        if(boxes.length==0) return 0;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int box: boxes)&#123;</span><br><span class="line">            list.add(box);</span><br><span class="line">        &#125;</span><br><span class="line">        return removeBoxes(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int removeBoxes(List&lt;Integer&gt; boxes)&#123;</span><br><span class="line">        if(boxes.size()==0) return 0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;boxes.size(); i++)&#123;</span><br><span class="line">            int start=i;</span><br><span class="line">            while(i&lt;boxes.size() &amp;&amp; boxes.get(i)==boxes.get(start)) i++;</span><br><span class="line">            List&lt;Integer&gt; next= new ArrayList&lt;&gt;();</span><br><span class="line">            for(int idx=0; idx&lt;boxes.size(); idx++)&#123;</span><br><span class="line">                if(idx&gt;=start &amp;&amp; idx&lt;i) continue;</span><br><span class="line">                next.add(boxes.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res, removeBoxes(next)+ (i-start)*(i-start));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top-down dp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int remooveBoxes(int[] boxes)&#123;</span><br><span class="line">  int n= boxes.length;</span><br><span class="line">  int[][][] dp= new int[n][n][n];</span><br><span class="line">  return removeBoxesSum(boxes, 0, n-1, 0, dp);</span><br><span class="line">&#125;</span><br><span class="line">private int removeBoxesSub(int[] boxes, int i, int j, int k, int[][] dp)&#123;</span><br><span class="line">  if(i&gt;j) return 0;</span><br><span class="line">  if(dp[i][j][k]&gt;0) return dp[i][j][k];</span><br><span class="line">  for(; i+1&lt;= j &amp;&amp; boxes[i+1]==boxes[i], i++, k++);// optimization: all boxes of the same color counted continuously from the first box should be grouped together;</span><br><span class="line">  int res=(k+1)*(k+1)+ removeBoxesSub(i+1, j. 0, dp);</span><br><span class="line">  for(int m= i+1; m&lt;=j; m++)&#123;</span><br><span class="line">    if(boxes[i]==boxes[m])&#123;</span><br><span class="line">      res= Math.max(res, removeBoxesSub(boxes, i+1, m-1, 0, dp)+ removeBoxesSub(boxes, m, j, k+1, dp));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> dp[i][j][k]= res;</span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k)&#123;</span><br><span class="line">  int[] count= new int[128];</span><br><span class="line">  int max=0;</span><br><span class="line">  int start=0;</span><br><span class="line">  for(int end=0; end&lt; s.length(); end++)&#123;</span><br><span class="line">    max= Math.max(max, ++count[s.charAt(end)]);</span><br><span class="line">    if(max+k&lt;=end-start)&#123;</span><br><span class="line">      count[s.charAt(start++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s.length()- start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n);</p>
<p>For example:</p>
<p>S=”ADOBECODEBANC”</p>
<p>T=”ABC”</p>
<p>Minimum window is “BANC”</p>
<p>这道题是window的一道很经典的题目了， 碰到这种题目的时候， 我们需要让window满足一个性质， 然后移动左右边界去更新。 得到我们想要的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t)&#123;</span><br><span class="line">  int count=0;</span><br><span class="line">  int[] cnt= new int[256];</span><br><span class="line">  for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">    cnt[t.charAt(i)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  int left= 0;</span><br><span class="line">  int min= Integer.MAX_VALUE;</span><br><span class="line">  String res= &quot;&quot;;</span><br><span class="line">  for(int right= 0; right&lt;s.length(); right++)&#123;</span><br><span class="line">    cnt[s.charAt(right)]--;</span><br><span class="line">    if(cnt[s.charAt(right)]&gt;=0) count++;</span><br><span class="line">    while(count&gt;= t.length())&#123;</span><br><span class="line">      if(right-left+1&lt;min)&#123;</span><br><span class="line">        min= right- left+1;</span><br><span class="line">        res=s.substring(left, right+1);</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[s.charAt(left)]++;</span><br><span class="line">      if(cnt[s.charAt(left)]&gt;0) count--;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-84-Largest-Rectangle-in-Histogram"><a href="#Leetcode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="Leetcode 84. Largest Rectangle in Histogram"></a>Leetcode 84. Largest Rectangle in Histogram</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>这道题目很经典， 在面试的时候stack基本都是这样用， 用来维持一个顺序， 我们在这里维持一个递增的stack， 每次发现数字比栈顶的数字要小的情况时， 对于栈顶而言， 我们找到了以栈顶为最高点的最大的长方形， 因此该长方形面积也能算出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        //maintain a stack which is strictly non-decreasing</span><br><span class="line">        int[] arr= new int[heights.length+1];</span><br><span class="line">        for(int i=0; i&lt;heights.length; i++)&#123;</span><br><span class="line">            arr[i]=heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&gt;arr[i])&#123;</span><br><span class="line">                int height= arr[stack.pop()];</span><br><span class="line">                int right=i-1;</span><br><span class="line">                int left=(stack.isEmpty()?-1:stack.peek())+1;</span><br><span class="line">               //System.out.println(&quot;height=&quot;+ height);</span><br><span class="line">               // System.out.println(&quot;width=&quot;+ (right-left+1));</span><br><span class="line">                res= Math.max(res, (right-left+1)* height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-218-the-skyline-problem"><a href="#Leetcode-218-the-skyline-problem" class="headerlink" title="Leetcode 218 the skyline problem"></a>Leetcode 218 the skyline problem</h3><p>在这道题里面， 我们给定了每个建筑的位置以及高度， 要我们输出一系列点（天际线）： A key point is the left endpoint of a horizontal line segment.</p>
<p>想法：</p>
<p>for position in sorted(all start points and all end points)</p>
<p>if this position is a start point:</p>
<p> add its height</p>
<p>if this position is a end point:</p>
<p> delete its height</p>
<p>Compare current max height with previous height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;int[]&gt; getSkyline(int[][] buildings)&#123;</span><br><span class="line">  List&lt;int[]&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;int[]&gt; height= new ArrayList&lt;&gt;();</span><br><span class="line">  for(int[] b: buildings)&#123;</span><br><span class="line">    height.add(new int[]&#123;b[0], -b[2]&#125;);</span><br><span class="line">    height.add(new int[]&#123;b[1], b[2]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(height, (a, b)-&gt;&#123;</span><br><span class="line">    if(a[0]==b[0])&#123;</span><br><span class="line">      return a[1]-b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0]-b[0];</span><br><span class="line">  &#125;);</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;Integer&gt;((a, b)-&gt;&#123;return b-a;&#125;);</span><br><span class="line">  pq.offer(0);</span><br><span class="line">  int prev_max=0;</span><br><span class="line">  for(int[] h: height)&#123;</span><br><span class="line">    if(h[1]&lt;0)&#123;</span><br><span class="line">      pq.offer(-h[1]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pq.remove(h[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int max= pq.peek();</span><br><span class="line">    if(prev_max!= max)&#123;</span><br><span class="line">      res.add(new int[]&#123;h[0], max&#125;);</span><br><span class="line">      prev_max= max;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-239-Sliding-Window-Maximum"><a href="#Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="Leetcode 239. Sliding Window Maximum"></a>Leetcode 239. Sliding Window Maximum</h3><p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>这道题目还是关于stack的题目， 所不同的是， 由于其特殊性， 这个栈的大小不能大于k， 所以在这里， 我们维持一个不大于k且递减的栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        // maintain a decreasing linkedlist;</span><br><span class="line">        if(nums.length==0) return new int[0];</span><br><span class="line">        Deque&lt;Integer&gt; deque= new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res= new int[nums.length- k+1];</span><br><span class="line">        int index=0;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            while(deque.size()!=0 &amp;&amp; nums[i]&gt;nums[deque.peekLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            if(i-deque.peekFirst()+1&gt;k)&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&gt;=k-1) res[index++]= nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315. Count of Smaller Numbers After Self."></a>Leetcode 315. Count of Smaller Numbers After Self.</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p>这道题可以用不同的方式来做， 比如说建树， merge sort， binarySearch等等， 这里我们使用建树和binarySearch两种方式来做。</p>
<h4 id="buildTree"><a href="#buildTree" class="headerlink" title="buildTree:"></a>buildTree:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        int val;</span><br><span class="line">        int size; // to kept the size node on his left;</span><br><span class="line">        int duplicate;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.size=0;</span><br><span class="line">            this.duplicate=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(nums.length==0) return res;</span><br><span class="line">        TreeNode root= new TreeNode(nums[nums.length-1]);</span><br><span class="line">        res.add(0);</span><br><span class="line">        for(int i=nums.length-2; i&gt;=0; i--)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(nums[i]);</span><br><span class="line">            insert(root, node, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode insert(TreeNode root, TreeNode node, int curr, List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.val&gt;root.val)&#123;</span><br><span class="line">            curr+=root.size+root.duplicate;</span><br><span class="line">            root.right=insert(root.right, node, curr, res);</span><br><span class="line">        &#125;else if(node.val==root.val)&#123;</span><br><span class="line">            root.duplicate++;</span><br><span class="line">            res.add(root.size+curr);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root.size++;</span><br><span class="line">            root.left=insert(root.left, node, curr, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= nums.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">            int index= findIndex(list, nums[i]);</span><br><span class="line">            //System.out.println(index);</span><br><span class="line">            res.add(index);</span><br><span class="line">            if(index==list.size()) list.add(nums[i]);</span><br><span class="line">            else list.add(index, nums[i]);</span><br><span class="line">            //System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findIndex(List&lt;Integer&gt; list, int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= list.size()-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+(hi- lo)/2;</span><br><span class="line">            if(list.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种做法可以延伸至 reverse pairs 这一道题目。</p>
<h3 id="Leetcode-312-Burst-Balloons"><a href="#Leetcode-312-Burst-Balloons" class="headerlink" title="Leetcode 312. Burst Balloons"></a>Leetcode 312. Burst Balloons</h3><p>注意思维方式： 我们关注的是最后一个爆掉的气球。 关于dp的话， 注意边界和构造就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int[] arr= new int[nums.length+2];</span><br><span class="line">        arr[0]=1;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            arr[i+1]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[nums.length+1]=1;</span><br><span class="line">        int[][] dp= new int[arr.length][arr.length];</span><br><span class="line">        for(int len=2;  len&lt;=arr.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len&lt;arr.length; i++)&#123;</span><br><span class="line">                int start= i;</span><br><span class="line">                int end=i+len;</span><br><span class="line">                for(int j= start+1; j&lt;end; j++)&#123;</span><br><span class="line">                    dp[start][end]= Math.max(dp[start][j]+ dp[j][end]+ arr[start]*arr[end]*arr[j], dp[start][end]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set-Intersection-Size-At-least-Two"><a href="#Set-Intersection-Size-At-least-Two" class="headerlink" title="Set Intersection Size At least Two"></a>Set Intersection Size At least Two</h3><p>An integer interval {a, b}( for integers a&lt;b) is a set of all consecutive integers from a to b, including a and b.</p>
<p>Find the minimum size of a set S such that for every integer intervals A in intervals, the intersection of S with A has size at east 2.</p>
<p>Example 1:</p>
<p>Input: intervals[[1, 3], [1, 4], [2, 5], [3,5]]</p>
<p>Output: 3</p>
<p>思路， 在选择区间中的元素时， 我们可以随意选， 但随意选的后果就是不能让set最优， 所以可以从侧面反映出如果有规则的选择， 可能达到全局最优。 一个思路： 对end进行排序， 这样我们就能根据end进行规则的选择了。</p>
<ol>
<li>很明显， 对于待选区间， 如果之前没有元素被选择过， 那么一定选择最后两个元素， 这样能够覆盖的后续区间最多， 不过这个时候需要判断一下， 选择两个元素之后， 后续区间是否都包含该两个元素。 包含一个+1， 包含两个+2， 不包含则跳出。</li>
<li>对于一个元素被选择了， 我们依旧选取当前区间的最后一个元素，不过此时只选择了一个， 所以只需要测试后续区间是否包含该元素即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class P implements Comparable&lt;P&gt;&#123;</span><br><span class="line">  int s;</span><br><span class="line">  int e;</span><br><span class="line">  int c;</span><br><span class="line">  P(int s, int e)&#123;</span><br><span class="line">    this.s= s;</span><br><span class="line">    this.e= e;</span><br><span class="line">    this.c=0;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int compareTo(P o)&#123;</span><br><span class="line">    return this.e- o.e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public int intersectionSizeTwo(int[][] intervals)&#123;</span><br><span class="line">  List&lt;P&gt; ps= new ArrayList&lt;&gt;();</span><br><span class="line">  int n= intervals.length;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    ps.add(new P(intervals[i][0], intervals[i][1]));</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(ps);</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    P inter= ps.get(i);</span><br><span class="line">    if(inter.c==0)&#123;</span><br><span class="line">      int pos= i+1;</span><br><span class="line">      // the first point we choose the end of curr</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;=inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++; </span><br><span class="line">        if(ps.get(pos).s&lt;=inter.e-1)&#123;</span><br><span class="line">          ps.get(pos).c++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res+=2;</span><br><span class="line">    &#125;else if(inter.c==1)&#123;</span><br><span class="line">      int pos=i+1;</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;= inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是之前intervals问题的推广版本， 我们每次选点都要求局部最优， 也就是选择最后两个点， 然后排除之后的点再次进行选择。 还是很具有价值的一道题目。</p>
<h3 id="Leetcode-173-Binary-Search-Tree-Iterator"><a href="#Leetcode-173-Binary-Search-Tree-Iterator" class="headerlink" title="Leetcode 173. Binary Search Tree Iterator"></a>Leetcode 173. Binary Search Tree Iterator</h3><p>Implement an iterator over a binary search tree(BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.</p>
<p>next() and hasNext() should run in average O(1) and uses O(h) memory, where h is the height of the tree.</p>
<h3 id="Leetcode-285-Inorder-Successor-in-BST"><a href="#Leetcode-285-Inorder-Successor-in-BST" class="headerlink" title="Leetcode 285. Inorder Successor in BST"></a>Leetcode 285. Inorder Successor in BST</h3><p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>If the given node has no in-order successor in the tree, return null.</p>
<p>MySolution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;</span><br><span class="line">        if(root==null) return null;</span><br><span class="line">        if(p.right!=null)&#123;</span><br><span class="line">            TreeNode node= p.right;</span><br><span class="line">            while(node.left!= null)&#123;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;       </span><br><span class="line">        TreeNode node= root;</span><br><span class="line">        TreeNode prev= null;</span><br><span class="line">        while(node!= null)&#123;</span><br><span class="line">            if(node.val&lt;=p.val)&#123;</span><br><span class="line">                node=node.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                prev= node;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Successor"><a href="#Successor" class="headerlink" title="Successor"></a>Successor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode successor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&lt;=p.val)&#123;</span><br><span class="line">    return successor(root.right, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode left= successor(root.left, p);</span><br><span class="line">    return( left!= null)? left: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Predecessor"><a href="#Predecessor" class="headerlink" title="Predecessor"></a>Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode predecessor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&gt;= p.val)&#123;</span><br><span class="line">    return predecessor(root.left, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode right= predecessor(root.right, p);</span><br><span class="line">    return (right!= null) ? right: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/算法(二)/" data-id="cjd8dst54000lauzh1003tcte" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试问题之海量数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/面试问题之海量数据/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/面试问题之海量数据/">面试问题之海量数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Big-Data-Interview-Questions"><a href="#Big-Data-Interview-Questions" class="headerlink" title="Big Data Interview Questions"></a>Big Data Interview Questions</h1><h1 id="Top-K-Frequent"><a href="#Top-K-Frequent" class="headerlink" title="Top K Frequent"></a>Top K Frequent</h1><p>寻找数据流中出现最频繁的k个元素(find k frequent items in a data stream)。 这个问题也称为Heavy Hitters。</p>
<p>这题也是从实践中提炼而来的， 例如搜索引擎的热搜榜， 找出访问网站次数最多的前10个IP地址， 等等。</p>
<h2 id="方案1：-HashMap-Heap"><a href="#方案1：-HashMap-Heap" class="headerlink" title="方案1： HashMap+ Heap"></a>方案1： HashMap+ Heap</h2><p>用一个HashMap， 存放所有元素出现的次数， 用一个小根堆， 容量为K， 存放目前出现过的最频繁的k个元素。</p>
<ol>
<li>每次从数据流来一个元素， 如果在HashMap里已经存在， 则把对应的计数器增1， 如果不存在， 则插入， 计数器初始化为1.</li>
<li>在堆里寻找该元素， 如果找到， 把堆里的计数器也增1， 并调整堆； 如果没找到， 把这个元素的次数跟堆顶元素比较， 如果大于堆订元素的出现次数， 则把堆顶元素替换为该元素， 并调整堆。</li>
<li>空间复杂度O(n). HashMap需要存放下所有元素，需要O(n);</li>
<li>时间复杂度<code>O(n)</code>。每次来一个新元素，需要在HashMap里查找一下，需要<code>O(1)</code>的时间；然后要在堆里查找一下，<code>O(k)</code>的时间，有可能需要调堆，又需要<code>O(logk)</code>的时间，总的时间复杂度是<code>O(n(k+logk))</code>，k是常量，所以可以看做是O(n)。</li>
</ol>
<p>如果元素数量巨大， 单机内存存不下， 怎么办？ 有两个办法， 见方案2和3.</p>
<h2 id="方案2：-多机HashMap-Heap"><a href="#方案2：-多机HashMap-Heap" class="headerlink" title="方案2： 多机HashMap+ Heap"></a>方案2： 多机HashMap+ Heap</h2><ul>
<li>可以把数据进行分片。 假设有8台机器， 第一台机器只处理hash(elem)%8==0 的元素， 第二台机器只处理hash(elem)%8==1的元素， 以此类推。</li>
<li>每台机器都有一个HashMap和一个Heap， 各自独立计算出top k的元素</li>
<li>把每台机器的Heap， 通过网络汇总到一台机器上， 将多个Heap合并成一个Heap，就可以计算出总的top k个元素了。</li>
</ul>
<h2 id="方案3：-Count-Min-Sketch-heap（近似算法）"><a href="#方案3：-Count-Min-Sketch-heap（近似算法）" class="headerlink" title="方案3： Count-Min Sketch + heap（近似算法）"></a>方案3： Count-Min Sketch + heap（近似算法）</h2><p>相当于用一个近似的频率来代替真实的出现吃树。</p>
<p>既然方案中的Hash Map太大， 内存装不下， 那么可以用Count-Min Sketch算法代替HashMap。</p>
<ul>
<li>在数据流不断流入的过程中， 维护一个标准的Count-Min Sketch二维数组</li>
<li>维护一个小根堆， 容量为k</li>
<li>每次来一个新元素<ul>
<li>将相应的sketch增1</li>
<li>在堆中查找该元素， 如果找到， 把堆里的计数器也增1， 并调整堆； 如果没有找到， 把这个元素的sketch作为该元素的频率的近似值， 如果大于堆顶元素的概率， 则把堆顶元素替换为该元素， 并调整堆。</li>
</ul>
</li>
</ul>
<p>Count-Min Sketch 算法流程：</p>
<ol>
<li>选定d个hash函数， 开一个dxm的二维整数数组作为哈希表。</li>
<li>对于每个元素， 分别使用d个哈希函数计算相应的hash值， 并对m取余， 然后再对应的位置上增1，二维数组中的每个整数称为sketch</li>
<li>要查询某个元素的频率时， 只需要取出d个sketch， 返回最小的那一个(其实d个sketch都是该元素的近似频率， 返回任意一个都可以， 该算法选择最小的那个)。</li>
</ol>
<p>这个方法的思路和Bloom Filter比较类似， 都是用多个hash函数来降低冲突。</p>
<ul>
<li><p>空间复杂度O(dm)。 Count-Min Sketch需要开一个dxm大小的二维数组， 所以空间复杂度是O(dm)</p>
</li>
<li><p>时间复杂度O(n). Count-Min Sketch只需要一遍扫描， 所以时间复杂度是O(n)</p>
<p>​</p>
</li>
</ul>
<p>Count Min Sketch 算法的优点是省内存， 缺点是对于出现次数比较少的元素， 准确性很差， 因为二维数组相比于原始数据来说还是太小， hash冲突比较严重， 导致结果偏差比较大。</p>
<p>算法评价：</p>
<p>只会估算偏大， 永远不会偏小；</p>
<p>只需要固定大小的内存和计算时间， 和需要统计的元素多少无关；</p>
<p>对于低频的元素， 估算值相对的错误可能会变大。</p>
<h2 id="Lossy-Counting"><a href="#Lossy-Counting" class="headerlink" title="Lossy Counting"></a>Lossy Counting</h2><p>Lossy Counting 算法流程：</p>
<ol>
<li>建立一个HashMap， 用于存放每个元素的出现次数。</li>
<li>建立一个窗口（窗口的大小由错误率决定， 后面具体讨论）</li>
<li>等待数据流不断流入这个窗口， 直到窗口满了， 开始统计每个元素出现的频率， 统计结束后， 每个元素的频率减1， 然后将出现次数为0 的元素从HashMap中栓除</li>
<li>返回第二步， 不断循环。</li>
</ol>
<p>Lossy Counting 背后朴素的思想是，出现频率高的元素，不太可能减一后变成0，如果某个元素在某个窗口内降到了0，说明它不太可能是高频元素，可以不再跟踪它的计数器了。随着处理的窗口越来越多，HashMap也会不断增长，同时HashMap里的低频元素会被清理出去，这样内存占用会保持在一个很低的水平。</p>
<p>很显然，Lossy Counting 算法是个近似算法，但它的错误率是可以在数学上证明它的边界的。假设要求错误率不大于ε，那么窗口大小为1/ε，对于长度为N的流，有N／（1/ε）＝εN 个窗口，由于每个窗口结束时减一了，那么频率最多被少计数了窗口个数εN。</p>
<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>问题一：Query 去除 在处理文字链相关广告的时候，遇到这样一个问题。用户很多的搜索，都是检索不到广告的。对于这一类的用户搜索，基本上来说，是没什么价值的。这样的数据也就可以丢弃了。但是，想确定一个搜索有没有价值，我们要匹配所有的广告，接近千万条。而用户的搜索更是上亿，每一个用户搜索都进行一次匹配。这样的匹配，估计现在多少的机器也搞不定。</p>
<p>问题二：URL是否被爬过 这与另外一个问题类似。假设我们在做一个爬虫，有1000亿的url地址，我们想确定一下当前的url有没有被爬过。最简单的想法是，我们直接用一个hash set。但是100亿条数据，也就是10G，每条数据hash一次8个byte，但是hashset的利用效率也就是50%，那也就是需要160GB的内存。现在有机器能存下这么多的内存，估计用起来也是很吃力吧。</p>
<p>Bloom filter 的想法很简单， 每个Bloom Filter 有两个参数：</p>
<ol>
<li>一个是k， 表示由多少个hash function。</li>
<li>另外一个是m， 表示bloom filter由多少个bit。</li>
</ol>
<p>Bloom filter的过程很简单， 就只有hash和位运算， 大致为下面几步：</p>
<ol>
<li>使用k个hash function 进行hash</li>
<li>hash之后再对m取余， 得到在filter的位置</li>
<li>最后对相应的位置置1。</li>
</ol>
<p>这个是处理输入的过程。 判断一个输入是不是在bloom filter中， 则进行类似的操作：</p>
<ol>
<li>使用k个hash函数进行hash</li>
<li>hash以后再对m取余， 得到在filter的位置</li>
<li>看所有的位置是不是<em>都是1</em>， 如果是返回true， 否则返回false</li>
</ol>
<h3 id="K和m的取值"><a href="#K和m的取值" class="headerlink" title="K和m的取值"></a>K和m的取值</h3><p>在使用bloom filter的时候， 最关键的是设置这两个参数。 一般来说， false positive的概率小于0.01就可以了。 K一般选择3或者4，而m/n一般选择10 左右。 所以上面， 对于URL的处理， 我们需要大概100Gb，也就是12GB的内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/面试问题之海量数据/" data-id="cjd8dst50000iauzh0q4lg6jh" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试中的随机算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/面试中的随机算法/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/面试中的随机算法/">面试中的随机算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Common-Random-Algorithm"><a href="#Common-Random-Algorithm" class="headerlink" title="Common Random Algorithm"></a>Common Random Algorithm</h1><h2 id="随机算法总结"><a href="#随机算法总结" class="headerlink" title="随机算法总结"></a>随机算法总结</h2><blockquote>
<p>下文所有用到的随机函数都假定它能随机的产生范围[1, b]内的整数， 即产生每个整数的概率相等。</p>
</blockquote>
<h3 id="随机排列数组"><a href="#随机排列数组" class="headerlink" title="随机排列数组"></a>随机排列数组</h3><p>假设给定一个数组A， 它包含元素1到N， 我们的目标是构造这个数组的一个随机排列。</p>
<p>一个常用的方法是 原地排列给定数组， 可以在O(N)的时间内完成， 伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZE-IN-PLACE ( A , n ) for i ←1 to n do swap A[i] ↔ A[RANDOM(i , n )]</span><br></pre></td></tr></table></figure>
<p>对于该算法的正确性的证明， 戳这里： <a href="http://www.jianshu.com/p/f8e7070c1c6b" target="_blank" rel="noopener">here</a></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static shuffle(int[] nums)&#123;</span><br><span class="line">    Random random= new Random();</span><br><span class="line">  	for(int i= nums.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        int next=random.nextInt(i+1);</span><br><span class="line">      	swap(nums, next, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int temp= nums[i];</span><br><span class="line">  	nums[i]= nums[j];</span><br><span class="line">  	nums[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机选取一个数字"><a href="#随机选取一个数字" class="headerlink" title="随机选取一个数字"></a>随机选取一个数字</h3><p>给定一个未知长度的整数流， 如何随机选取一个数？（所谓随机就是保证每个数被选取的概率相等）</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>如果数据流不是很长， 可以存在数组中， 然后再从数组中随机选取。 当然题目说的是未知长度， 所以如果长度很大不足以保存在内存中的话会很麻烦。 这种解法有其局限性。</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>如果数据流在第一个数字后结束， 那么必选第一个数字。</p>
<p>如果数据流在第二个数字后结束， 那么我们选第二个数字的概率为1/2， 我们以1/2 的概率用第二个数字替换前面选的随机数， 得到新的随机数。</p>
<p>………………………….</p>
<p>如果数据流在第n个数字后结束， 那么我们选择第n个数字的概率为1/n， 即我们以1/n的概率用第n个数字替换前面选的随机数， 得到新的随机数。</p>
<p>一个简单的方法就是使用随机函数 bigrand()%n, 其中 bigrand() 返回很大的随机整数， 当数据流到第n个数时， 如果f(n)==0, 则替换前面的已经选的随机数， 这样可以保证每个数字被选中的概率都是1/n。</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int getRand(int[] nums)// here we don&apos;t know the size of the array</span><br><span class="line">&#123;	</span><br><span class="line">	int count=0;</span><br><span class="line">	int candidate=-1;</span><br><span class="line">	Random random= new Random();</span><br><span class="line">   	for(int num: nums)&#123;</span><br><span class="line">      	int next= random.next(count+1);</span><br><span class="line">      	if(next==0)&#123;</span><br><span class="line">          	candidate= num;</span><br><span class="line">      	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   	return candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机选取M个数字"><a href="#随机选取M个数字" class="headerlink" title="随机选取M个数字"></a>随机选取M个数字</h3><p>随机抽样问题表示如下：</p>
<p>要求从N个元素中随机的抽取k个元素， 其中N无法确定。</p>
<p>这种应用的场景一般是在数据流的情况下， 由于数据只能被读取一次， 而且数据量很大， 并不能全部保存， 因此数据量N是无法在抽样开始时确定的； 但又要保持随机性， 于是有了这个问题。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>解决方案就是蓄水库抽样(Reservoid sampling). 主要思想就是保持一个集合， 作为一个蓄水池， 依次遍历所有数据的时候以一定概率替换这个蓄水池中的数字。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Init: a reservior with the size: k</span><br><span class="line">	for i= k+1 to N</span><br><span class="line">		M= rand(1, i);</span><br><span class="line">		if(M&lt;K)</span><br><span class="line">			SWAP the Mth value and ith value</span><br><span class="line">	end for</span><br></pre></td></tr></table></figure>
<p>证明方法：</p>
<p><a href="http://blog.csdn.net/hackbuteer1/article/details/7971328" target="_blank" rel="noopener">归纳法</a></p>
<h3 id="已知-rand-n-，-求出rand-m"><a href="#已知-rand-n-，-求出rand-m" class="headerlink" title="已知 rand(n) ， 求出rand(m)"></a>已知 rand(n) ， 求出rand(m)</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>已知一个函数rand7() 能够生成1~7 的随机数，请给出一个函数， 该函数能够生成1-10的随机数。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>假如已知一个函数能够生成1-49 的随机数， 那么如何以此生成1-10 的随机数呢》</p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>该解法基于一种叫做拒绝采样的方法。主要思想是只要产生一个目标范围内的随机数， 则直接返回。 如果产生的随机数不在目标范围内， 则丢弃该值， 重新取样。 由于目标范围内的数字被选中的概率相等， 这样一个均匀的分布生成了。</p>
<p>显然rand7至少需要执行两次， 否则产生不了1~10的数字。 通过运行rand7两次， 可以生成1~49的整数。</p>
<p>由于49 不是10 的倍数， 所以我们需要丢弃一些值， 我们想要的数字范围为1~40， 不在此范围则丢弃并重新取样。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int rand10()&#123;</span><br><span class="line">  	int row, col, idx;</span><br><span class="line">  	do&#123;</span><br><span class="line">      	row= rand7();</span><br><span class="line">      	col= rand7();</span><br><span class="line">      	idx= col+(row-1)*7;</span><br><span class="line">  	&#125;while(idx&gt;40);</span><br><span class="line">  	return 1+ (idx-1)%10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>上面的方法大概需要2.45次调用才能得到1个1~10 范围内的数， 下面可以进行再度优化。</p>
<p>对于大于40的数， 我们不必马上丢弃， 可以对41~49的数减去40可得到1-9 的随机数， 而rand7可生成1-7的随机数， 这样可以生成1-63的随机数。 对于1-60我们可以直接返回， 而61-63则丢弃， 这样需要丢弃的数只有3个， 相比前面的9个， 效率有所提高。 而对于61-63的数， 减去60之后为1-3， rand7产生1-7， 这样可以再度利用产生1-21的数， 对于1-20 我们则直接返回， 对于21 则丢弃。 这时， 丢弃的数就只有1个了， 优化再进一步。 当然这里对于rand7的调用次数也是增加了。</p>
<p>优化了之后我们大概需要调用2.21次。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/sgbfblog/article/details/7753012" target="_blank" rel="noopener">已知一个函数rand7()</a></p>
<h2 id="加权随机算法"><a href="#加权随机算法" class="headerlink" title="加权随机算法"></a>加权随机算法</h2><p>加权随机算法一般应用在一下场景： 有一个集合S, 里面比如有A，B， C， D这四项。 这时我们想随机从中抽取一项， 但是抽取的概率不同， 比如我们希望抽到A的概率是50%， 抽到B和C的概率是20%， D的概率是10%。 一般来说， 我们可以给各项附一个权重， 抽取的概率正比于这个权重。 那么上述集合就成了：<code>{A:5, B:2, C:2, D:1}</code></p>
<h3 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a>Solution 1：</h3><p>扩展这个集合， 使每一项出现的次数与其权重正相关。 在上述例子这个集合扩展成：</p>
<p><code>{A, A, A, A, A, B, B, C, C, D}</code></p>
<p>然后就可以用均匀随机算法来从中选取。</p>
<ul>
<li>pros: 选取的时间复杂度为O(1)， 算法简单。</li>
<li>cons： 空间占用极大。 另外如果权重数字位数较大， 例如<code>{A: 49.1，B: 50.9}</code>的时候， 就会产生巨大的空间浪费。</li>
</ul>
<h3 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a>Solution 2：</h3><p>计算权重总和sum， 然后在1到sum之间随机选择一个数R， 之后遍历整个集合， 统计遍历的项的权重之和， 如果大于等于R， 就停止遍历， 选择遇到的项。</p>
<p>还是以上面的集合为例， sum等于10， 如果随机到1-5，则会在遍历第一个数字的时候就退出遍历。 符合所选取的概率。</p>
<ul>
<li>Pros： 没有额外的空间占用， 算法也比较简单。</li>
<li>cons： 选取的时候要遍历集合， 时间复杂度是O(n)。</li>
</ul>
<h3 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a>Solution 3：</h3><p>可以对方法二进行优化， 对项目集按照权重排序， 这样遍历的时候， 概率高的项可以很快遇到， 减少遍历的项。</p>
<p>进一步优化， 可以使用数组+ 二分查找来实现。</p>
<ul>
<li>Pros: 提高了平均选取速度。</li>
<li>cons：需要进行排序， 并且不易添加删除修改项。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/面试中的随机算法/" data-id="cjd8dst4w000gauzhz4jd5eg6" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java线程简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java线程简介/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Java线程简介/">Java线程简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程的两种创建方式以及优劣比较"><a href="#线程的两种创建方式以及优劣比较" class="headerlink" title="线程的两种创建方式以及优劣比较"></a>线程的两种创建方式以及优劣比较</h2><ol>
<li><p>通过实现Runnable 接口线程创建</p>
<ul>
<li>定义一个类实现Runnable接口， 重写接口中的run()方法。 在run()方法中加入具体的任务代码或者处理逻辑。</li>
<li>创建Runnable接口实现类的对象。</li>
<li>创建一个Thread类的对象， 需要封装前面Runnable接口实现类的对象。(接口可以实现多继承)</li>
<li>调用Thread对象的start()方法， 启动线程。</li>
</ul>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo1 implements Runnable&#123;</span><br><span class="line">    private int countDown=10;</span><br><span class="line">  @Override</span><br><span class="line">  public void run()&#123;</span><br><span class="line">      while(countDown--&gt;10)&#123;</span><br><span class="line">          System.out.println(&quot;#&quot;+ Thread.currentThread().getName()+ &quot;(&quot;+ countDown+&quot;)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      //Runnable中run方法是一个空方法， 并不会产生任何线程行为， 必须显式地将一个任务附着到现呈上。</span><br><span class="line">    ThreadDemo1 tt= new ThreadDemo1();</span><br><span class="line">    new Thread(tt).start();</span><br><span class="line">    new Thread(tt).start();</span><br><span class="line">    System.out.println(&quot;Counting Down:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法共享countDown， 所以结果的输出只有十行。</p>
</li>
<li><p>通过继承Thread类创建线程。</p>
<ul>
<li>首先定义一个类去继承Thread父类， 重写父类中的run()方法。 在run()方法中加入具体的任务代码或处理逻辑。</li>
<li>直接创建一个ThreadDemo类的对象， 也可以利用多态性，变量声明为父类的类型。</li>
<li>调用start方法， 线程t启动， 隐含的调用run()方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo extends Thread&#123;</span><br><span class="line">    private int countDown=10;</span><br><span class="line">  	@Override</span><br><span class="line">  	public void run()&#123;</span><br><span class="line">		while(countDown--&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+ this.getName()+&quot;(&quot;+ countDown+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	public static void main(String[] args)&#123;</span><br><span class="line">        new ThreadDemo2().start();</span><br><span class="line">      new ThreadDemo2().start();</span><br><span class="line">      System.out.println(&quot;Counting down:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会输出20行。 因为变量并不共享。</p>
</li>
<li><p>两种方式的比较。</p>
<p>同样是创建了两个线程， 为什么结果不一样呢？</p>
<p>使用实现Runnable接口方式创建线程可以共享同一个目标对象(ThreadDemo 1 tt= new ThreadDemo1();), 实现了多个线程可以处理同一份资源。</p>
<p>然后再看一段来自JDK的解释：</p>
<p>Runnable接口应该由哪些通过某一线程执行其实例的类来实现。 类必须定义一个称为run的无参数方法。</p>
<p>设计该接口的目的是为希望再活动时执行代码的对象提供一个公共协议。 例如， Thread类实现了Runnable。 激活的意思是说某个线程已启动并且尚未停止。</p>
<p>此外， Runnable为非Thread子类的类提供了一种激活方式。 通过实例化某个Thread实例并将自身作为运行目标， 就可以运行实现Runnable的类而无须创建Thread的子类。 大多数情况下， 如果指向重写run()方法， 而不重写其他Thread方法， 那么应该使用Runnable接口。 这很重要， 因为除非程序员打算修改或增强类的基本行为， 否则不应为该类创建子类。</p>
</li>
</ol>
<h2 id="Java-里的生产者-消费者模型-Producer-and-Consumer"><a href="#Java-里的生产者-消费者模型-Producer-and-Consumer" class="headerlink" title="Java 里的生产者-消费者模型(Producer and Consumer)"></a>Java 里的生产者-消费者模型(Producer and Consumer)</h2><p>生产者-消费者模型是多线程问题里面的经典问题， 也是面试的常见问题。 有如下几个常见的实现方法：</p>
<ol>
<li>wait()/notify()</li>
<li>lock &amp; condition</li>
<li>Blocking Queue</li>
</ol>
<p>下面来逐一分析：</p>
<ol>
<li><p>wait()/notify()</p>
<p>第一种实现， 利用根类Object的两个方法wait()/notify(), 来停止或者唤醒线程的执行； 这也是最原始的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyBroker&lt;T&gt; implements Brocker&lt;T&gt;&#123;</span><br><span class="line">    private final Object[] items;</span><br><span class="line">  	private int takeIndex;</span><br><span class="line">  	private int putIndex;</span><br><span class="line">  	private int count;</span><br><span class="line">  	public WaitNotifyBroker(int capacity)&#123;</span><br><span class="line">        this.items= new Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">  	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  	@Override </span><br><span class="line">  	public T take()&#123;</span><br><span class="line">        T tmpObj= null;</span><br><span class="line">      	try&#123;</span><br><span class="line">            synchronized(items)&#123;</span><br><span class="line">                while(0==count)&#123;</span><br><span class="line">                    items.wait();</span><br><span class="line">                &#125;</span><br><span class="line">              	tmpObj= (T) items[takeIndex];</span><br><span class="line">              if(++Index==items.length)&#123;</span><br><span class="line">                  takeIndex=0;</span><br><span class="line">              &#125;</span><br><span class="line">              count--;</span><br><span class="line">              items.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      	return tmpObj&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void put(T obj)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            synchronized(items)&#123;</span><br><span class="line">                while(items.length==count)&#123;</span><br><span class="line">                    items.wait();</span><br><span class="line">                &#125;</span><br><span class="line">              	items[putIndex]= obj;</span><br><span class="line">              	if(++putIndex==items.length)&#123;</span><br><span class="line">                    putIndex=0;</span><br><span class="line">                &#125;</span><br><span class="line">              	count++;</span><br><span class="line">              	items.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用Array构造一个Buffer去存取数据， 并利用count， putIndex和 takeIndex来保证FIrst-In-First-Out。</p>
<p>如果利用LinkedList 来代替Array， 相对来说会稍微简单些。</p>
<p>LinkedList的实现， 可以参考《Java 7 Concurrency Cookbook》第二章 wait/notify;</p>
</li>
<li><p>lock &amp; condition</p>
<p>lock &amp; condition， 实际上也实现了类似synchronized和wait()/notify()的功能， 但是在加锁和解锁， 暂停和唤醒方面， 更加细腻和可控。</p>
<p>在JDK的BlockingQueue的默认实现里， 也是利用了lock &amp; condition。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class LockConditionBroker&lt;T&gt; implements Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    private final int capacity;</span><br><span class="line">    private LinkedList&lt;T&gt; items;</span><br><span class="line"></span><br><span class="line">    public LockConditionBroker(int capacity) &#123;</span><br><span class="line">        this.lock = new ReentrantLock();</span><br><span class="line">        this.notFull = lock.newCondition();</span><br><span class="line">        this.notEmpty = lock.newCondition();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        items = new LinkedList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        T tmpObj = null;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (items.size() == 0) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmpObj = items.poll();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return tmpObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(T obj) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (items.size() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            items.offer(obj);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BlockingQueue</p>
<p>最后这种方法， 也是最简单最值得推荐的， 利用冰法并发包提供的工具： 阻塞队列， 将阻塞的逻辑交给BlockingQueue， 实际上， 上述1 和2 的方法实现的Broker类， 也可以视为一种简单的阻塞队列， 不过没有标准包那么完善。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueueBroker&lt;T&gt; implements Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final BlockingQueue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">    public BlockingQueueBroker() &#123;</span><br><span class="line">        this.queue = new LinkedBlockingQueue&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return queue.take();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(T obj) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.put(obj);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来， 就是一个1P2C的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Broker&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T take();</span><br><span class="line"></span><br><span class="line">    void put(T obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public class Producer implements Runnable {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private final Broker&lt;Integer&gt; broker;</span><br><span class="line">private final String name;</span><br><span class="line"></span><br><span class="line">public Producer(Broker&lt;Integer&gt; broker, String name) &#123;</span><br><span class="line">    this.broker = broker;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            broker.put(i);</span><br><span class="line">            System.out.format(&quot;%s produced: %s%n&quot;, name, i);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        broker.put(-1);</span><br><span class="line">        System.out.println(&quot;produced termination signal&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
</li>
</ol>
<p>public class Consumer implements Runnable {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final Broker&lt;Integer&gt; broker;</span><br><span class="line">private final String name;</span><br><span class="line"></span><br><span class="line">public Consumer(Broker&lt;Integer&gt; broker, String name) &#123;</span><br><span class="line">    this.broker = broker;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Integer message = broker.take(); message != -1; message = broker.take()) &#123;</span><br><span class="line">            System.out.format(&quot;%s consumed: %s%n&quot;, name, message);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;received termination signal&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           Broker&lt;Integer&gt; broker = new WaitNotifyBroker&lt;Integer&gt;(5);</span><br><span class="line"></span><br><span class="line">   //         Broker&lt;Integer&gt; broker = new LockConditionBroker&lt;Integer&gt;(5);</span><br><span class="line"></span><br><span class="line">   //         Broker&lt;Integer&gt; broker = new BlockingQueueBroker&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">           new Thread(new Producer(broker, &quot;prod 1&quot;)).start();</span><br><span class="line">           new Thread(new Consumer(broker, &quot;cons 1&quot;)).start();</span><br><span class="line">           new Thread(new Consumer(broker, &quot;cons 2&quot;)).start();</span><br><span class="line">    </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Consider the standard producer-consumer problem. Assume, we have a buffer of 4096 byte length. A producer thread collects the data and writes it tp the buffer. A consumer thread processes the collected data from the buffer. Objective is, both the threads should not run at the same time.</p>
<ul>
<li><p>Using Mutex:</p>
<p>A mutex provides mutual exclusion, either producer or consumer can have the key(mutex) and proceed with their work. As long as the buffer is filled by producer, the consumer needs to wait, and vice versa.</p>
<p>At any point of time, only one thread can work with with the entire buffer. The concept can be generalized using semaphore.</p>
</li>
<li><p>Using Semaphore:</p>
<p>A semaphore is a generalized mutex. In lieu of single buffer, we can split the 4 KB buffer into four 1 KB buffers(identical resources). A semaphore can be associated with these four buffers. The consumer and producer can work on different buffers at the same time.</p>
</li>
<li><p>Misconception:</p>
<p>There is an ambiguity between binary semaphore and mutex. we might have come across that a mutex is binary semaphore. But they are not! The purpose of mutex and semaphore are different . May be, due to similarity in their</p>
<p>implementation a mutex would be referred as binary semaphore.</p>
<p>Strictly speaking, a mutex is locking mechanism used to synchronize access to resource. Only one task(can be a thread or process based on OS abstraction) can acquire the mutex. It means there is ownership associated with mutex, and only the owner can release the lock(mutex).</p>
<p>Semaphore is signaling mechanism(“I am done, you can carry on “ kind of signal). For example, if you are listening songs(assume it as one task) on your mobile and at the same time your friend calls you, an interrupt is triggered upon which an interrupt service routine signals the call processing task to wake up.</p>
</li>
</ul>
<h3 id="General-Questions"><a href="#General-Questions" class="headerlink" title="General Questions:"></a>General Questions:</h3><ol>
<li><p>Can a thread acquire more than one lock(Mutex)?</p>
<p>Yes, it is possible that a thread is in need of more than one resource, hence the locks. If any lock is not available the thread will wait(block) on the lock.</p>
</li>
<li><p>Can a mutex be locked more than once?</p>
<p>A mutex is a lock. Only one state(locked/unlocked) is associated with it. However, a recursive mutex can be locked more than once(POSIX complaint systems), in which a count is associated with it, yet retains only one state(locked/unlocked). The programmer must unlock the mutex as many number times as it was locked.</p>
</li>
<li><p>What happens if a non-recursive mutex is locked more than once.</p>
<p>Deadlock. If a thread which had already locked a mutex, tries to lock the mutex again, it will enter into the waiting list of that mutex, which results in deadlock. It is because no other thread can unlock the mutex. An operating system implementer can exercise care in identifying the owner of mutex and return if it is already locked by same thread to prevent deadlocks.</p>
</li>
<li><p>Are binary semaphore and mutex same?</p>
<p>No, we suggest to treat them separately, as it is explained signaling vs locking mechanisms. But a binary semaphore may experience the same critical issues associated with mutex.</p>
</li>
<li><p>What is mutex and critical section?</p>
<p>Some operating systems use the same word critical section in the API. Usually a mutex is costly operation due to protection protocols associated with it. At last, the objective of mutex is atomic access. There are other ways to achieve atomic access like disabling interrupts which can be much faster but ruins responsiveness. The alternate API makes use of disabling interrupts.</p>
</li>
</ol>
<h2 id="StackOverflow-click-here"><a href="#StackOverflow-click-here" class="headerlink" title="StackOverflow: click here"></a>StackOverflow: <a href="https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex" target="_blank" rel="noopener">click here</a></h2><p>Mutex can be released only by thread that had acquired it, while you can signal semaphore from any other thread(or process), so semaphores are more suitable for some synchronization problems like producer-consumer.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java线程简介/" data-id="cjd8dst4q0008auzhu304ucl2" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node.js 学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Node.js 学习笔记/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Node.js 学习笔记/">Node.js 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js-Note"><a href="#Node-js-Note" class="headerlink" title="Node.js Note"></a>Node.js Note</h1><p>** 2017-11-25</p>
<h2 id="如何理解node-js-的单线程"><a href="#如何理解node-js-的单线程" class="headerlink" title="如何理解node.js 的单线程"></a>如何理解node.js 的单线程</h2><p>node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not a problem.</p>
<p>JavaScript的单线程， 与它的用途相关。 作为浏览器脚本语言， JavaScript的主要用途是与用户互动， 以及操作DOM。 这就决定了它只能是单线程， 否则会带来很复杂的同步问题。</p>
<p>比如， 假设JavaScript同时有两个线程， 一个线程在某个DOM节点上添加内容， 另一个线程删除了这个节点， 那么这时浏览器应该以哪个线程为准？</p>
<p>所以， 为了避免复杂性， 从一诞生， JavaScript就是单线程， 这已经成了这门语言的核心特征， 将来也不会改变。</p>
<p>为了利用多核CPU的计算能力， HTML5提出WEB Worker标准， 允许javaScript脚本创建多个线程， 但是子线程完全受主线程控制， 且不得操作DOM。</p>
<p>所以， 这个新标准并没有改变JavaScript单线程的本质。</p>
<p>单线程就意味着， 所有任务需要排队， 前一个任务结束， 才会执行后一个任务。 如果前一个任务耗时很长， 后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大， CPU忙不过来， 倒也算了， 但是很多时候CPU是闲着的， 因为IO设备很慢（比如Ajax操作从网络读取数据）， 不得不等着结果出来， 再往下执行。</p>
<p>JavaScript语言的设计者意识到， 这时主线程完全可以不管IO设备， 挂起处于等待中的任务， 先运行排在后面的任务。 等到IO设备返回了结果， 再回过头， 把挂起的任务继续执行下去。</p>
<p>于是， 所有任务可以分成两种， 一种是同步任务（synchronous）, 另一种是异步任务（asynchronous）。</p>
<blockquote>
<p>同步任务指的是， 在主线程上排队执行的任务， 只有前一个任务执行完毕， 才能执行后一个任务；</p>
<p>异步任务指的是， 不进入主线程， 而进入任务队列的任务， 只有任务队列通知主线程， 某个异步任务可以执行了， 该任务才会进入主线程执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for函数循环10此， 每循环以下就执行一次setTimeOut， 也就是执行了10次setTimeout， 每次setTimeout执行后， 知识将里面的function放进一个队列里， 也就是往队列里面放了10个function， 把这10个function放进队列， 但都没有直接运行， 等待后面所有的程序执行完之后， 再去询问队列里面有没有东西，如果有再去执行， 所以for循环之后， i值就变成了10， 所以会输出10个10；</p>
<p>综上述， 隐含着一个意思， 即触发的每个事件都会位于堆栈的最底部。</p>
<ol>
<li>所有同步任务都在主线程上执行， 形成一个执行栈（execution context stack）。</li>
<li>主线程之外， 还存在一个任务队列。 只要异步任务有了任务结果， 就在任务队列之中放置一个时间。</li>
<li>一旦执行栈中的所有同步任务执行完毕， 系统就会读取“任务队列”， 看看里面有哪些时间。 哪些对应的异步任务。 于是结束等待状态， 进入执行栈， 开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p>这就是JavaScript运行机制。</p>
<p>主线程从任务队列中读取事件， 这个过程是循环不断的， 所以整个的这种运行机制又称为Event Loop。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="noopener">JavaScript是单线程的深入理解</a></p>
<hr>
<h2 id="Node-js-调试工具"><a href="#Node-js-调试工具" class="headerlink" title="Node.js 调试工具"></a>Node.js 调试工具</h2><h3 id="Node-inspect"><a href="#Node-inspect" class="headerlink" title="Node inspect"></a>Node inspect</h3><h3 id="Node-–inspect-brk-Chrome-Dev-Tools"><a href="#Node-–inspect-brk-Chrome-Dev-Tools" class="headerlink" title="Node –inspect-brk(Chrome Dev Tools)"></a>Node –inspect-brk(Chrome Dev Tools)</h3><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27" target="_blank" rel="noopener">Debugging Node.js with Chrome DevTools</a></p>
<p><a href="http://www.jianshu.com/p/611e7be13655" target="_blank" rel="noopener">Node.js 调试方法</a></p>
<h2 id="Intro-to-ES6"><a href="#Intro-to-ES6" class="headerlink" title="Intro to ES6"></a>Intro to ES6</h2><h2 id="Promise-and-Callback"><a href="#Promise-and-Callback" class="headerlink" title="Promise and Callback"></a>Promise and Callback</h2><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>要理解callback的概念， 我们先要理解同步， 异步， 阻塞， 非阻塞的概念。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://larry850806.github.io/2016/06/16/nodejs-async/" target="_blank" rel="noopener">理解Node.js事件驱动</a></p>
<p><a href="http://larry850806.github.io/2016/05/31/async/" target="_blank" rel="noopener">如何使用async控制流程</a></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在开始谈论正题之前，我们先来看看下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(function (value1) &#123;</span><br><span class="line">    step2(value1, function(value2) &#123;</span><br><span class="line">        step3(value2, function(value3) &#123;</span><br><span class="line">            step4(value3, function(value4) &#123;</span><br><span class="line">                // Do something with value4</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>是不是感觉很恐怖，随着嵌套的回调函数增加，结尾会有大量的花括号和圆括号 }); 出现。(Callback 地狱)</p>
<p>在javascript中实现异步最简单的方式是Callback。遗憾的是，这种编程方式牺牲了控制流，同时你也不能throw new Error()并在外部捕获异常。 Promise的出现解决了这两个需求，又保持了javascript异步的优势，不同于Fiber这种多线程的实现方式，Promise只是一种编程方式的变化。而无须在底层改变。</p>
<p>CommonJS的规范提到了多种Promise，我们只介绍其中一种的实现q (<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a>)</p>
<p>我们在这里不讲解抽象的Promise规范，这多半是实现者应该关心的，我们直接从示例入手，如果你有兴趣，可以参见<a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a>。</p>
<p>q的核心是一个promise对象的then方法，他接受两个回调方法，一个promise被定义之后有3种状态，pending（过渡状态），fullfilled（完成状态），rejected(错误状态)。一个promise只能是这三种状态种的一种，而无法是他们的混合状态。</p>
<ul>
<li>pending状态可以理解为promise还没有获得确定值，就相当于一个任务还没有完成。</li>
<li>fullfilled状态可以理解为完成并返回结果。这时then(onFullfilled, onRejected)的onFullfilled方法会被调用。</li>
<li>rejected状态可以理解为错误，并结束。返回错误。这时then(onFullfilled, onRejected)的onRejected方法会被调用。</li>
</ul>
<p>了解了核心思想后，我们来看一个例子，在这个例子中我们先读取一个json文本文件，然后将其解析成javascript对象，最后这个对象进行修改再保存回去。 按照传统的callback写法，有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;example.json&apos;, function(err, data)&#123;</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    console.log(err):</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      var obj = JSON.parse(data);</span><br><span class="line">      obj.prop = &apos;something new&apos;;</span><br><span class="line">      fs.writeFile(&apos;example.json&apos;, JSON.stringify(obj), function(error)&#123;</span><br><span class="line">        if(err) &#123;</span><br><span class="line">          console.log(error);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&apos;success&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，控制流被切割成多个部分（每次异步都要处理一次错误），并且 <strong>JSON.parse</strong> 的错误必须在内部捕获，但却不能跑到外部。因为在异步回调中无法抛出异常。 现在当我们使用promise的时候，假设我们有个能够返回一个 <em>promise</em> 对象的 <strong>readFile</strong> 和 <strong>writeFile</strong> 方法。那么上面的代码就可以变成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var promise = readFile();</span><br><span class="line">promise</span><br><span class="line">  .then(function(data)&#123;</span><br><span class="line">  // we don&apos;t need to catch error. in other words. we can throw error in this callback.</span><br><span class="line">  var obj = JSON.parse(data);</span><br><span class="line">  obj.prop = &apos;something new&apos;;</span><br><span class="line">  // return a promise. so we can chain the then() method.</span><br><span class="line">  return writeFile(JSON.stringify(obj));</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function()&#123;</span><br><span class="line">    console.log(&apos;success&apos;);</span><br><span class="line">  &#125;, function(err)&#123;</span><br><span class="line">    // all error will fall down here.</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们首先从 <strong>readFile()</strong> 方法里获得了一个返回的 <em>promise</em> 对象，然后使用这个对象的 <strong>then()</strong> 方法。在这里，我们只传入了一个 <strong>onFullfilled</strong>回调方法，根据Promise/A+的文档。<strong>then()</strong> 一定会返回一个 <em>promise</em> 对象，所以我们又连接了一个 <strong>then()</strong> ，由于这个 <strong>then()</strong> 是最后一个，所以我们需要在这里提供一个 <strong>onRejected()</strong> 回调方法来处理所有的错误。在第一个 <strong>onFullfilled()</strong>回调方法中，我们返回了一个 <em>promise</em> ，这个 <em>promise</em> 的处理结果将会在下一个 <strong>then()</strong> 的 <strong>onFullfilled()</strong> 方法中取得。</p>
<p>这段代码执行的时候，当任意位置抛出异常的时候，最后一个then的 <strong>onRejected</strong> 回调会被执行。否则一切按照从上至下的顺序执行，整个控制流都十分简洁明了。</p>
<p>因为 <strong>then()</strong> 方法必须返回一个promise，实际上我们也可以结合同步方法返回一个已经fullfilled的promise 比如下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var promise = readFile();</span><br><span class="line">promise</span><br><span class="line">  .then(function(data)&#123;</span><br><span class="line">    return JSON.parse(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function(obj)&#123;</span><br><span class="line">    obj.prop = &apos;something new&apos;;</span><br><span class="line">    console.log(obj);</span><br><span class="line">  &#125;,function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面例子中第二个then会在第一个then返回之后被执行，因为第一个then返回的时候，由于JSON.parse是同步方法，所以返回了一个值，这个值会被包装成一个fullfilled的promise.</p>
<h4 id="制作promise的API"><a href="#制作promise的API" class="headerlink" title="制作promise的API"></a>制作promise的API</h4><p>上面例子中我们知道了如何使用promise提供的核心方法 <strong>then()</strong> 。但是对于平时使用的fs等异步的库我们要怎么才能利用promise呢。 在q的文档中介绍了q-io库，里面将常用的io方法都用promise的模式包装了一遍，在实际使用中，你可以使用那个库的方法。不过我们在这里简单的对fs进行包装，让其支持promise，这样以后遇到任何异步方法，你都可以将其转化。</p>
<p>首先定义改一个readFile方法，返回promise，这里利用了 <strong>Q</strong> 的 <strong>defer()</strong> 方法，创建一个 <em>deferred</em> 对象。这个对象有连个关键的方法 <strong>resolve</strong> 和 <strong>reject()</strong> 。当resolve(value)执行之后，promise变成fullfilled状态，fullfilled的值就是value 当 <strong>reject(reason)</strong> 执行之后，promise变成了rejected状态，reason会被传递到onRejected()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(&apos;q&apos;);</span><br><span class="line">function readFile(callback)&#123;</span><br><span class="line">  var deferred = Q.defer();</span><br><span class="line">  fs.readFile(&apos;example.json&apos;, function(err, data)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      deferred.reject(err);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      deferred.resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return deferred.promise.nodeify(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里面我们依然提供了一个callback，用于提供一些需要callback的场合的兼容性，我们利用 <em>promise</em> 对象的nodeify方法来调用这个callback，这个callback可以为undefined。</p>
<p>另外一点需要注意的是，一个promise状态改变之后，不能再次改变，所以，你只能调用一次reject或resolve。</p>
<p>有了这个API，我们便可以像前面例子里那样，使用promise来执行读取文件的操作了。其他异步回调转化成返回promise的异步方法基本上都可以参照这个模式来做。</p>
<h4 id="一次处理多个promise的"><a href="#一次处理多个promise的" class="headerlink" title="一次处理多个promise的"></a>一次处理多个promise的</h4><p>如果你有几个异步方法，他们都返回promise，并且当这些方法都处理完之后，你才能进行下一步，Q提供了一个all()方法来帮助你消化多个promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Q.all([</span><br><span class="line">  readFile(&apos;file1.json&apos;),</span><br><span class="line">  readFile(&apos;file2.json&apos;)</span><br><span class="line">  ])</span><br><span class="line">  .then(function(dataArray)&#123;</span><br><span class="line">    for(var i = 0; i &lt; dataArray.length; i++)&#123;</span><br><span class="line">      console.log(dataArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在这里例子里，我们将一个promise数组传给 <strong>all()</strong> all返回一个promise，当数组里面的所有promise都为fullfilled状态时，我们的then()方法才会被调用。这时fullfilled值是一个数组，每个元素对应前面promise的fullfilled值。 当任意一个promise变成rejected状态的时候，all的promise会立即reject而不等其他的完成。</p>
<h4 id="利用promise改写你的项目"><a href="#利用promise改写你的项目" class="headerlink" title="利用promise改写你的项目"></a>利用promise改写你的项目</h4><p>最佳的理解方法便是事件，你可以把一些nodejs的基本异步方法包装成promise，这样你就可以在整个程序的多个地方使用这些方法。并且让你的程序的异步代码看起来更整洁，更容易理解。 阅读 <a href="http://documentup.com/kriskowal/q/" target="_blank" rel="noopener">Q的文档</a> 了解更多的API和方法。并在程序中使用这些方法，使你的代码更优美，逻辑更健壮。 阅读 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a> 。了解promise原理。</p>
<h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn" target="_blank" rel="noopener">JavaScript Promise 简介</a></p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">node.js promise 简介</a></p>
<hr>
<h2 id="Intro-to-axios"><a href="#Intro-to-axios" class="headerlink" title="Intro to axios"></a>Intro to axios</h2><h2 id="Node-如何进行测试—Mocha-简介"><a href="#Node-如何进行测试—Mocha-简介" class="headerlink" title="Node 如何进行测试—Mocha 简介"></a>Node 如何进行测试—Mocha 简介</h2><h2 id="Node-入门"><a href="#Node-入门" class="headerlink" title="Node 入门"></a>Node 入门</h2><p>原文地址：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">戳这里</a></p>
<p>此文仅当作上述文档的笔记使用</p>
<p>JavaScript最早是运行在浏览器中， 然而浏览器只是提供了一个上下文， 它定义了使用JavaScript可以做什么， 但并没有“说”太多关于JavaScript语言本身可以做什么。事实上， JavaScript是一门完整的语言: 它可以使用在不同的额上下文中， 其能力与其他同类语言相比有过之而无不及。</p>
<p>Node.js 事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>
<p>要实现在后台运行JavaScript代码， 代码需要先被解释然后正确的执行。 Node.js 的原理正是如此， 它使用了Google的V8虚拟机来解释和执行JavaScript代码。</p>
<p>除此之外， 伴随着Node.js的还有许多 有用的模块， 他们可以简化很多重复的劳作， 比如向terminal输出字符串。</p>
<p>因此， Node.js事实上既是一个运行时环境， 同时又是一个库。</p>
<h3 id="一个完整的基于Node-js的web应用"><a href="#一个完整的基于Node-js的web应用" class="headerlink" title="一个完整的基于Node.js的web应用"></a>一个完整的基于Node.js的web应用</h3><h4 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h4><ul>
<li>用户可以通过浏览器使用我们的应用。</li>
<li>当用户请求<a href="http://domain.start/" target="_blank" rel="noopener">http://domain.start</a> 时， 可以看到一个欢迎界面， 页面上有一个文件上传的表单。</li>
<li>用户可以选择一个图片并提交表单， 随后文件将被上传到<a href="http://domain/ipload%EF%BC%8C" target="_blank" rel="noopener">http://domain/ipload，</a> 该页面完成上传后会把图片显示在页面上。</li>
</ul>
<h4 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h4><p>为了实现上文的用例， 我们需要实现哪些部分呢？</p>
<ul>
<li>我们需要提供Web页面， 因此需要一个HTTP服务器</li>
<li>对于不同的请求， 根据请求的URL， 我们的服务器需要给予不同的相应， 因此我们需要一个路由， 用于把请求对应到请求处理程序。</li>
<li>当请求被服务器接受并通过路由传递之后， 需要可以对其进行处理， 因此我们需要最终的请求处理程序。</li>
<li>路由还应该能处理POST数据， 并且把数据封装成更友好的格式传递给请求处理的程序， 因此需要请求数据处理功能。</li>
<li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>
<li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>
</ul>
<p>基础服务器的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(request, response) &#123;</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello World&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>
<p>由上代码，我们先接受这一点: 在JavaScript中， 一个函数可以作为另一个函数接受的参数。 我们可以先定义一个函数， 然后传递， 也可以在传递参数的地方直接定义函数（匿名函数）。</p>
<p>用下面的代码我们也可以达到同样的目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">function onRequest(request, response) &#123;</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello World&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(8888);</span><br></pre></td></tr></table></figure>
<p>那么我们为什么要使用这种方式呢？</p>
<h4 id="基于事件驱动的回调"><a href="#基于事件驱动的回调" class="headerlink" title="基于事件驱动的回调"></a>基于事件驱动的回调</h4><p>这是Node.js原生的工作方式。 它是事件驱动的， 这也是它为什么这么快的原因。</p>
<p>参考资料：<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="noopener">Understanding node.js</a></p>
<p>当我们使用http.createServer方法的时候， 我们当然不只是想要一个侦听某个端口的服务器， 我们还想它在服务器收到一个HTTP请求的时候做点什么。</p>
<p>问题是， 这是异步的： 请求任何时候都可能到达， 但是我们的服务器却跑在一个单进程中。</p>
<p>我们创建了服务器， 并且向创建它的方法传递了一个函数。 无论何时我们的服务器收到一个请求， 这个函数就会被调用。</p>
<p>我们不知道这件事情什么时候会发生， 但是我们现在有了一个处理请求的地方：它就是我们传递过去的哪个函数。 至于它是被预先定义的函数还是匿名函数， 就无关紧要了。</p>
<p>这个就是传说中的回调。 我们给某个方法传递了一个函数， 这个方法在有相应事件发生时调用这个函数来进行回调。</p>
<p>我们仍然只拥有整个应用的最初部分： 我们可以接受HTTP请求。 但是我们得做点什么–对于不同的URL请求， 服务器应该有不同的反应。</p>
<p>对于一个非常简单的应用来说， 你可以直接在回调函数<code>onRequest()</code>中做这件事情。 不过就像我所说的， 我们应该加入一些抽象的元素， 让我们的例子变得更有趣一些。</p>
<p>处理不同的HTTP请求在我们的代码中是一个不同的部分， 叫做“路由选择”—-那么， 我们接下来就创造一个叫做路由的模块吧。</p>
<h4 id="如何来进行请求的路由"><a href="#如何来进行请求的路由" class="headerlink" title="如何来进行请求的路由"></a>如何来进行请求的路由</h4><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>
<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                               url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http://localhost:8888/start?foo=bar&amp;hello=world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring(string)[&quot;foo&quot;]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring(string)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>
<p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>
<p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
<p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(pathname) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>
<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>
<p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">function start(route) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line"></span><br><span class="line">    route(pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&quot;./server&quot;);</span><br><span class="line">var router = require(&quot;./router&quot;);</span><br><span class="line"></span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<p>在这里，我们传递的函数依旧什么也没做。</p>
<p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash$ node index.js</span><br><span class="line">Request for /foo received.</span><br><span class="line">About to route a request for /foo</span><br></pre></td></tr></table></figure>
<p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>
<h4 id="路由给真正的请求处理程序"><a href="#路由给真正的请求处理程序" class="headerlink" title="路由给真正的请求处理程序"></a>路由给真正的请求处理程序</h4><p>回到正题，现在我们的 HTTP服务器和请求路由模块已经如我们的期望可以相互交流了，但是这还远远不够—我们的业务逻辑还没有实现。</p>
<p>在现在的实现下， 路由过程会在路由模块中结束， 并且路由模块并不是真正针对请求采取行动的模块，否则当我们的应用程序变得更为复杂时， 将无法很好地扩展。</p>
<p>我们暂时把作为路由目标的函数称为请求处理程序。 现在我们不要急着来开发路由模块， 因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>
<p>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把请求处理程序和路由模块连接起来， 让路由“有路可循”。</p>
<p>在这里我们得做个决定： 是将requestHandlers模块硬编码到路由里来使用， 还是再添加一点依赖注入？ 虽然和其他模式一样， 以来注入不应该仅仅为使用而使用， 但是现在这个情况下， 使用依赖注入可以让路由和请求处理程序之间的耦合更加松散， 也因此能让路由的重用性更高。</p>
<p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>
<p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<em>if request == x then call handler y</em>也使得系统丑陋不堪。</p>
<p>在C++或C#中， 当我们谈到对象， 指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类）， 会拥有不同的属性和方法。 但是在JavaScript里对象不是这个概念。 在JavaScript中， 对象就是一个键/值对的集合–你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>
<p>好了，最后再回到代码上来。 现在我们已经确定将一系列请求处理程序通过一个对象来传递， 并且需要使用松耦合的方式将这个对象注入到route（）函数中。</p>
<p>我们先将这个对象引入到主文件<em>index.js</em>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&quot;./server&quot;);</span><br><span class="line">var router = require(&quot;./router&quot;);</span><br><span class="line">var requestHandlers = require(&quot;./requestHandlers&quot;);</span><br><span class="line"></span><br><span class="line">var handle = &#123;&#125;</span><br><span class="line">handle[&quot;/&quot;] = requestHandlers.start;</span><br><span class="line">handle[&quot;/start&quot;] = requestHandlers.start;</span><br><span class="line">handle[&quot;/upload&quot;] = requestHandlers.upload;</span><br><span class="line"></span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为<em>“/“</em>的属性，对应<em>requestHandlers.start</em>即可，这样我们就可以干净简洁地配置<em>/start</em>和<em>/</em>的请求都交由<em>start</em>这一处理程序处理。</p>
<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将<em>server.js</em>修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">function start(route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line"></span><br><span class="line">    route(handle, pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>这样我们就在start（）函数里添加了handle参数， 并且把handle对象作为第一个参数传递给了route（）回调函数。</p>
<p>然后我们相应地在route.js文件中修改route()函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">  if (typeof handle[pathname] === &apos;function&apos;) &#123;</span><br><span class="line">    handle[pathname]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>我们上述程序只是实现了一个基本的框架， 即server-router-handler的模式，但是如果我们要求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”， 那就更好了。</p>
<h5 id="不好的实现方式"><a href="#不好的实现方式" class="headerlink" title="不好的实现方式"></a>不好的实现方式</h5><p>对于我们这样拥有PHP或者Ruby技术背景的开发者来说， 最直截了当的实现方式事实上并不是非常靠谱： 看似有效， 实际上未必如此。</p>
<p>这里我指的“直截了当的实现方式”意思是：让请求处理程序通过<em>onRequest</em>函数直接返回（<em>return()</em>）他们要展示给用户的信息。</p>
<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>
<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将<em>requestHandler.js</em>修改为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line">  return &quot;Hello Start&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">  return &quot;Hello Upload&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将<em>router.js</em>修改为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">  if (typeof handle[pathname] === &apos;function&apos;) &#123;</span><br><span class="line">    return handle[pathname]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname);</span><br><span class="line">    return &quot;404 Not found&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>
<p>最后，我们需要对我们的<em>server.js</em>进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">function start(route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line"></span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    var content = route(handle, pathname)</span><br><span class="line">    response.write(content);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>如果我们运行重构后的应用，一切都会工作的很好：请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>,浏览器会输出“Hello Start”，请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>会输出“Hello Upload”,而请求<a href="http://localhost:8888/foo" target="_blank" rel="noopener">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>
<p>好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。</p>
<p>没理解？没关系，下面就来详细解释下。</p>
<h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</p>
<p>我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</p>
<p>这里，我们来修改下<em>start</em>请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似<em>sleep()</em>这样的操作，所以这里只能够来点小Hack来模拟实现。</p>
<p>让我们将<em>requestHandlers.js</em>修改成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line"></span><br><span class="line">  function sleep(milliSeconds) &#123;</span><br><span class="line">    var startTime = new Date().getTime();</span><br><span class="line">    while (new Date().getTime() &lt; startTime + milliSeconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep(10000);//here we add the blocking event here.</span><br><span class="line">  return &quot;Hello Start&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">  return &quot;Hello Upload&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>上述代码中，当函数<em>start()</em>被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用<em>upload()</em>的时候，会和此前一样立即返回。</p>
<p>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>
<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>
<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>， 但是先不要打开它！</p>
<p>在第二个浏览器窗口的地址栏中输入<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>， 同样的，先不要打开它！</p>
<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>
<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然<em>也</em>花了10秒，而它在对应的请求处理程序中并没有类似于<em>sleep()</em>这样的操作！</p>
<p>这到底是为什么呢？原因就是<em>start()</em>包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<p>这显然是个问题，因为Node一向是这样来标榜自己的：<em>“在node中除了代码，所有一切都是并行执行的”</em>。</p>
<p>这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>
<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>
<p>对于Node.js来说，它是这样处理的：<em>“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</em></p>
<p>（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="noopener">理解node.js的事件轮询</a>。）</p>
<p>接下来，我们会介绍一种错误的使用非阻塞操作的方式。</p>
<p>和上次一样，我们通过修改我们的应用来暴露问题。</p>
<p>这次我们还是拿<em>start</em>请求处理程序来“开刀”。将其修改成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var exec = require(&quot;child_process&quot;).exec;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line">  var content = &quot;empty&quot;;</span><br><span class="line"></span><br><span class="line">  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) &#123;</span><br><span class="line">    content = stdout;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">  return &quot;Hello Upload&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们引入了一个新的Node.js模块，<em>child_process</em>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<em>exec()</em>。</p>
<p><em>exec()</em>做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当<em>/start</em>URL请求的时候将文件信息输出到浏览器中。</p>
<p>上述代码是非常直观的： 创建了一个新的变量<em>content</em>（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>
<p>和往常一样，我们启动服务器，然后访问“<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>” 。</p>
<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>
<p>这个时候，你可能大致已经猜到了，<em>exec()</em>在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>
<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>
<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>
<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>
<p>问题就在于，为了进行非阻塞工作，<em>exec()</em>使用了回调函数。</p>
<p>在我们的例子中，该回调函数就是作为第二个参数传递给<em>exec()</em>的匿名函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function (error, stdout, stderr) &#123;</span><br><span class="line">  content = stdout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用<em>exec()</em>之后，Node.js会立即执行 <em>return content</em> ；在这个时候，<em>content</em>仍然是“empty”，因为传递给<em>exec()</em>的回调函数还未执行到——因为<em>exec()</em>的操作是异步的。</p>
<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>
<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当<em>exec()</em>在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给<em>exec()</em>的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>
<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>
<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>
<h5 id="以非阻塞操作进行请求请求响应"><a href="#以非阻塞操作进行请求请求响应" class="headerlink" title="以非阻塞操作进行请求请求响应"></a>以非阻塞操作进行请求请求响应</h5><p>我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>
<p>不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。</p>
<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>现在我们采用如下这种新的实现方式： 相对采用将内容传递给服务器的方式， 我们这次采用将服务器传递给内容的方式。 从实践角度来说， 就是将response对象（从服务器的回调函数onRequest（）获取）通过请求路由传递给请求处理程序， 随后， 处理程序就可以采用该对象上的函数来对请求做出响应。</p>
<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>
<p>先从<em>server.js</em>开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">function start(route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line"></span><br><span class="line">    route(handle, pathname, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>相对此前从<em>route()</em>函数获取返回值的做法，这次我们将response对象作为第三个参数传递给<em>route()</em>函数，并且，我们将<em>onRequest()</em>处理程序中所有有关<em>response</em>的函数调都移除，因为我们希望这部分工作让<em>route()</em>函数来完成。</p>
<p>下面就来看看我们的<em>router.js</em>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname, response) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">  if (typeof handle[pathname] === &apos;function&apos;) &#123;</span><br><span class="line">    handle[pathname](response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname);</span><br><span class="line">    response.writeHead(404, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;404 Not found&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递<em>response</em>对象。</p>
<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>
<p>最后，我们将<em>requestHandler.js</em>修改为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var exec = require(&quot;child_process&quot;).exec;</span><br><span class="line"></span><br><span class="line">function start(response) &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line"></span><br><span class="line">  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) &#123;</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(stdout);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response) &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello Upload&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>
<p><em>start</em>处理程序在<em>exec()</em>的匿名回调函数中做请求响应的操作，而<em>upload</em>处理程序仍然是简单的回复“Hello World”，只是这次是使用<em>response</em>对象而已。</p>
<p>这时再次我们启动应用（<em>node index.js</em>），一切都会工作的很好。</p>
<p>如果想要证明<em>/start</em>处理程序中耗时的操作不会阻塞对<em>/upload</em>请求作出立即响应的话，可以将<em>requestHandlers.js</em>修改为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var exec = require(&quot;child_process&quot;).exec;</span><br><span class="line"></span><br><span class="line">function start(response) &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);</span><br><span class="line"></span><br><span class="line">  exec(&quot;find /&quot;,</span><br><span class="line">    &#123; timeout: 10000, maxBuffer: 20000*1024 &#125;,</span><br><span class="line">    function (error, stdout, stderr) &#123;</span><br><span class="line">      response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">      response.write(stdout);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response) &#123;</span><br><span class="line">  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);</span><br><span class="line">  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">  response.write(&quot;Hello Upload&quot;);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>这样一来，当请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>的时候，会花10秒钟的时间才载入，而当请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>的时候，会立即响应，纵然这个时候/start响应还在处理中。</p>
<h3 id="添加upload等功能。"><a href="#添加upload等功能。" class="headerlink" title="添加upload等功能。"></a>添加upload等功能。</h3><p>具体见：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">node.js入门</a></p>
<h2 id="常见middleware简介"><a href="#常见middleware简介" class="headerlink" title="常见middleware简介"></a>常见middleware简介</h2><h3 id="为什么使用method-override"><a href="#为什么使用method-override" class="headerlink" title="为什么使用method-override"></a>为什么使用method-override</h3><p>这个需求主要来自前端的form， 比如我们在后端提供一个针对HTTP PUT的API， 前端的数据提交时， 我们自然希望FORM能够产生一个PUT请求。 然而， 浏览器的FORM只能GET或者POST。 这个时候， 我们就需要使用method-override来帮助我们。</p>
<h3 id="Express模板传值对象-app-locals-res-locals"><a href="#Express模板传值对象-app-locals-res-locals" class="headerlink" title="Express模板传值对象 app.locals, res.locals"></a>Express模板传值对象 app.locals, res.locals</h3><p>locals是Express应用中 Application(app)对象和Response(res)对象中的属性， 该属性是一个对象。该对象的主要作用是， 将值传递到所传递的模板中。</p>
<p>locals对象会被传递到页面， 在模板中可以直接引用该对象的属性， 也可以通过该对象引用。如：<code>&lt;%= name %&gt;</code>属性同样可以通过<code>&lt;%= locals.name %&gt;</code>来引用。</p>
<h4 id="app-locals与-res-locals"><a href="#app-locals与-res-locals" class="headerlink" title="app.locals与 res.locals"></a>app.locals与 res.locals</h4><p>locals可能存在于app对象中， 即： app.locals； 也可能存在于res对象中， 即： res.locals。 两者都会将对象传递至所渲染的页面中。 不同的是， app.locals会在整个生命周期中起作用； 而res.locals只会有当前请求中起作用。 由于app.locals 在当前应用所有的渲染模中访问， 这样我们就可以在对象中定义一些顶级/全局的数据， 并在渲染模板中使用。</p>
<h2 id="Node-Express获取参数的几种方式"><a href="#Node-Express获取参数的几种方式" class="headerlink" title="Node Express获取参数的几种方式"></a>Node Express获取参数的几种方式</h2><p>Node 配合Express框架获取参数主要有以下四种反射方式：</p>
<ul>
<li>req.body</li>
<li>req.params</li>
<li>req.param()</li>
<li>req.query</li>
</ul>
<h3 id="使用场景案例"><a href="#使用场景案例" class="headerlink" title="使用场景案例"></a>使用场景案例</h3><h4 id="req-body"><a href="#req-body" class="headerlink" title="req. body"></a>req. body</h4><p><code>req.body</code>在<a href="http://expressjs.com/4x/api.html#request" target="_blank" rel="noopener">官方文档</a>是没有提供的，但是它也是很好用的获取表单参数的方法。<code>req.body</code>是<strong>配合Express中间件bodyParser()中间件</strong>提供的。当<code>bodyParser()</code>中间件使用后，这个对象默认为 <code>{}</code>,<code>req.body</code>可以获取到post到body中的内容。<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.post(&apos;/user/signup&apos;,function(req,res)&#123;</span><br><span class="line">	var _user = req.body.user;</span><br><span class="line">&#125;)</span><br><span class="line">// POST user[name]=tobi&amp;user[email]=tobi@learnboost.com</span><br><span class="line">req.body.user.name</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br><span class="line"></span><br><span class="line">req.body.user.email</span><br><span class="line">// =&gt; &quot;tobi@learnboost.com&quot;</span><br><span class="line"></span><br><span class="line">// POST &#123; &quot;name&quot;: &quot;tobi&quot; &#125;</span><br><span class="line">req.body.name</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br></pre></td></tr></table></figure>
<h4 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h4><p>这是一个数组对象， 命名过的参数会以键值对的形式存放。 比如你有一个路由<code>/user/:name</code>， name属性会存放在req.params.name. 这个对象默认为{}， 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.post(&apos;/user/signup/:userid&apos;,function(req,res)&#123;</span><br><span class="line">	req.params.userid;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="req-param-name"><a href="#req-param-name" class="headerlink" title="req.param(name)"></a>req.param(name)</h4><p>req.param() 是req.query, req.body 以及 req.params 获取参数的三种方式的封装。 req.param(name)返回name参数的值。</p>
<h4 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h4><p>这是一个解析过的请求参数对象，默认为<code>{}</code>.<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// GET /search?q=tobi+ferret</span><br><span class="line">req.query.q</span><br><span class="line">// =&gt; &quot;tobi ferret&quot;</span><br><span class="line"></span><br><span class="line">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse</span><br><span class="line">req.query.order</span><br><span class="line">// =&gt; &quot;desc&quot;</span><br><span class="line"></span><br><span class="line">req.query.shoe.color</span><br><span class="line">// =&gt; &quot;blue&quot;</span><br><span class="line"></span><br><span class="line">req.query.shoe.type</span><br><span class="line">// =&gt; &quot;converse&quot;</span><br></pre></td></tr></table></figure>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>总结出以下四点：</p>
<ol>
<li>对于path中的变量， 均可以使用 req.params.XXXXX方法</li>
<li>于get请求的<code>?xxxx=</code>,使用<code>req.query.xxxxx</code>方法</li>
<li>对于post请求中的变量，使用<code>req.body.xxxxx</code>方法</li>
<li>以上三种情形，均可以使用<code>req.param()</code>方法，所以说<code>req.param()</code>是<code>req.query</code>、<code>req.body</code>、以及<code>req.params</code>获取参数的三种方式的封装。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Node.js 学习笔记/" data-id="cjd8dst4u000dauzh7qx8477q" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java面试问题/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Java面试问题/">Java面试问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-Interview-Questions"><a href="#Java-Interview-Questions" class="headerlink" title="Java Interview Questions"></a>Java Interview Questions</h1><h2 id="What-if-the-main-method-is-declared-as-private"><a href="#What-if-the-main-method-is-declared-as-private" class="headerlink" title="What if the main method is declared as private?"></a>What if the main method is declared as private?</h2><p>The program compiles properly but at runtime it will give “Main method not public.” message.</p>
<h2 id="What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method"><a href="#What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method" class="headerlink" title="What if the static modifier is removed from the signature of the main method?"></a>What if the static modifier is removed from the signature of the main method?</h2><p>Program compiles. But at runtime throws an error “NoSuchMethodError”.</p>
<h2 id="What-if-I-write-static-public-void-instead-of-public-static-void"><a href="#What-if-I-write-static-public-void-instead-of-public-static-void" class="headerlink" title="What if I write static public void instead of public static void?"></a>What if I write static public void instead of public static void?</h2><p>Program compiles and runs properly.</p>
<h2 id="What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method"><a href="#What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method" class="headerlink" title="What if I do not provide the String array as the argument to the method?"></a>What if I do not provide the String array as the argument to the method?</h2><p>Program compiles but throws a runtime error “NoSuchMethodError”.</p>
<h2 id="What-is-the-first-argument-of-the-String-array-in-main-method"><a href="#What-is-the-first-argument-of-the-String-array-in-main-method" class="headerlink" title="What is the first argument of the String array in main method?"></a>What is the first argument of the String array in main method?</h2><p>The String array is empty. It does not have any element. This is unlike C/C++ where the first element by default is the program name.</p>
<h2 id="If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null"><a href="#If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null" class="headerlink" title="If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?"></a>If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?</h2><p>It is empty. But not null.</p>
<h2 id="How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code"><a href="#How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code" class="headerlink" title="How can one prove that the array is not null but empty using one line of code?"></a>How can one prove that the array is not null but empty using one line of code?</h2><p>Print args.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print args.length.</p>
<h2 id="What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs"><a href="#What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs" class="headerlink" title="What environment variables do I need to set on my machine in order to be able to run Java programs?"></a>What environment variables do I need to set on my machine in order to be able to run Java programs?</h2><p>CLASPATH and PATH are the two variables.</p>
<h2 id="Can-an-application-have-multiple-classes-having-main-method"><a href="#Can-an-application-have-multiple-classes-having-main-method" class="headerlink" title="Can an application have multiple classes having main method?"></a>Can an application have multiple classes having main method?</h2><p>Yes it is possible. While starting the application we mention the class name to be run. The JVM will look for the Main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.</p>
<h2 id="Can-I-have-multiple-methods-in-the-same-class"><a href="#Can-I-have-multiple-methods-in-the-same-class" class="headerlink" title="Can I have multiple methods in the same class?"></a>Can I have multiple methods in the same class?</h2><p>No the program fails to compile. The compiler says that the main method is already defined in the class.</p>
<h2 id="Do-I-need-to-import-java-lang-package-any-time-Why"><a href="#Do-I-need-to-import-java-lang-package-any-time-Why" class="headerlink" title="Do I need to import java.lang package any time? Why?"></a>Do I need to import java.lang package any time? Why?</h2><p>No. It is by default loaded internally by the JVM.</p>
<h2 id="Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime"><a href="#Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime" class="headerlink" title="Can I import same package/class twice? will the JVM load the package twice at runtime?"></a>Can I import same package/class twice? will the JVM load the package twice at runtime?</h2><p>one can import the same package or same class multiple times. Neither complier nor JVM complains about it. And the JVM will internally load the class only once no matter how many times you import the same class.</p>
<h2 id="What-are-Checked-and-UnChecked-Exception"><a href="#What-are-Checked-and-UnChecked-Exception" class="headerlink" title="What are Checked and UnChecked Exception?"></a>What are Checked and UnChecked Exception?</h2><p>A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses.<br>Making an exception checked forces client programmers to deal with the possibility that the exception will be thrown. eg, IOException thrown by java.io.FileInputStream’s read() method·<br>Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked. With an unchecked exception, however, the compiler doesn’t force client programmers either to catch the<br>exception or declare it in a throws clause. In fact, client programmers may not even know that the exception could be thrown. eg, StringIndexOutOfBoundsException thrown by String’s charAt() method· Checked exceptions must be caught at compile time. Runtime exceptions do not need to be. Errors often cannot be.</p>
<h2 id="What-is-Overriding"><a href="#What-is-Overriding" class="headerlink" title="What is Overriding?"></a>What is Overriding?</h2><p>When a class defines a method using the same name, return type, and arguments as a method in its superclass, the method in the class overrides the method in the superclass. when the method is invoked for an object of the class, it is the new definition of the method that is called,and not the method definition from the superclass. Methods may be overridden to be more public, not more private.</p>
<h2 id="What-are-different-types-of-inner-classes"><a href="#What-are-different-types-of-inner-classes" class="headerlink" title="What are different types of inner classes?"></a>What are different types of inner classes?</h2><h3 id="Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes"><a href="#Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes" class="headerlink" title="Nested top-level classes, Member classes, Local classes, Anonymous classes."></a>Nested top-level classes, Member classes, Local classes, Anonymous classes.</h3><p>参考： <a href="https://www.jianshu.com/p/3ec6aa56fe6a" target="_blank" rel="noopener">java中的四种内部类</a></p>
<h4 id="Nested-top-level-classes"><a href="#Nested-top-level-classes" class="headerlink" title="Nested top-level classes"></a>Nested top-level classes</h4><p>If you declare a class within a class and specify the static modifier, the compiler treats the class just like any other top-level class.</p>
<p>Any class outside the declaring class accesses the nested class with the declaring class name acting similarly to a package. eg, outer.inner. Top-level inner classes implicitly have access only to static variables. There can also be inner interfaces. All of these are of the nested top-level variety.</p>
<p>静态内部类也是定义在另一个类里面的类， 只不过在类的前面多了一个关键字static。 静态内部类是不需要依赖于外部类的， 这点和类的静态成员属性有点类似。并且它不能使用内部类的非static成员变量或者方法， 这点很好理解， 因为在没有外部类的对象的情况下， 可以创建静态内部类的对象， 如果允许访问外部类的非static成员就会产生矛盾， 因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">	static class Inner &#123;</span><br><span class="line">		void go() &#123;</span><br><span class="line">			System.out.println(&quot;Inner class reference is: &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer.Inner n = new Outer.Inner();</span><br><span class="line">		n.go();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Member-classes"><a href="#Member-classes" class="headerlink" title="Member classes"></a>Member classes</h4><p>Member inner classes are just like other member methods and member variables and access to the member class is restricted, just like methods and variables. This means a public member classes acts similarly to a nested top-level class. The primary difference between member classes and nested top-level classes is that member classes is that member classes have access to the specific instance of the enclosing class.</p>
<p>成员内部类， 就是作为外部类的成员， 可以直接使用外部类的所有成员和方法， 即使是private的。 同时外部类要访问内部类的所有成员变量/方法， 则需要通过内部类的对象来获取。</p>
<p>要注意的是， 成员内部类不能含有static的变量和方法。 因为成员内部类需要先创建了外部类， 才能创建它自己的。</p>
<p>在成员内部类要引用外部类对象时， 使用outer.this 来表示外部类对象； 创建内部类对象， 可以使用 outer.inner obj= outerobj. new innier();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int x = 100;</span><br><span class="line"> </span><br><span class="line">    public void makeInner()&#123;</span><br><span class="line">        Inner in = new Inner();</span><br><span class="line">        in.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Inner&#123;</span><br><span class="line">        public void seeOuter()&#123;</span><br><span class="line">            System.out.println(&quot;Outer x is &quot; + x);</span><br><span class="line">            System.out.println(&quot;Inner class reference is &quot; + this);</span><br><span class="line">            System.out.println(&quot;Outer class reference is &quot; + Outer.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">    	Outer o = new Outer();</span><br><span class="line">        Inner i = o.new Inner();</span><br><span class="line">        i.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Local-classes"><a href="#Local-classes" class="headerlink" title="Local classes"></a>Local classes</h4><p>Local classes are like local variables, specific to a block of code. Their visibility is only within the block of their declaration. In order for the class to be useful beyond the declaration block, it would need to implement a more publicly available interface.Because local classes are not members, the modifiers public, protected, private, and static are not usable.</p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类， 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">	private String x = &quot;outer&quot;;</span><br><span class="line"> </span><br><span class="line">	public void doStuff() &#123;</span><br><span class="line">		class MyInner &#123;</span><br><span class="line">			public void seeOuter() &#123;</span><br><span class="line">				System.out.println(&quot;x is &quot; + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		MyInner i = new MyInner();</span><br><span class="line">		i.seeOuter();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer o = new Outer();</span><br><span class="line">		o.doStuff();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Anonymous-classes"><a href="#Anonymous-classes" class="headerlink" title="Anonymous classes"></a>Anonymous classes</h4><p>Anonymous inner classes extend local inner classes one level further. As anonymous classes have no name, you cannot provide a constructor.</p>
<p>匿名内部类最常使用的情况就是在多线程的实现上， 因为要实现多线程必须继承Thread类或者实现Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(new ActionListener()&#123;</span><br><span class="line">     public void actionPerformed(ActionEvent e)&#123;</span><br><span class="line">         comp.setText(&quot;Button has been clicked&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="What-is-the-difference-between-an-Interface-and-an-abstract-class"><a href="#What-is-the-difference-between-an-Interface-and-an-abstract-class" class="headerlink" title="What is the difference between an Interface and an abstract class?"></a>What is the difference between an Interface and an abstract class?</h2><p>An abstract class can have instance methods that implement a default behavior. An Interface can only declare constants and instance methods, but cannot implements default behavior and all methods are implicitly abstract . An interface has all public members and no implementation. Am abstract class is a class which may have the usual flavors of class members(private , protected, etc.), but has some abstract methods.</p>
<p>抽象类是用来捕捉子类中的通用特性的。 它不能被实例化， 只能被用作子类的超类。 抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;</span><br><span class="line">    // abstract method</span><br><span class="line">    abstract void service(ServletRequest req, ServletResponse res);</span><br><span class="line"> </span><br><span class="line">    void init() &#123;</span><br><span class="line">        // Its implementation</span><br><span class="line">    &#125;</span><br><span class="line">    // other method related to Servlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当HttpServlet类继承GenericServlet 时， 它提供了service方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServlet extends GenericServlet &#123;</span><br><span class="line">    void service(ServletRequest req, ServletResponse res) &#123;</span><br><span class="line">        // implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // some other methods related to HttpServlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是抽象方法的集合。 如果一个类实现了某个接口， 那么它就继承了这个接口的抽象方法。 这就像契约模式， 如果实现了这个接口， 那么就必须确保使用这些方法。 接口只是一种形式， 接口自身不能做任何事情。 以Externalizable接口为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Externalizable extends Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    void writeExternal(ObjectOutput out) throws IOException;</span><br><span class="line"> </span><br><span class="line">    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你实现这个接口时， 你就需要实现上面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements Externalizable &#123;</span><br><span class="line"> </span><br><span class="line">    int employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<p>Oracle已经开始尝试向接口中引入默认方法和静态方法， 以此来减少抽象类和接口之间的差异。 现在， 我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。</p>
<h2 id="Describe-synchronization-in-respect-to-multithreading"><a href="#Describe-synchronization-in-respect-to-multithreading" class="headerlink" title="Describe synchronization in respect to multithreading."></a>Describe synchronization in respect to multithreading.</h2><p>With respect to multithreading, synchronization is the capability to control the access of multiple threads to shared resources. Without synchronization, it is possible for one thread to modify a shared variables while another thread is in the process of using or updating same shared variable. This usually leads to significant errors.</p>
<h2 id="Explain-different-way-of-using-thread"><a href="#Explain-different-way-of-using-thread" class="headerlink" title="Explain different way of using thread?"></a>Explain different way of using thread?</h2><p>The thread could be implemented by using runnable interface or by inheriting from the Thread class. The former is more advantageous, ‘cause when you are going for multiple inheritance, the only interface can help.</p>
<h2 id="Difference-between-HashMap-and-HashTable"><a href="#Difference-between-HashMap-and-HashTable" class="headerlink" title="Difference between HashMap and HashTable?"></a>Difference between HashMap and HashTable?</h2><p>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesnt allow). HashMap does not guarantee that the order of the map will remain constant over time. HashMap is unsynchronized and Hashtable is synchronized.</p>
<h2 id="What-is-the-difference-between-a-constructor-and-a-method"><a href="#What-is-the-difference-between-a-constructor-and-a-method" class="headerlink" title="What is the difference between a constructor and a method?"></a>What is the difference between a constructor and a method?</h2><p>A constructor is a member function of a class that is used to create objects of that class. It has the same name as the class itself, has no return type, and is invoked using the new operator.<br>A method is an ordinary member function of a class. It has its own name, a return type (which may be void), and is invoked using the dot operator.</p>
<h2 id="What-is-an-Iterator"><a href="#What-is-an-Iterator" class="headerlink" title="What is an Iterator?"></a>What is an Iterator?</h2><p>Some of the collection classes provide traversal of their contents via a java.util.Iterator interface. This interface allows you to walk through a collection of objects, operating on each object in turn. Remember when using Iterators that they contain a snapshot of the collection at the time the Iterator was obtained; generally it is not advisable to modify the collection itself while traversing an Iterator.</p>
<h2 id="State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers"><a href="#State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers" class="headerlink" title="State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers."></a>State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers.</h2><p><strong><em>public : \</em></strong>Public class is visible in other packages, field is visible everywhere (class must be public too)<br><strong><em>private :\</em></strong> Private variables or methods may be used only by an instance of the same class that declares the variable or method, A private feature may only be accessed by the class that owns the feature.<br><strong><em>protected :\</em></strong> Is available to all classes in the same package and also available to all subclasses of the class that owns the protected feature.This access is provided even to subclasses that reside in a different package from the class that owns the protected feature.<br><strong><em>default :\</em></strong>What you get by default ie, without any access modifier (ie, public private or protected).It means that it is visible to all within a particular package.</p>
<h2 id="What-is-static-in-Java"><a href="#What-is-static-in-Java" class="headerlink" title="What is static in Java?"></a>What is static in Java?</h2><p>static means one per class, not one for each object no matter how many instance of a class might exist. This means that you can use them without creating an instance of a class. Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can’t override a static method with a non-static method. In other words, you can’t change a static method into an instance method in a subclass.</p>
<p>Static methods can be overriden, but they cannot be overriden to be non-static,Whereas final methods cannot be overridden.</p>
<p>A static method is a method that’s invoked through a class, rather than a specific object of that class. Static methods can only access static variables – they can’t use anything that’s specific to a particular object. Nonstatic methods (or instance methods) must be called on a specific object and can use the object’s instance data.<br>A final method is just a method that cannot be overridden – while static methods are implicitly final, you might also want to create an final instance method.</p>
<p>In this code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the static method in Bar ‘hides’ the static method declared in Foo, as opposed to overriding it in the polymorphism sense.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Foo.method();</span><br><span class="line">        Bar.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>will output:</p>
<p>in Foo<br>in Bar</p>
<p>Re-defining method() as final in Foo will disable the ability for Bar to hide it, and re-running main() will output:</p>
<p>in Foo<br>in Foo</p>
<p>Compilation fails when you mark the method as final, and only runs again when remove Bar.method()</p>
<p>Final will prevent the method from being hidden by subclasses .</p>
<h2 id="Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests"><a href="#Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests" class="headerlink" title="Does importing a package imports the subpackages as well? e.g. Does importing com.Test. also import com.MyTest.UnitTests.?"></a>Does importing a package imports the subpackages as well? e.g. Does importing com.Test.<em> also import com.MyTest.UnitTests.</em>?</h2><p>No you will have to import the subpackage explicitly. Importing com.MyTest.* will import classes in the package MyTest only. It will not import any class in any of it’s subpackage.</p>
<h2 id="What-is-serialization"><a href="#What-is-serialization" class="headerlink" title="What is serialization?"></a>What is serialization?</h2><p>Serialization is a mechanism by which you can save the state of an object by converting it to a byte stream.</p>
<p>The serializable interface is an empty interface. It does not contain any methods. So we do not implement ant methods.</p>
<h2 id="What-is-the-common-usage-of-serialization"><a href="#What-is-the-common-usage-of-serialization" class="headerlink" title="What is the common usage of serialization?"></a>What is the common usage of serialization?</h2><p>Whenever an object is to be sent over the network, objects need to be serialized. Moreover if the state of an object is to be saved, objects need to be serialized.</p>
<h2 id="What-are-wrapper-classes"><a href="#What-are-wrapper-classes" class="headerlink" title="What are wrapper classes?"></a>What are wrapper classes?</h2><p>java provides specialized classes corresponding to each of the primitive data types. These are called wrapper classes. They are e.g. Integer, Character, Double etc.</p>
<h2 id="What-are-the-different-ways-to-handle-exceptions"><a href="#What-are-the-different-ways-to-handle-exceptions" class="headerlink" title="What are the different ways to handle exceptions?"></a>What are the different ways to handle exceptions?</h2><p>There are two ways to handle exceptions,</p>
<ol>
<li>By wrapping the desired code in a try block followed by a catch block to catch the exceptions.</li>
<li>Lit the desired exceptions in the throws clause of the method and let the caller of the method handle those exceptions.</li>
</ol>
<h2 id="Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block"><a href="#Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block" class="headerlink" title="Is it necessary that each try block must be followed by a catch block?"></a>Is it necessary that each try block must be followed by a catch block?</h2><p>It is not necessary that each catch block must be followed by a catch block. It should be followed by either a catch block or a finally block. And whatever exceptions are likely to be thrown should be declared in the throws clause if the method.</p>
<h2 id="If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt"><a href="#If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt" class="headerlink" title="If I write return at the end of the try block, will the finally block still execute&gt;"></a>If I write return at the end of the try block, will the finally block still execute&gt;</h2><p>Yes even if you write return as the last statement in the try block and no exception occurs, the finally block will execute. The finally block will execute and then the control system.</p>
<h2 id="If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute"><a href="#If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute" class="headerlink" title="If I write System.exit (0); at the end of the try block, will the finally block still execute?"></a>If I write System.exit (0); at the end of the try block, will the finally block still execute?</h2><p>No in this case the finally block will not execute because when you say System.exit (0); the control immediately goes out of the program, and thus finally never executes.</p>
<h2 id="Can-a-java-file-contain-more-than-one-java-classes"><a href="#Can-a-java-file-contain-more-than-one-java-classes" class="headerlink" title="Can a .java file contain more than one java classes?"></a>Can a .java file contain more than one java classes?</h2><p>Yes, a .java file contain more than one java classes, provided at the most one of of them is a public class.</p>
<h2 id="What-is-the-default-value-of-the-local-variables"><a href="#What-is-the-default-value-of-the-local-variables" class="headerlink" title="What is the default value of the local variables?"></a><strong>What is the default value of the local variables?</strong></h2><p>The local variables are not initialized to any default value, neither primitives nor object references. If you try to use these variables without initializing them explicitly, the java compiler will not compile the code. It will complain abt the local variable not being initialized.</p>
<h2 id="Can-we-Overload-main-method"><a href="#Can-we-Overload-main-method" class="headerlink" title="Can we Overload main() method?"></a>Can we Overload main() method?</h2><p>Yes. We can overload main() method. A java class can have any number of main() methods. But to run the java class. class should have main() method with signature as “public static void main(String[] args)”. If you do any modification to this signature, compilation will be successful. But, you can’t run the java program. You will get run time error as main method not found.</p>
<h2 id="Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier"><a href="#Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier" class="headerlink" title="Can we declare main() method as private or protected or with no access modifier?"></a>Can we declare main() method as private or protected or with no access modifier?</h2><p>No, main() method must be public. You can’t define main() methods as private or protected or with no access modifier. This is because to make the main() method accessible to JVM. If you define main() method other than public, compilation will be successful but you will get run time error as no main method found.</p>
<h2 id="Can-we-Declare-main-Method-As-Non-Static"><a href="#Can-we-Declare-main-Method-As-Non-Static" class="headerlink" title="Can we Declare main() Method As Non-Static?"></a>Can we Declare main() Method As Non-Static?</h2><p>No, main() method must be declared as static so than JVM can call main() method without instantiating it’s class. If you remove “static” from main() method signature, compilation will be successful but program fails at run time.</p>
<h2 id="Can-we-change-return-type-of-main-method"><a href="#Can-we-change-return-type-of-main-method" class="headerlink" title="Can we change return type of main() method?"></a>Can we change return type of main() method?</h2><p>No. The return type of main() method must be void only. Any other type is not acceptable.</p>
<h2 id="Can-we-run-java-class-without-main-method"><a href="#Can-we-run-java-class-without-main-method" class="headerlink" title="Can we run java class without main() method?"></a>Can we run java class without main() method?</h2><p>No, you can’t run java class without main method. But, there are some scenarios like if super class has main() method. then sub class can be run without defining main() method in it.</p>
<h3 id="What-is-Thread-in-Java"><a href="#What-is-Thread-in-Java" class="headerlink" title="What is Thread in Java?"></a>What is Thread in Java?</h3><p>The thread is an independent path of execution. It’s way to take advantage of multiple CPU available in a machine. By employing multiple threads you can speed up CPU bound task. For example, if one thread takes 100 milliseconds to do a job, you can use 10 threads to reduce that task into 10 milliseconds. Java provides excellent support for multithreading at the language level, and it’s one of the strong selling points.</p>
<h3 id="What-is-the-difference-between-Thread-and-Process-in-Java"><a href="#What-is-the-difference-between-Thread-and-Process-in-Java" class="headerlink" title="What is the difference between Thread and Process in Java?"></a>What is the difference between Thread and Process in Java?</h3><p>The thread is a subset of Process, in other words, one process can contain multiple threads. Two process runs on different memory space, but all threads share same memory space. Don’t confuse this with stack memory, which is different for the different thread and used to store local data to that thread.</p>
<h3 id="How-do-you-implement-Thread-in-Java"><a href="#How-do-you-implement-Thread-in-Java" class="headerlink" title="How do you implement Thread in Java?"></a>How do you implement Thread in Java?</h3><p>At the language level, there are two ways to implement Thread in Java. An instance of java.lang.Thread represent a thread but it needs a task to execute, which is an instance of interface java.lang.Runnable. Since Thread class itself implement Runnable, you can override run() method by extending Thread class or just implementing Runnable interface.</p>
<h3 id="When-to-use-Runnable-vs-Thread-in-Java"><a href="#When-to-use-Runnable-vs-Thread-in-Java" class="headerlink" title="When to use Runnable vs Thread in Java?"></a>When to use Runnable vs Thread in Java?</h3><p>This question will be easy to answer if you know that Java programming language doesn’t support multiple inheritances of class, but it allows you to implement multiple interfaces. Which means, it’s better to implement Runnable then extends Thread if you also want to extend another class.</p>
<h3 id="What-is-the-difference-between-start-and-run-method-of-Thread-class"><a href="#What-is-the-difference-between-start-and-run-method-of-Thread-class" class="headerlink" title="What is the difference between start() and run() method of Thread class?"></a>What is the difference between start() and run() method of Thread class?</h3><p>start() method is used to start newly created thread, while start() internally calls run() method, there is difference calling run() method directly. When you invoke run() as normal method, it’s called in the same thread, no new thread is started, which is the case when you call start() method.</p>
<h3 id="What-is-the-difference-between-Runnable-and-Callable-in-Java"><a href="#What-is-the-difference-between-Runnable-and-Callable-in-Java" class="headerlink" title="What is the difference between Runnable and Callable in Java?"></a>What is the difference between Runnable and Callable in Java?</h3><p>Both Runnable and Callable represent task which is intended to be executed in a separate thread. Runnable is there from JDK 1.0 while Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. See my <a href="http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html" target="_blank" rel="noopener">blog post</a> on the same topic for a more in-depth answer to this question.</p>
<h3 id="What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java"><a href="#What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java" class="headerlink" title="What is the difference between CyclicBarrier and CountDownLatch in Java?"></a>What is the difference between CyclicBarrier and CountDownLatch in Java?</h3><p>Though both CyclicBarrier and CountDownLatch wait for number of threads on one or more events, the main difference between them is that you can not re-use CountDownLatch once count reaches to zero, but you can reuse same CyclicBarrier even after barrier is broken.</p>
<h3 id="What-is-volatile-variable-in-Java"><a href="#What-is-volatile-variable-in-Java" class="headerlink" title="What is volatile variable in Java?"></a>What is volatile variable in Java?</h3><p>volatile is a special modifier, which can only be used with instance variables. In concurrent Java programs, changes made by multiple threads on instance variables is not visible to other in absence of any synchronizers e.g. synchronized keyword or locks. Volatile variable guarantees that a write will happen before any subsequent read: as stated:”volatile variable rule”.</p>
<h3 id="What-is-thread-safety-is-a-Vector-a-thread-safe-class"><a href="#What-is-thread-safety-is-a-Vector-a-thread-safe-class" class="headerlink" title="What is thread-safety? is a Vector a thread-safe class?"></a>What is thread-safety? is a Vector a thread-safe class?</h3><p>Thread-safety is a property of an object or code which guarantees that if executed or used by multiple threads in any manner. For example, a thread-safe counter object will not miss any count if same instance of that counter is shared among multiple threads. Apparently, you can also divide collection classes in two category, thread-safe and non-thread-safe. Vector is indeed a thread-safe class and it achieves thread-safety by synchronizing methods which modify state of Vector, on the other hand, its counterpart ArrayList is not thread-safe.</p>
<h3 id="How-to-stop-a-thread-in-Java"><a href="#How-to-stop-a-thread-in-Java" class="headerlink" title="How to stop a thread in Java?"></a>How to stop a thread in Java?</h3><p>I always said that Java provides rich APIs for everything but ironically Java doesn’t provide a sure shot way of stopping thread. There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which was deprecated in later releases due to potential deadlock threats, from then Java API designers has not made any effort to provide a consistent, thread-safe and elegant way to stop threads. Programmers mainly rely on the fact that thread stops automatically as soon as they finish execution of run() or call() method. To manually stop, programmers either take advantage of volatile boolean variable and check in every iteration if run method has loops or interrupt threads to abruptly cancel tasks. See this <a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="noopener">tutorial</a> for sample code of stopping thread in Java.</p>
<h3 id="What-happens-when-an-Exception-occurs-in-a-thread"><a href="#What-happens-when-an-Exception-occurs-in-a-thread" class="headerlink" title="What happens when an Exception occurs in a thread?"></a>What happens when an Exception occurs in a thread?</h3><p>This is one of the good <a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="noopener">tricky Java question</a> I have seen in interviews. In simple words, If not caught thread will die, if an uncaught exception handler is registered then it will get a call back. Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments.</p>
<h3 id="What-is-the-difference-between-notify-and-notifyAll-in-Java"><a href="#What-is-the-difference-between-notify-and-notifyAll-in-Java" class="headerlink" title="What is the difference between notify and notifyAll in Java?"></a>What is the difference between notify and notifyAll in Java?</h3><p>This is another tricky questions from core Java interviews, since multiple threads can wait on single monitor lock, Java API designer provides method to inform only one of them or all of them, once waiting condition changes, but they provide half implementation. There notify() method doesn’t provide any way to choose a particular thread, that’s why its only useful when you know that there is only one thread is waiting. On the other hand, notifyAll() sends notification to all threads and allows them to compete for locks, which ensures that at-least one thread will proceed further. See my <a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="noopener">blog post</a> on similar topic for a more detailed answer and code example.</p>
<h3 id="Why-wait-notify-and-notifyAll-are-not-inside-thread-class"><a href="#Why-wait-notify-and-notifyAll-are-not-inside-thread-class" class="headerlink" title="Why wait, notify and notifyAll are not inside thread class?"></a>Why wait, notify and notifyAll are not inside thread class?</h3><p>This is a design related question, which checks what candidate thinks about existing system or does he ever thought of something which is so common but looks in-appropriate at first. In order to answer this question, you have to give some reasons why it make sense for these three method to be in Object class, and why not on Thread class. One reason which is obvious is that Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object.</p>
<h3 id="What-is-ThreadLocal-variable-in-Java"><a href="#What-is-ThreadLocal-variable-in-Java" class="headerlink" title="What is ThreadLocal variable in Java?"></a>What is ThreadLocal variable in Java?</h3><p>ThreadLocal variables are special kind of variable available to Java programmer. Just like instance variable is per instance, ThreadLocal variable is per thread. It’s a nice way to achieve thread-safety of expensive-to-create objects, for example you can make SimpleDateFormat thread-safe using ThreadLocal. Since that class is expensive, its not good to use it in local scope, which requires separate instance on each invocation. By providing each thread their own copy, you shoot two birds with one arrow. First, you reduce number of instance of expensive object by reusing fixed number of instances, and Second, you achieve thread-safety without paying cost of synchronization or immutability. Another good example of thread local variable is ThreadLocalRandom class, which reduces number of instances of expensive-to-create Random object in multi-threading environment. See this <a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="noopener">answer</a> to learn more about thread local variables in Java.</p>
<h3 id="What-is-FutureTask-in-Java"><a href="#What-is-FutureTask-in-Java" class="headerlink" title="What is FutureTask in Java?"></a>What is FutureTask in Java?</h3><p>FutureTask represents a cancellable asynchronous computation in concurrent Java application. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get methods will block if the computation has not yet completed. A FutureTask object can be used to wrap a Callable or Runnable object. Since FutureTask also implements Runnable, it can be submitted to an Executor for execution.</p>
<h3 id="What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java"><a href="#What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java" class="headerlink" title="What is the difference between the interrupted() and isInterrupted() method in Java?"></a>What is the difference between the interrupted() and isInterrupted() method in Java?</h3><p>Main difference between interrupted() and isInterrupted() is that former clears the interrupt status while later does not. The interrupt mechanism in Java multi-threading is implemented using an internal flag known as the interrupt status. Interrupting a thread by calling Thread.interrupt() sets this flag. When interrupted thread checks for an interrupt by invoking the <a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="noopener">static method</a> Thread.interrupted(), interrupt status is cleared. The non-static isInterrupted() method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag. By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it’s always possible that interrupt status will immediately be set again, by another thread invoking interrupt</p>
<h3 id="Why-wait-and-notify-method-are-called-from-synchronized-block"><a href="#Why-wait-and-notify-method-are-called-from-synchronized-block" class="headerlink" title="Why wait and notify method are called from synchronized block?"></a>Why wait and notify method are called from synchronized block?</h3><p>Main reason for calling wait and notify method from either synchronized block or method is that it made mandatory by Java API. If you don’t call them from synchronized context, your code will throw IllegalMonitorStateException. A more subtle reason is to avoid the race condition between wait and notify calls.</p>
<h3 id="What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java"><a href="#What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java" class="headerlink" title="What is the difference between synchronized and concurrent collection in Java?"></a>What is the difference between synchronized and concurrent collection in Java?</h3><p>Though both synchronized and concurrent collection provides thread-safe collection suitable for multi-threaded and concurrent access, later is more scalable than former. Before Java 1.5, Java programmers only had synchronized collection which becomes source of contention if multiple thread access them concurrently, which hampers scalability of system. Java 5 introduced concurrent collections like ConcurrentHashMap, which not only provides thread-safety but also improves scalability by using modern techniques like lock stripping and partitioning internal table.</p>
<h3 id="What-is-the-difference-between-Stack-and-Heap-in-Java"><a href="#What-is-the-difference-between-Stack-and-Heap-in-Java" class="headerlink" title="What is the difference between Stack and Heap in Java?"></a>What is the difference between Stack and Heap in Java?</h3><p>Why does someone this question as part of multi-threading and concurrency? because Stack is a memory area which is closely associated with threads. To answer this question, both stack and heap are specific memories in Java application. Each thread has their own stack, which is used to store local variables, method parameters and call stack. Variable stored in one Thread’s stack is not visible to other. On another hand, the heap is a common memory area which is shared by all threads. Objects whether local or at any level is created inside heap. To improve performance thread tends to cache values from heap into their stack, which can create problems if that variable is modified by more than one thread, this is where volatile variables come into the picture. volatile suggest threads read the value of variable always from main memory.</p>
<h3 id="What-is-thread-pool-Why-should-you-thread-poll-in-Java"><a href="#What-is-thread-pool-Why-should-you-thread-poll-in-Java" class="headerlink" title="What is thread pool? Why should you thread poll in Java?"></a>What is thread pool? Why should you thread poll in Java?</h3><p>Creating thread is expensive in terms of time and resource. If you create thread at time of request processing it will slow down your response time, also there is only a limited number of threads a process can create. To avoid both of these issues, a pool of thread is created when application starts-up and threads are reused for request processing. This pool of thread is known as “thread pool” and threads are known as worker thread. From JDK 1.5 release, Java API provides Executor framework, which allows you to create different types of thread pools e.g. single thread pool, which process one task at a time, fixed thread pool (a pool of fixed number of threads) or cached thread pool (an expandable thread pool suitable for applications with many short lived tasks).</p>
<h3 id="How-do-you-check-if-a-Thread-holds-a-lock-or-not"><a href="#How-do-you-check-if-a-Thread-holds-a-lock-or-not" class="headerlink" title="How do you check if a Thread holds a lock or not?"></a>How do you check if a Thread holds a lock or not?</h3><p>I didn’t even know that you can check if a Thread already holds lock before this question hits me in a telephonic round of Java interview. There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object.</p>
<h3 id="What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java"><a href="#What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java" class="headerlink" title="What is the difference between synchronized and ReentrantLock in Java?"></a>What is the difference between synchronized and ReentrantLock in Java?</h3><p>There were days when the only way to provide mutual exclusion in Java was via synchronized keyword, but it has several shortcomings e.g. you can not extend lock beyond a method or block boundary, you can not give up trying for a lock etc. Java 5 solves this problem by providing more sophisticated control via Lock interface. ReentrantLock is a common implementation of Lock interface and provides re-entrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p>
<h3 id="There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java"><a href="#There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java" class="headerlink" title="There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?"></a>There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?</h3><p>Sequencing in multi-threading can be achieved by different means but you can simply use the join() method of thread class to start a thread when another one has finished its execution. To ensure three threads execute you need to start the last one first e.g. T3 and then call join methods in reverse order e.g. T3 calls T2. join and T2 calls T1.join, these ways T1 will finish first and T3 will finish last.</p>
<h3 id="What-does-yield-method-of-Thread-class-do"><a href="#What-does-yield-method-of-Thread-class-do" class="headerlink" title="What does yield method of Thread class do?"></a>What does yield method of Thread class do?</h3><p>Yield method is one way to request current thread to relinquish CPU so that other thread can get a chance to execute. Yield is a static method and only guarantees that current thread will relinquish the CPU but doesn’t say anything about which other thread will get CPU. Its possible for the same thread to get CPU back and start its execution again.</p>
<h3 id="What-is-Semaphore-in-Java"><a href="#What-is-Semaphore-in-Java" class="headerlink" title="What is Semaphore in Java?"></a>What is Semaphore in Java?</h3><p>Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool.</p>
<h3 id="What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled"><a href="#What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled" class="headerlink" title="What happens if you submit a task when the queue of the thread pool is already filled?"></a>What happens if you submit a task when the queue of the thread pool is already filled?</h3><p>This is another tricky question on my list. Many programmers will think that it will block until a task is cleared but its true. ThreadPoolExecutor’s submit() method throws RejectedExecutionException if the task cannot be scheduled for execution.</p>
<h3 id="What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java"><a href="#What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java" class="headerlink" title="What is the difference between the submit() and execute() method thread pool in Java?"></a>What is the difference between the submit() and execute() method thread pool in Java?</h3><p>Both methods are ways to submit a task to thread pools but there is a slight difference between them. execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. Its return type is void. On other hand submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods.</p>
<h3 id="What-is-ReadWriteLock-in-Java"><a href="#What-is-ReadWriteLock-in-Java" class="headerlink" title="What is ReadWriteLock in Java?"></a>What is ReadWriteLock in Java?</h3><p>In general, read write lock is the result of lock stripping technique to improve the performance of concurrent applications. In Java, ReadWriteLock is an interface which was added in Java 5 release. A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive. If you want you can implement this interface with your own set of rules, otherwise you can use ReentrantReadWriteLock, which comes along with JDK and supports a maximum of 65535 recursive write locks and 65535 read locks.</p>
<h3 id="What-is-the-difference-between-the-volatile-and-atomic-variable-in-java"><a href="#What-is-the-difference-between-the-volatile-and-atomic-variable-in-java" class="headerlink" title="What is the difference between the volatile and atomic variable in java?"></a>What is the difference between the volatile and atomic variable in java?</h3><p>This is an interesting question for Java programmer, at first, volatile and atomic variable look very similar, but they are different. Volatile variable provides you happens-before guarantee that a write will happen before any subsequent write, it doesn’t guarantee atomicity. For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly you have atomic version for other data type and reference variable as well.</p>
<h3 id="What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block"><a href="#What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block" class="headerlink" title="What happens if a thread throws an Exception inside synchronized block?"></a>What happens if a thread throws an Exception inside synchronized block?</h3><p>This is one more tricky question for average Java programmer, if he can bring the fact about whether lock is released or not is a key indicator of his understanding. To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a <a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="noopener">finally block</a>.</p>
<h3 id="What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading"><a href="#What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading" class="headerlink" title="What is the difference between calling wait() and sleep() method in Java multi-threading?"></a>What is the difference between calling wait() and sleep() method in Java multi-threading?</h3><p>Though both wait and sleep introduce some form of pause in Java application, they are the tool for different needs. Wait method is used for inter-thread communication, it relinquishes lock if waiting for a condition is true and wait for notification when due to an action of another thread waiting condition becomes false. On the other hand sleep() method is just to relinquish CPU or stop execution of current thread for specified time duration. Calling sleep method doesn’t release the lock held by the current thread.</p>
<p>中文版： <a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">http://www.importnew.com/12773.html</a></p>
<p>When you synchronize a method, you are effectively synchronizing to the object itself. In the case of a static method, you’re synchronizing to the class of the object.</p>
<h3 id="how-does-Java-object-casting-work-behind-the-scene"><a href="#how-does-Java-object-casting-work-behind-the-scene" class="headerlink" title="how does Java object casting work behind the scene?"></a>how does Java object casting work behind the scene?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class parent&#123;</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends parent&#123;</span><br><span class="line">  @override</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent p= new Parent();</span><br><span class="line">Child c= (Child) p;</span><br></pre></td></tr></table></figure>
<p>Essentially the parent class is treated like an interface might be. when you cast the child to the Parent, only the Parent API is available. However, the overridden method will still be called. So , if you do:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent p= (Parent) new Child()</span><br><span class="line">p.a()</span><br></pre></td></tr></table></figure>
<p>the Child’s public void a() will be called, even though it is being seem through the lens of the Parent class. However if you were to have a second method in the Child that the parent does not have, you would not be able to call that without casting the object back to a Child.</p>
<h3 id="hashcode-and-equals"><a href="#hashcode-and-equals" class="headerlink" title="hashcode() and equals()"></a>hashcode() and equals()</h3><p>我们以“类的用途”来讲hashCode()和equals()的关系分两种情况来说明。</p>
<ul>
<li><p>第一种， 不会创建类所对应的散列表</p>
<p>这里所说的不会创建类所对应的散列表是说： 我们不会在HashSet, hashTable, HashMap等等这些本质是散列表的数据结构中， 用到此类。</p>
<p>在这种情况下， 该类的hashCode()和equals没有关系。</p>
<p>在这种情况下， equals()用来比较该类的两个对象是否相等。 而hashCode()则根本没有任何作用， 所以不用理会hashcode()</p>
</li>
<li><p>第二种， 会创建类所对应的散列表</p>
<p>这里所说的会创建类对应的散列表是说， 我们会在hashset， hashtable， hashtable等等这些本质是散列表的数据结构中， 用到该类。</p>
<p>在这种情况下， 该类的hashCode() 和 equals()是有关系的:</p>
<ul>
<li><p>如果两个对象相等， 那么它们的hashCode()值一定相同。</p>
<p>这里的相等是指， 通过equals()比较两个对象时返回true。</p>
</li>
<li><p>如果两个对象hashCode()相等， 它们并不一定相等。</p>
</li>
</ul>
<p>因为在散列表中， hashcode()相等， 即两个键值对的哈希值相等， 然而哈希值相等， 并不一定能得出键值对相等。</p>
<p>此外， 在这种情况下， 若要判断两个对象是否相等， 除了要覆盖equals之外， 也要覆盖hashCode()函数。 否则， equals()无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest2&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        Person p4 = new Person(&quot;EEE&quot;, 100);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象 </span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 比较p1 和 p4， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc重写hashCode </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode()&#123;  </span><br><span class="line">            int nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">            return nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc 覆盖equals方法 </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;  </span><br><span class="line">            if(obj == null)&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //如果是同一个对象返回true，反之返回false  </span><br><span class="line">            if(this == obj)&#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //判断是否类型相同  </span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>这里有个比较好的例子， 由这个例子， 我们可以看出来， 因为通过这个来讲的话， hashset在进行add的时候， 我们先比较hashcode， 然后再进行equal。 所以， hashcode这个只和分桶有关， 我们还要通过equals的比较才能进行更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java面试问题/" data-id="cjd8dst4t000bauzhrp2sg99g" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-中HashMap的实现机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java-中HashMap的实现机制/" class="article-date">
  <time datetime="2018-02-04T05:53:02.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Java-中HashMap的实现机制/">Java 中HashMap的实现机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="The-Implementation-of-HashMap-in-Java"><a href="#The-Implementation-of-HashMap-in-Java" class="headerlink" title="The Implementation of HashMap in Java"></a>The Implementation of HashMap in Java</h1><p><a href="http://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="noopener">Java 源码阅读</a></p>
<p>HashMap是基于哈希表的Map接口的非同步实现。 此实现提供所有可选的映射操作， 并允许使用null值和null键。 此类不保证映射的顺序， 特别是它不保证该顺序恒久不变。</p>
<p><em>HashMap与HashTable的主要区别</em></p>
<p><em>他们的主要区别其实就是Table加了线程同步保护</em></p>
<ul>
<li>Hashtable线程更加安全， 代价就是因为它粗暴的添加了同步锁， 所以会有性能损失。</li>
<li>其实有更好的concurrentHashMap可以代替HashTable</li>
</ul>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>在Java编程语言中， 最基本的结构就是两种， 一种是数组， 另外一个是指针（引用）， HashMap就是通过这两个数据结构进行实现。 HashMap实际上是一个“链表散列” 的数据结构， 即数组和链表的结合体。</p>
<p>观察这种结构， 我们可以发现， 失败的hashCode算法会导致hashMap的性能下降为链表（这叫做链地址处理冲突）， 所以想要避免发生碰撞， 就要提高hashCode结果的均匀性。 当然， 在JDK8中， 采用了红黑二叉树进行了处理。</p>
<p><em>什么是Hash攻击？</em></p>
<p><em>通过请求大量key不同，但是hashCode相同的数据， 让HashMap不断发生碰撞， 硬生生的变成了SingleLinkedList， 这样put/get性能就从O（1）变成了O（N), CPU负载呈直线上升， 行成了放大版DDOS的效果， 这种方式就叫做hash攻击，在java8 中通过使用TreeMap, 提升了处理性能， 可以一定程度的防御hash攻击。</em></p>
<p><a href="http://lic128.me/2017/11/20/The-implementation-of-HashMap-in-Java/Structure.jpg" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/20/The-implementation-of-HashMap-in-Java/Structure.jpg" alt="img"></a></p>
<p>每个元素存储的是一个链表的头节点。 那么这些元素是按照怎么样的规则存储到数组中呢？ 一般情况是通过hash（key）%len获得， 也就是元素的key的哈希值对数组长度取模得到。</p>
<p>HashMap里面实现一个静态内部类Entry，其重要的属性有key， value， next。 我们上面说到HashMap的基础就是一个线性数组， 这个数组就是Entry[],， Map里面的内容都保存在Entry[]里面。</p>
<h2 id="HashMap的初始化过程"><a href="#HashMap的初始化过程" class="headerlink" title="HashMap的初始化过程"></a>HashMap的初始化过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public HashMap&lt;Map&lt;? extends K, ? extends V&gt; m&gt;&#123;</span><br><span class="line">    this(Math.max((int)(m.size()/DEFAULT_LOAD_FACTOR)+1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">  inflateTable(threadshold);</span><br><span class="line">  putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>DEFAULT_LOAD_FACTOR</em>: 负载因子的默认值0.75表示数据填充的临界值， 即数据达到总数据的75%时就开始准备扩容了。</p>
<p><em>DEFAULT_INITIAL_CAPACITY</em>: 默认传入Map中的数据默认值为4， 从上面看出， 显示调用自己的构造方法， 然后创建存储的Table（实际是数组）， 最后把值添加到创建的table中。</p>
<h3 id="this-var1-var2-实际调用的构造方法"><a href="#this-var1-var2-实际调用的构造方法" class="headerlink" title="this(var1, var2)实际调用的构造方法"></a>this(var1, var2)实际调用的构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadfactor)&#123;</span><br><span class="line">  if(initalCapacity&lt;0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;+ initialCapacity);</span><br><span class="line">  if(initialCapacity&gt;MAXIMUN_CAPACITY)&#123;</span><br><span class="line">    initialCapacity=MAXIMUM_CAPACITY;</span><br><span class="line">  &#125;else if(initialCapacity&lt;DEFAULT_INITILA_CAPACITY)&#123;</span><br><span class="line">    initialCapacity=DEFAULT_INITIAL_CAPACTITY;</span><br><span class="line">  &#125;</span><br><span class="line">  if(loadFactor&lt;=0 || Float.isNAN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor:&quot;+ loadFactor);</span><br><span class="line">  threadshold= initialCapacity;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initialCapacity</code> : 即初始化申请空间的值,不等于Map实际初始化的内部数组的长度(稍后解释为什么)==,若不填写默认是<code>DEFAULT_INITIAL_CAPACITY</code>也就是4<br><code>initialCapacity</code>的最大值为1 &lt;&lt; 30 也就是2^30次方<br><code>initialCapacity</code>的最小值为DEFAULT_INITIAL_CAPACITY也就是4.</p>
<p><code>loadFactor</code>: 负载因子的初始化值， 若不填写默认问DEFAULT_LOAD_FACTOR也就是0.75</p>
<p><code>threadshold</code>： 下次扩容时的申请空间值。</p>
<h3 id="inflate-Table-方法"><a href="#inflate-Table-方法" class="headerlink" title="inflate Table 方法"></a>inflate Table 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inflates the table.</span><br><span class="line"> */</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    // Find a power of 2 &gt;= toSize</span><br><span class="line">    int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    // Android-changed: Replace usage of Math.min() here because this method is</span><br><span class="line">    // called from the &lt;clinit&gt; of runtime, at which point the native libraries</span><br><span class="line">    // needed by Float.* might not be loaded.</span><br><span class="line">    float thresholdFloat = capacity * loadFactor;</span><br><span class="line">    if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123;</span><br><span class="line">        thresholdFloat = MAXIMUM_CAPACITY + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = (int) thresholdFloat;</span><br><span class="line">    table = new HashMapEntry[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有个重点， 实际申请的内部数组的大小 <code>int capacity= roundUpToPowerOf2(toSize);</code></p>
<p>当数组长度为2^n的时候， 不同的key算得得index相同的几率较小， 那么数据在数组上分布就比较均匀， 也就是说碰撞的几率小， 相对的， 查询的时候就不用遍历某个位置上的链表， 这样查询效率也就较高了。</p>
<h3 id="putAllCreate方法"><a href="#putAllCreate方法" class="headerlink" title="putAllCreate方法"></a>putAllCreate方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void putAllCreate(Map&lt;? extends K, ? extends V&gt; m)&#123;</span><br><span class="line">    for(Map.Entry&lt;? extends K, ? extends V&gt; e: m.entrySet())</span><br><span class="line">      putFOrCreate(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个foreach循环， 将m中的数据拿出来一一添加到map， 下面看具体的putForCreate 方法</p>
<h3 id="putForCreate-方法"><a href="#putForCreate-方法" class="headerlink" title="putForCreate 方法"></a>putForCreate 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void putForCreate(K key, V value)&#123;</span><br><span class="line">  int hash= null==key? 0: sum,sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">  int i= indexFor(hash, table.length);</span><br><span class="line">  for(HashMapEntry&lt;K, V&gt; e= table[i]; e!=null; e=e.next)&#123;</span><br><span class="line">      Object k;</span><br><span class="line">    if(e.hash==hash &amp;&amp; ((k==e.key)==key || (key!=null &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">        e.value= value;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>计算key的hash值</li>
<li>计算数组下标按位取并， 作用上相当于取模mod或者取余%。 这意味着数组下标相同，并不表示hashCode相同。</li>
<li>在对应的key上赋值或者添加一组map。</li>
</ol>
<h3 id="存储数据，-Put方法"><a href="#存储数据，-Put方法" class="headerlink" title="存储数据， Put方法"></a>存储数据， Put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">      if (table == EMPTY_TABLE) &#123;</span><br><span class="line">          inflateTable(threshold);</span><br><span class="line">      &#125;</span><br><span class="line">      if (key == null)</span><br><span class="line">          return putForNullKey(value);</span><br><span class="line">      int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">      int i = indexFor(hash, table.length);</span><br><span class="line">      for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">          Object k;</span><br><span class="line">          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              e.value = value;</span><br><span class="line">              e.recordAccess(this);</span><br><span class="line">              return oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      modCount++;</span><br><span class="line">      addEntry(hash, key, value, i);</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源代码中可以看出</p>
<ol>
<li>Map支持key=null；HashMap会将Key为null组成的Entry<code>&lt;null, value&gt;</code>放置到table[0], 即第一个桶中。在get和put中， 对其进行特殊处理。</li>
<li>当我们往HashMap中put元素的时候， 先根据key的hashCode重新计算hash值， 根据hash值得到这个元素在数组中的位置， 即下标， 如果该数组上已经存放有其他元素了， 那么在这个位置上的元素将以链表的形式存放， 新加入的放在链头， 最先加入的放在链尾。 如果数组该位置上没有元素， 就直接把该元素放在该数组中的该位置上。</li>
</ol>
<p>对于给定的Key， Value, 判断该Key是否与Entry链表中有某一个Entry对象的key值相等时用的是<code>(k=e.key)==key ||key.equals(k)</code>， 另外还有一个判断条件： 即Key经过hash函数转换后的hash值和当前Entry对象的hash属性值相等.</p>
<p>上面的情况我们可以总结为： HashMap在确定Key是否在HashMap中存在的要求有两个：</p>
<ol>
<li>Key值是否相等；</li>
<li>hashcode是否相等；</li>
</ol>
<p>所以我们在定义类时， 如果重写了equals()方法， 但是hashcode却没有保证相等， 就会导致当使用该类实例作为key值放入HashMap中时， 会出现HashMap“工作异常”的问题， 会出现你不希望的情况。</p>
<h4 id="addEntry方法"><a href="#addEntry方法" class="headerlink" title="addEntry方法"></a>addEntry方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储HashMap中的key-value对时， 完全没有考虑Entry中的value， 仅仅只是根据key来计算并决定每个Entry的存储位置。 我们完全可以把Map集合中的value当成key的附属， 当系统决定key的存储位置之后， value随之保存在那里即可。</p>
<p>HashMap的get和put方法实现基本相同， 归纳起来简单地说，HashMap在底层将key-value当成一个整体进行处理， 这个整体就是一个Entry对象。 HashMap底层采用一个Entry[] 数组来保存所有的key-value对， 当需要存储一个Entry对象时， 会根据hash算法来决定其在数组中的存储位置， 再根据equals方法决定其再数组位置上的链表的存储位置； 当需要取出一个Entry时， 也会根据hash算法找到其再数组中的存储位置， 再根据equals方法从该位置上的链表中取出该Entry。</p>
<h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     void resize(int newCapacity) &#123;</span><br><span class="line">       HashMapEntry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">        //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">//根据传入参数的长度定义新的数组</span><br><span class="line">       HashMapEntry[] newTable = new HashMapEntry[newCapacity];</span><br><span class="line">       //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">       transfer(newTable);</span><br><span class="line">       table = newTable;</span><br><span class="line">         //更新临界值</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>旧数组的数据转到新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  void transfer(HashMapEntry[] newTable) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (HashMapEntry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。<br>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">           expectedModCount = modCount;</span><br><span class="line">           if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">               HashMapEntry[] t = table;</span><br><span class="line">               while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">                   ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>　　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）</p>
<p>　在HashMap的API中指出：<br>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。<br>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误.</p>
<h3 id="JDK8-中HashMap的新特性"><a href="#JDK8-中HashMap的新特性" class="headerlink" title="JDK8 中HashMap的新特性"></a>JDK8 中HashMap的新特性</h3><p>如果某个桶的链表记录过大的话（当前是TREEIFY_THRESHOLD=8）， 就会把这个链动态变成红黑二叉树， 使查询最差复杂度由O（n）变成了O（logN）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">    if ((e = p.next) == null) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, null);</span><br><span class="line">        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        break;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附录：-常见哈希算法"><a href="#附录：-常见哈希算法" class="headerlink" title="附录： 常见哈希算法"></a>附录： 常见哈希算法</h3><p>下面给出几个常用的哈希码的算法。</p>
<ol>
<li>Object类的hashcode返回对象的内存地址经过处理后的结构， 由于每个对象的内存地址都不一样， 所以哈希码也不一样。 这个时native方法， 这个取决于JVM的设计， 一般是某种地址的偏移。</li>
<li>String类的hashCode。 根据String类包含的字符串的内容， 根据一种特殊算法返回哈希码， 只要字符串的内容相同， 返回的哈希码也相同。</li>
<li>Integer等包装类， 返回的哈希码就是Integer对象里面所包含的那个整数的数值， 由此可见， 2个一样的Integer对象， 返回的哈希码也一样。</li>
</ol>
<h3 id="附录，-在笔试中的使用"><a href="#附录，-在笔试中的使用" class="headerlink" title="附录， 在笔试中的使用"></a>附录， 在笔试中的使用</h3><h4 id="查重与分组问题"><a href="#查重与分组问题" class="headerlink" title="查重与分组问题"></a>查重与分组问题</h4><p>某公司正在做一个寻找走失儿童的公益项目，现在有一个函数，可以输入两个图片，并返回这个儿童是否重复。请你设计一个系统，帮助他们寻找儿童。</p>
<ol>
<li>网友可以同时上传一批图片</li>
<li>系统能够把所有图片分类并归为一组</li>
<li>网友上传图片后，网页要尽快返回该照片所在的组。</li>
</ol>
<p>A：假设你现在有一个机器，请写出你的数据结构与处理流程，设计的思路。<br>B：如果你有多台机器，如果缩短请求的时间？</p>
<p><strong>Answer：</strong></p>
<p>我们可以把它分解成两个部分， 一个是数据结构一个是上传流程</p>
<ol>
<li>对于数据结构来说， 一个是对儿童信息进行包装， 另一个是实现儿童信息的高效查找。 对于儿童信息包装类来说， 除了加入儿童的图片， 姓名， 生日等基本信息外， 特别要注意重写equals与hashCode， 这个equals就是题目所说的比较函数。 对于查找的实现来说， 首先我们建立一个HashSet， 用于存储儿童信息。 网友上传后， 服务器通过对图像计算出特征Hash值， 并查Hash表， 如果HashCode相同， 则返回所在的组； 如果不相同， 就加入hash表中。</li>
<li>对于多图上传问题， 使用生产者-消费者阻塞队列就可以实现尽快的依次返回照片所在的组。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.jianshu.com/p/8d2d1c4779eb" target="_blank" rel="noopener">HashMap的实现原理</a></li>
<li><a href="http://www.importnew.com/21294.html" target="_blank" rel="noopener">HashMap的实现与优化</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/41576373" target="_blank" rel="noopener">HashMap的设计原理和实现分析</a></li>
<li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK源码中HashMap的hash方法原理时什么？(To be read)</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~hsinmu/courses/_media/dsa_12spring/hashing.pdf" target="_blank" rel="noopener">HashMap</a></li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如何解决Collision：</p>
<ol>
<li><p>Chaining： 使用Linked list 把 hashing到同一个slot的value串起来。这个我们上面已经很详细地介绍过了。</p>
</li>
<li><p>Open Addressing， 使用Probing Method 来寻找Table中空的slot存放资料。</p>
<p>当hash Function 把具有不同Key的资料分配到同一个slot时， 继续寻找下一个空的slot， 直到找到或者所有slot都满了为止。</p>
<p>这种寻找下一格空的slot的方式就称为Probing。</p>
</li>
</ol>
<h4 id="Probing"><a href="#Probing" class="headerlink" title="Probing"></a>Probing</h4><p>Probing就是寻找下一个空的slot， 如果没找到， 就要继续往下找， 因此Probing的精髓就是要制造出往下找的顺序， 这个顺序尽可能越不规则越好， 如此可以确保Hash Function不会一直找到同一个slot。</p>
<p>可以想象的是， 如果对于所有item都只有一种Probing顺序， 那么在加入第一个item时， 只需要O(1)的时间， 但是再继续加入item时， 就必须考虑现有的item数， 也就是说， 其复杂度随着item上升儿上升。</p>
<p>常见的Probing method</p>
<ol>
<li>Linear probing</li>
<li>Quadratic probing</li>
<li>Double hashing</li>
</ol>
<p>特别注意， probing的hash function 与chaining 的hash function 略有不同（虽然都称为Hash Function):</p>
<ul>
<li>Chaining 使用的hash function 只有一个参数， 就是资料的key。</li>
<li>Open Addressing 使用的hash function有两个参数， 一个时资料的key，另一个是probing的次数。</li>
</ul>
<p>基本的hash函数：</p>
<ol>
<li><p>Division Method: m有限制， 但是比较快。</p>
<p>相当于直接做余数运算。</p>
<ul>
<li>优点： 速度快， 只需要做一次余数运算即可。</li>
<li>缺点： 较为理想的Table大小m是距离2^n够远的质数， 像是701. 换句话说， Table大小m必须慎选。例如， 要尽量避免2的指数， 否则就只有最低的p-bit会影响Hash Function.</li>
</ul>
</li>
<li><p>Multiplication Method： m没有限制， 但是比较慢, 各种奇怪的hash算法。</p>
</li>
</ol>
<p>Simple Implementation of HashMap in Java.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class myHashMap &#123;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private String key;</span><br><span class="line">        private String value;</span><br><span class="line">        private Node next;</span><br><span class="line">        public Node()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public Node(String key, String value)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">            this.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getKey()&#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setKey(String key)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getValue()&#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setValue(String value)&#123;</span><br><span class="line">            this.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node getNext()&#123;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setNext(Node next)&#123;</span><br><span class="line">            this.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int BUCKET_ARRAY_SIZE= 256;</span><br><span class="line">    private Node bucketArray[]= new Node[BUCKET_ARRAY_SIZE];</span><br><span class="line">    public myHashMap(int initialSize)&#123;</span><br><span class="line">        this.BUCKET_ARRAY_SIZE= initialSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String key, String value)&#123;</span><br><span class="line">        int hash= Math.abs(key.hashCode()%BUCKET_ARRAY_SIZE);</span><br><span class="line">        Node entry= new Node(key, value);</span><br><span class="line">        if(bucketArray[hash]== null)&#123;</span><br><span class="line">            bucketArray[hash]= entry;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node current= bucketArray[hash];</span><br><span class="line">            while(current.next!= null)&#123;</span><br><span class="line">                if(current.getKey().equals(entry.getKey()))&#123;</span><br><span class="line">                    current.setValue(entry.getValue());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                current= current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next= entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String get(String Key)&#123;</span><br><span class="line">        int hash= Math.abs(Key.hashCode()%BUCKET_ARRAY_SIZE);</span><br><span class="line">        Node n= bucketArray[hash];</span><br><span class="line">        while(n!= null)&#123;</span><br><span class="line">            if(n.getKey().equals(Key))&#123;</span><br><span class="line">                return n.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            n= n.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals-and-hashCode"><a href="#equals-and-hashCode" class="headerlink" title="equals() and hashCode()"></a>equals() and hashCode()</h3><p>As you know this method priovides the hashcode of an object, Basically the default implementation of hashCode() provided by Object is derived by mapping the memory address to an integer value. If look into the source of Object class, you will find the following code for the hashCode. public native int hashCode(); It indicates that hashCode is the native implementation which provides the memory address to a certain content. However it is possible to override the hashCode method in your implementation class.</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>This particular method is used to make equal comparison between two objects.</p>
<p>This particular method is used to make equal comparison between two objects. There are two types of comparisons in Java. One is using “= =” operator and another is “equals()”. I hope that you know the difference between this two. More specifically the “.equals()” refers to equivalence relations. So in broad sense you say that two objects are equivalent they satisfy the “equals()” condition. If you look into the source code of Object class you will find the following code for the equals() method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) </span><br><span class="line">&#123;</span><br><span class="line">	return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now I will explain you when to override the equals() and hashCode() methods and why it is necessary to override these methods. In this regard there is a rule of thumb that if you are going to override the one of the methods( ie equals() and hashCode() ) , you have to override the both otherwise it is a violation of contract made for equals() and hashCode(). Please refer to the Sun’s java docs for the method’s contract. I provide some test case scenario where you will find the significance of these methods. Case-1: You can override the hashCode method in your own way. Please refer to the following example.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above example class “Emp” the variable age is the significant factor. Here the hashCode value will return the age of the person. Now let us consider the following test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;emp1.hashCode()---&gt;&gt;&gt;&quot;+emp1.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you run the above program, the output will be the age what you have given i.e. 23. Now question arises whether there is any way we can get the original hashCode(). We can say that if we do not override the hashCode() method what could have been the hashCode of this object. However please do not feel depressed, Java provide another approach even if you have overridden the hashCode() method , still you can get the original hashCode of a particular class. Now run the following test harness program.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;Overridden hashCode()---&gt;&gt;&gt;&quot;+emp1.hashCode());</span><br><span class="line">		int originalHashCode = System.identityHashCode(emp1);</span><br><span class="line">		System.out.println(&quot;Original hashCode of Emp----&gt;&gt;&gt;&quot;+originalHashCode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here the output will be like this Overridden hashCode()—&gt;&gt;&gt;23 Original hashCode of Emp—-&gt;&gt;&gt;8567361 As you know the above number is arbitrary, it depends upon your system. So then why it is necessary to override this method. There is one reason that if want to compare two objects based upon the equals() method. Although in a very simple class like “Emp”, you can achieve without overriding hashCode() method. But if you do this , you are going to violate the contract for the methods hashCode() and hashCode() of the object class. The similar case is for the method equals(). So funcational point is that if want to compare two objects based upon the equals() method you have to override both hashCode() and equals() methods. Please have look into the Emp class with the overridden methods and the related test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean equals( Object obj )</span><br><span class="line">	&#123;</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		Emp emp = ( Emp )obj;</span><br><span class="line">		if( emp.age == age )</span><br><span class="line">			flag = true;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The related test harness class is given below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		Emp emp2 = new Emp(23);</span><br><span class="line">		System.out.println(&quot;emp1.equals(emp2)---&gt;&gt;&gt;&quot;+emp1.equals(emp2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Case- 2 Think of a test scenario where you want to store your objects in a HasSet and you want to find a particular object. First let us see if we do not override the methods and we want to store the objects in the HashSet. Let us analyse the impact of it from the following code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above code it is a normal class. Now let us see the test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestEmp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) </span><br><span class="line">	&#123;</span><br><span class="line">		Emp emp1 = new Emp(23);</span><br><span class="line">		Emp emp2 = new Emp(24);</span><br><span class="line">		Emp emp3 = new Emp(25);</span><br><span class="line">		Emp emp4 = new Emp(26);</span><br><span class="line">		Emp emp5 = new Emp(27);</span><br><span class="line">		HashSet&lt;Emp&gt; hs = new HashSet&lt;Emp&gt;();</span><br><span class="line">		hs.add(emp1);</span><br><span class="line">		hs.add(emp2);</span><br><span class="line">		hs.add(emp3);</span><br><span class="line">		hs.add(emp4);</span><br><span class="line">		hs.add(emp5);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;HashSet Size---&gt;&gt;&gt;&quot;+hs.size());</span><br><span class="line">		System.out.println(&quot;hs.contains( new Emp(25))---&gt;&gt;&gt;&quot;+hs.contains(new Emp(25)));</span><br><span class="line">		System.out.println(&quot;hs.remove( new Emp(24)---&gt;&gt;&gt;&quot;+hs.remove( new Emp(24));</span><br><span class="line">		System.out.println(&quot;Now HashSet Size---&gt;&gt;&gt;&quot;+hs.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you run the above program, the will output will be like the following. HashSet Size—&gt;&gt;&gt;5 hs.contains( new Emp(25))—&gt;&gt;&gt;false hs.remove( new Emp(24)—&gt;&gt;&gt;false Now HashSet Size—&gt;&gt;&gt;5 It means that you can not find the object. However it is not the case for Integer object. You can put object of type Integer in a HashSet and you can try and you can see the effect. Now let us modify the “Emp” class so that we will get over the problems what we faced in the above test harness class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ddlab.core;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Debadatta Mishra(PIKU)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Emp </span><br><span class="line">&#123;</span><br><span class="line">	private int age ;</span><br><span class="line">	</span><br><span class="line">	public Emp( int age )</span><br><span class="line">	&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int hashCode()</span><br><span class="line">	&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean equals( Object obj )</span><br><span class="line">	&#123;</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		Emp emp = ( Emp )obj;</span><br><span class="line">		if( emp.age == age )</span><br><span class="line">			flag = true;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here in the above class, we have overridden the hashCode() and equals() methods. Now if you run the same test harness class, you will get the desired output like the following. HashSet Size—&gt;&gt;&gt;5 hs.contains( new Emp(25))—&gt;&gt;&gt;true hs.remove( new Emp(24))—&gt;&gt;&gt;true Now HashSet Size—&gt;&gt;&gt;4 Case – 3 In this case you want to use your object as key not the value in the HashMap. So you have to override both the methods hashCode() and equals(). However it is left to the reader to create the object and test the feature in a Map. Case-4 If want to make your own immutable object , it will be wiser to override the equals() and hashCode() methods. To test the above programs, please create the appropriate package as mentioned in the program. You can also create your own package and modify the package name in the above programs. You can all the code in your favorable java editor.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java-中HashMap的实现机制/" data-id="cjd8dst4o0005auzhsh0edz4v" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Data-Structure/">Java, Data Structure</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-Generics-简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java-Generics-简介/" class="article-date">
  <time datetime="2018-02-04T05:51:44.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Java-Generics-简介/">Java Generics 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Generics-in-Java"><a href="#Generics-in-Java" class="headerlink" title="Generics in Java"></a>Generics in Java</h1><h1 id="Java泛型详解"><a href="#Java泛型详解" class="headerlink" title="Java泛型详解"></a>Java泛型详解</h1><p>Java泛型是jdk1.5 中引入的一个新特性， 泛型提供了编译时的类型检测机制， 该机制允许程序员在编译时检测到非法的类型。 泛型是java中一个非常重要的知识点， 在Java集合类框架中泛型被广泛应用。</p>
<h2 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>我们首先定义一个简单的Box类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line">    private String object;</span><br><span class="line">    public void set(String object) &#123; this.object = object; &#125;</span><br><span class="line">    public String get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最常见的做法， 这样做的一个坏处是Box里面现在只能装入String类型的元素， 今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box， 代码得不到复用， 使用泛型可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt;&#123;</span><br><span class="line">  // T stands for &quot;Type&quot;</span><br><span class="line">  private T t;</span><br><span class="line">  public void set(T t)&#123;</span><br><span class="line">    this.t= t;</span><br><span class="line">  &#125;</span><br><span class="line">  public T get()&#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们的Box类便可以得到复用， 我们可以将T替换成任何我们想要的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();</span><br><span class="line">Box&lt;String&gt; stringBox = new Box&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>看完了泛型类，接下来我们来了解一下泛型方法。 声明一个泛型方法很简单，只要在返回类型前面加上一个类似的形式就行了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Util &#123;</span><br><span class="line">    public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</span><br><span class="line">        return p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pair&lt;K, V&gt; &#123;</span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setKey(K key) &#123; this.key = key; &#125;</span><br><span class="line">    public void setValue(V value) &#123; this.value = value; &#125;</span><br><span class="line">    public K getKey()   &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样去调用泛型方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br></pre></td></tr></table></figure>
<p>或者在Java1.7/1.8 利用type inference, 让java自动推导出相应的类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">boolean same = Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>
<h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h3><p>现在我们要实现这样一个功能， 查找一个泛型数组中大于某个特定元素的个数， 我们可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e &gt; elem)  // compiler error</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样很明显是错误的， 因为除了short, int, double, long, float, byte, char等原始类型， 其他的类并不一定能够使用操作符&gt;, 所以编译器报错， 那怎么解决这个问题呢？ 答案是使用边界符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">  	public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做一个类似于下面这样的声明， 这样就等于告诉编译器类型参数T代表的都是实现了<code>Comparable</code>接口的类， 这样等于告诉编译器它们都至少实现了compareTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e.compareTo(elem) &gt; 0)</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在了解通配符之前， 我们首先要澄清一个概念， 还是借用我们上面定义的Box类， 假设我们添加了一个这样的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void boxTest(Box&lt;Number&gt; n) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure>
<p>那么现在Box n允许接受什么类型的参数？ 我们是否能够传入Box 或者Box呢？ 答案是否定的， 虽然Integer 和Double是Number的子类，但是在泛型中 Box 或者Box与Box之间并没有任何的关系。 这一点非常重要。</p>
<p>下面这个例子中，我们创建了一个泛型类<code>Reader</code>，然后在<code>f1()</code>中当我们尝试<code>Fruit f = fruitReader.readExact(apples);</code>编译器会报错，因为<code>List&lt;Fruit&gt;</code>与<code>List&lt;Apple&gt;</code>之间并没有任何的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Fruit &#123;&#125;</span><br><span class="line">class Apple extends Fruit &#123;&#125;</span><br><span class="line">class Orange extends Fruit &#123;&#125;</span><br><span class="line">public class GenericReading &#123;</span><br><span class="line">    static List&lt;Apple&gt; apples = Arrays.asList(new Apple());</span><br><span class="line">    static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit());</span><br><span class="line">    static class Reader&lt;T&gt; &#123;</span><br><span class="line">        T readExact(List&lt;T&gt; list) &#123;</span><br><span class="line">            return list.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void f1() &#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = new Reader&lt;Fruit&gt;();</span><br><span class="line">        // Errors: List&lt;Fruit&gt; cannot be applied to List&lt;Apple&gt;.</span><br><span class="line">        // Fruit f = fruitReader.readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是按照我们通常的思维习惯， Apple和Fruit之间肯定是存在联系， 然而编译器却无法识别， 那么怎么在泛型代码中解决这个问题呢？ 我们可以通过使用通配符来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class CovariantReader&lt;T&gt; &#123;</span><br><span class="line">    T readCovariant(List&lt;? extends T&gt; list) &#123;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void f2() &#123;</span><br><span class="line">    CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;Fruit&gt;();</span><br><span class="line">    Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">    Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就相当于告诉编译器， fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。</p>
<h3 id="PESC原则"><a href="#PESC原则" class="headerlink" title="PESC原则"></a>PESC原则</h3><p>上面我们看到了类似<code>&lt;? extends T&gt;</code>的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsAndCovariance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Wildcards allow covariance:</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</span><br><span class="line">        // Compile Error: can&apos;t add any type of object:</span><br><span class="line">        // flist.add(new Apple())</span><br><span class="line">        // flist.add(new Orange())</span><br><span class="line">        // flist.add(new Fruit())</span><br><span class="line">        // flist.add(new Object())</span><br><span class="line">        flist.add(null); // Legal but uninteresting</span><br><span class="line">        // We Know that it returns at least Fruit:</span><br><span class="line">        Fruit f = flist.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为<code>List&lt;? extends Fruit&gt; flist</code>它自身可以有多种含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</span><br><span class="line">List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Orange&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们尝试add一个Apple的时候，flist可能指向<code>new ArrayList&lt;Orange&gt;()</code>;</li>
<li>当我们尝试add一个Orange的时候，flist可能指向<code>new ArrayList&lt;Apple&gt;()</code>;</li>
<li>当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。</li>
</ul>
<p>所以对于实现了<code>&lt;? extends T&gt;</code>的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。</p>
<p>如果我们要add元素应该怎么做呢？可以使用<code>&lt;? super T&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWriting &#123;</span><br><span class="line">    static List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();</span><br><span class="line">    static List&lt;Fruit&gt; fruit = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">    static &lt;T&gt; void writeExact(List&lt;T&gt; list, T item) &#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    static void f1() &#123;</span><br><span class="line">        writeExact(apples, new Apple());</span><br><span class="line">        writeExact(fruit, new Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    static &lt;T&gt; void writeWithWildcard(List&lt;? super T&gt; list, T item) &#123;</span><br><span class="line">        list.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    static void f2() &#123;</span><br><span class="line">        writeWithWildcard(apples, new Apple());</span><br><span class="line">        writeWithWildcard(fruit, new Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f1(); f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于<code>List&lt;? super Apple&gt; list</code>，它可以有下面几种含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Apple&gt;();</span><br><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;? super Apple&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<p>当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。</p>
<p>根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”：</p>
<ul>
<li>“Producer Extends” - 如果你需要一个只读List，用它来produce T，那么使用<code>? extends T</code>。</li>
<li>“Consumer Super” - 如果你需要一个只写List，用它来consume T，那么使用<code>? super T</code>。</li>
<li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li>
</ul>
<p>如何阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class="line">        for (int i=0; i&lt;src.size(); i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java泛型中最令人苦恼的地方或许就是类型擦除了。 类型擦除就是说Java泛型只能用于在编译期间的静态类型检查， 然后编译器生成的 代码会查出相应的类型信息， 这样到了运行期间JVM并不知道泛型所代表的具体类型。</p>
<p>这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。</p>
<p>说了这么多，那么泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public Node(T data, Node&lt;T&gt; next) &#125;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(Object data, Node next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着不管我们声明<code>Node&lt;String&gt;</code>还是<code>Node&lt;Integer&gt;</code>，到了运行期间，JVM统统视为<code>Node&lt;Object&gt;</code>。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译器就会将<code>T</code>出现的地方替换成<code>Comparable</code>而不再是默认的<code>Object</code>了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    private Comparable data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(Comparable data, Node next) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Comparable getData() &#123; return data; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的概念或许还是比较好理解，但其实泛型擦除带来的问题远远不止这些，接下来我们系统地来看一下类型擦除所带来的一些问题，有些问题在C++的泛型中可能不会遇见，但是在Java中却需要格外小心。</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在Java中不允许创建泛型数组，类似下面这样的做法编译器会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure>
<p>为什么编译器不支持上面这样的做法呢？继续使用逆向思维，我们站在编译器的角度来考虑这个问题。</p>
<p>我们先来看一下下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure>
<p>对于上面这段代码还是很好理解，字符串数组不能存放整型元素，而且这样的错误往往要等到代码运行的时候才能发现，编译器是无法识别的。接下来我们再来看一下假设Java支持泛型数组的创建会出现什么后果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">// An ArrayStoreException should be thrown, but the runtime can&apos;t detect it.</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道<code>new ArrayList&lt;String&gt;()</code>和<code>new ArrayList&lt;Integer&gt;()</code>的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。</p>
<p>如果你对上面这一点还抱有怀疑的话，可以尝试运行下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ErasedTypeEquivalence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Due to the implementation of Java generics, you can’t have code like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GenSet&lt;E&gt;&#123;</span><br><span class="line">  private E a[];</span><br><span class="line">  public GenSet()&#123;</span><br><span class="line">    a= new E[INITIAL_ARRAY_LENGTH];// error: generic array creation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How can implement this while maintaining type safety?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">class Stack&lt;T&gt; &#123;</span><br><span class="line">    public Stack(Class&lt;T&gt; clazz, int capacity) &#123;</span><br><span class="line">        array = (T[])Array.newInstance(clazz, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final T[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/529085/how-to-create-a-generic-array-in-java" target="_blank" rel="noopener">How to create a generic array in Java?</a></p>
<p>You can always do this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[] arr= (E[]) new Object[INITIAL_ARRAY_LENGTH]</span><br></pre></td></tr></table></figure>
<p>This is one of the suggested ways of implementing a generic collection in <em>Effective Java; Item 26</em>. No type errors, no need to cast the array repeatedly. <em>However</em> this triggers a warning because it is potentially dangerous, and should be used with caution. As detailed in the comments, this <code>Object[]</code> is now masquerading as our <code>E[]</code> type, and can cause unexpected errors or <code>ClassCastException</code>s if used unsafely.</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>继续复用我们上面的<code>Node</code>的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出<code>ClassCastException</code>异常，提示String无法转换成Integer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn; // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;); // Causes a ClassCastException to be thrown.</span><br><span class="line">// Integer x = mn.data;</span><br></pre></td></tr></table></figure>
<p>如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在<code>setData(String data)</code>方法，所以只能调用父类Node的<code>setData(Object data)</code>方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那<code>ClassCastException</code>到底是怎么抛出的？</p>
<p>实际上Java编译器对上面代码自动还做了一个处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就是为什么上面会报错的原因了，<code>setData((Integer) data);</code>的时候String无法转换成Integer。所以上面第2行编译器提示<code>unchecked warning</code>的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上<code>Node&lt;Integer&gt; n = mn</code>就好了，这样编译器就可以提前帮我们发现错误。</p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure>
<p>实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。</p>
<h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>我们无法对泛型代码直接使用<code>instanceof</code>关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>的之间的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=&gt; &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;, LinkedList&lt;Character&gt;, ... &#125;</span><br></pre></td></tr></table></figure>
<p>和上面一样，我们可以使用通配符重新设置bounds来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="To-be-Read"><a href="#To-be-Read" class="headerlink" title="To be Read:"></a>To be Read:</h2><p><a href="http://blog.csdn.net/qq_27093465/article/details/73229016" target="_blank" rel="noopener">More about generics</a>;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>见下：</p>
<p><a href="http://lic128.me/2017/11/27/Generics-in-Java/generics.jpg" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/27/Generics-in-Java/generics.jpg" alt="img"></a></p>
<h3 id="StackOverflow"><a href="#StackOverflow" class="headerlink" title="StackOverflow"></a>StackOverflow</h3><p>I‘ve encountered a problem while doing a homework for online algorithms class. Casting Object[] to T[] where T is Comparable raises a run-time exception</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] xs)&#123;</span><br><span class="line">    T[] aux= (T[]) new Object[xs.length];</span><br><span class="line">  	mergeSort(xs, aux, 0, xs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In java, generic types don’t exist at runtime They are only a convenience to enable better compile time type checking. During compilation, generics are replaced by a real type in a process known as type erasure.</p>
<p>Normally, the erasure of a generic type is Object, but since you provided an upper bound for T, it is converted to that bound, Comparable, Therefore, after erasure, your code looks like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable[] aux=(Comparable[]) new Object[xs.length];</span><br></pre></td></tr></table></figure>
<p>In otherwords, you’re creating an array of type Object[] and immediately trying to cast it to type Comparable[]. Since Object doesn’t implement Comparable, the types are incompatible, so you get a runtime exception. You can fix this by creating an array of Comparable instead;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] xs)&#123;</span><br><span class="line">    T[] aux= (T[]) new Comparable[xs.length];</span><br><span class="line">  	mergeSort(xs, aux, 0, xs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java-Generics-简介/" data-id="cjd8dst4n0004auzhe71gpfbw" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Data-Structure/">Java, Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java，-Algorithm/">Java， Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java-Algorithm/" style="font-size: 10px;">Java, Algorithm</a> <a href="/tags/Java-Data-Structure/" style="font-size: 10px;">Java, Data Structure</a> <a href="/tags/Java，-Algorithm/" style="font-size: 10px;">Java， Algorithm</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/03/Resume Review/">关于简历</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(一)/">算法(一)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(二)/">算法(二)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试问题之海量数据/">面试问题之海量数据</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试中的随机算法/">面试中的随机算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>