<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Usin">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm Part 2">
<meta property="og:url" content="http://yoursite.com/2018/01/02/Algorithm-Part2/index.html">
<meta property="og:site_name" content="Rock of SisyPhus">
<meta property="og:description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Using the IP’s themselves as a key is a bad">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-01-18T04:49:07.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm Part 2">
<meta name="twitter:description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Using the IP’s themselves as a key is a bad">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/02/Algorithm-Part2/"/>





  <title>Algorithm Part 2 | Rock of SisyPhus</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock of SisyPhus</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/Algorithm-Part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liyan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock of SisyPhus">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Algorithm Part 2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-02T19:12:06-08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==p || root==q || root==<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left= lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right= lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span> ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=Math.min(p.val, q.val);</span><br><span class="line">        <span class="keyword">int</span> max=Math.max(p.val, q.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;min)  <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;max)  <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> hi=x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= lo+ (hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt; x/mid)&#123;</span><br><span class="line">                lo= mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid== x/mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi= mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Left Table: Transaction Table</span><br><span class="line">Left Mapper: </span><br><span class="line"><span class="function">the transaction <span class="title">map</span><span class="params">()</span> <span class="title">reads</span><span class="params">(transaction_id, product_id, user_id, quantity, amout)</span> and emits a key-value pair composed <span class="title">of</span> <span class="params">(user_id, product_id)</span></span>;</span><br><span class="line"></span><br><span class="line">Right Table: User Table</span><br><span class="line">Right Mapper:</span><br><span class="line"><span class="function">the user <span class="title">map</span><span class="params">()</span> <span class="title">reads</span><span class="params">(user_id, location_id)</span> and emits a key-value pair composed <span class="title">of</span> <span class="params">(user_id, location_id)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Transaction mapper</span></span></span><br><span class="line"><span class="function"><span class="title">map</span><span class="params">(key value)</span></span>&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, <span class="string">"\t"</span>);</span><br><span class="line">  String productID=tokens[<span class="number">1</span>];</span><br><span class="line">  String userID= tokens[<span class="number">2</span>];</span><br><span class="line">  outputKey= Pair(userID, <span class="number">2</span>);</span><br><span class="line">  outputValue= Pair(<span class="string">"P"</span>, productID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User mapper</span></span><br><span class="line">map(key, value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, <span class="string">"\t"</span>);</span><br><span class="line">  String userID= tokens[<span class="number">0</span>];</span><br><span class="line">  String locationID= tokens[<span class="number">1</span>];</span><br><span class="line">  outputKey= Pair(userID, <span class="number">1</span>);<span class="comment">// make sure location shows before produ</span></span><br><span class="line">  outputValue=Pair(<span class="string">"L"</span>, locationID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values=List&lt;&gt;&#123;</span></span><br><span class="line">  Pair&lt;<span class="string">"L"</span>, locationID&gt;,</span><br><span class="line">  Pair&lt;<span class="string">"P"</span>, productID1&gt;,</span><br><span class="line">  Pair&lt;<span class="string">"P"</span>, productID2&gt;,</span><br><span class="line">&#125;</span><br><span class="line">reduce(key, values)&#123;</span><br><span class="line">  locationID=<span class="string">"undefined"</span>;</span><br><span class="line">  <span class="keyword">for</span>(Pair&lt;left, right&gt; value: values)&#123;</span><br><span class="line">    <span class="keyword">if</span>(value.left.equals(<span class="string">"L"</span>))&#123;</span><br><span class="line">      locationID= value.right;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    productID= value.right;</span><br><span class="line">    emit(productID, locationID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的意思就是要设置label。 </p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths  of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity  is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash. </li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(num)==<span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125; </span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)&#123;</span><br><span class="line">            arr[i]= res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">closestToT</span><span class="params">(<span class="keyword">double</span>[] x, <span class="keyword">double</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> prefix=<span class="number">0</span>;</span><br><span class="line">  TreeSet&lt;Double&gt; set= <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">  set.add(prefix);</span><br><span class="line">  <span class="keyword">double</span> leastDiff= Double.MAX_VALUE;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">double</span> i: x)&#123;</span><br><span class="line">      prefix+=i;</span><br><span class="line">    <span class="keyword">double</span> rest= prefix-t;</span><br><span class="line">    <span class="comment">// the next step is binary search, we can coporate the tree set api into it to solve this.</span></span><br><span class="line">    <span class="keyword">if</span>(set.first()&lt;= rest)&#123;</span><br><span class="line">        <span class="keyword">double</span> theSum= prefix- set.floor(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(set.last()&gt; last)&#123;</span><br><span class="line">        <span class="keyword">double</span> theSum= prefix- set.ceiling(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set.add(prefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> leastDiff;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ifRobbedPrevious= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> ifDidntRobPrevious=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> currRobbed= ifDidntRobPrevious+nums[i];</span><br><span class="line">      <span class="keyword">int</span> currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);</span><br><span class="line">      </span><br><span class="line">      ifDidntRobPrevious= currNotRobbed;</span><br><span class="line">      ifRobbedPrevious= currRobbed;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Math.max(ifRobbedPrevious, ifDidntRobPrevious);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] direction= <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] len= <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len[i][j]==<span class="number">0</span>) dfs(i, j, len, matrix);</span><br><span class="line">                res= Math.max(res, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] len, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len[x][y]!=<span class="number">0</span>) <span class="keyword">return</span> len[x][y];</span><br><span class="line">        len[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;direction.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newX= x+ direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newY= y+ direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y])&#123;</span><br><span class="line">                len[x][y]= Math.max(len[x][y], <span class="number">1</span>+ dfs(newX, newY, len, matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: an integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: a boolean which equals to true if the first player will win</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(values.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(values.length&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// so here we are get to take number from left, so what happens h</span></span><br><span class="line">    <span class="comment">// dp[i] means the max value we can get from i~end;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);</span></span><br><span class="line">    <span class="comment">// choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=values.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i]=Math.max(values[i]+ Math.min((i+<span class="number">2</span>&lt;dp.length?dp[i+<span class="number">2</span>]:<span class="number">0</span>),(i+<span class="number">3</span>&lt;dp.length?dp[i+<span class="number">3</span>]:<span class="number">0</span>)), values[i]+ (i+<span class="number">1</span>&lt;values.length? values[i+<span class="number">1</span>]: <span class="number">0</span>)+ Math.min((i+<span class="number">3</span>&lt;dp.length?dp[i+<span class="number">3</span>]:<span class="number">0</span>), (i+<span class="number">4</span>&lt;dp.length?dp[i+<span class="number">4</span>]:<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print(dp);</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: values)&#123;</span><br><span class="line">        sum+= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]&gt;sum- dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]= sum[i]-max(dp[i-1], dp[i-2]);</span></span><br><span class="line">    <span class="keyword">int</span>[] sum= <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">int</span>[] dp= <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=values.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        sum[i]= (i+<span class="number">1</span>&lt;values.length?sum[i+<span class="number">1</span>]:<span class="number">0</span>)+values[i];</span><br><span class="line">        dp[i]= sum[i]- Math.min((i+<span class="number">1</span>&lt;dp.length?dp[i+<span class="number">1</span>]:<span class="number">0</span>), (i+<span class="number">2</span>&lt;dp.length?dp[i+<span class="number">2</span>]:<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//System.out.println(dp[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum[<span class="number">0</span>]-dp[<span class="number">0</span>]&lt;dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can  merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Merge second and third piles =&gt; [4, 2, 4], score +2</span><br><span class="line">2. Merge the first two piles =&gt; [6, 4]，score +6</span><br><span class="line">3. Merge the last two piles =&gt; [10], score +10</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stonegame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxScore</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">        <span class="comment">//int[][] sum= new int[nums.length][nums.length];</span></span><br><span class="line">        <span class="keyword">int</span>[] sum= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum[i]= (i&gt;<span class="number">0</span>?sum[i-<span class="number">1</span>]:<span class="number">0</span>)+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=nums.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len-<span class="number">1</span>&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left= i;</span><br><span class="line">                <span class="keyword">int</span> right= i+len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(left!=right)</span><br><span class="line">                    dp[left][right]=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> mid= left; mid&lt;right; mid++)&#123;</span><br><span class="line">                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+<span class="number">1</span>][right]+sum[right]-(left&gt;<span class="number">0</span>?sum[left-<span class="number">1</span>]:<span class="number">0</span>), dp[left][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][dp.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(getMaxScore(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h3><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost  if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minAdjustCost</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个</span></span><br><span class="line"><span class="comment">     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价</span></span><br><span class="line"><span class="comment">     * 之和最小是多少。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinAdjustmentCost</span><span class="params">(ArrayList&lt;Integer&gt;A, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= A.size();</span><br><span class="line">        <span class="keyword">int</span>[][] f= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">100</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i-<span class="number">1</span>][j]!= Integer.MAX_VALUE)&#123;<span class="comment">// if the previous is restricted to the condition;</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=<span class="number">100</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(j-k)&lt;= target)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(f[i][k]&gt; f[i-<span class="number">1</span>][j]+Math.abs(A.get(i-<span class="number">1</span>)-k))</span><br><span class="line">                                f[i][k] = f[i-<span class="number">1</span>][j] + Math.abs(A.get(i-<span class="number">1</span>)-k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (f[n][i] &lt; ans)</span><br><span class="line">                ans = f[n][i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_2= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index_3= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index_5= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// we say it's a merge process;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> candidate_2=<span class="number">2</span>* dp[index_2];</span><br><span class="line">            <span class="keyword">int</span> candidate_3=<span class="number">3</span>* dp[index_3];</span><br><span class="line">            <span class="keyword">int</span> candidate_5=<span class="number">5</span>* dp[index_5];</span><br><span class="line">            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_2) index_2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_3) index_3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_5) index_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param root: param root: The root of the binary search tree</span></span><br><span class="line"><span class="comment">     * @param k1: An integer</span></span><br><span class="line"><span class="comment">     * @param k2: An integer</span></span><br><span class="line"><span class="comment">     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span></span><br><span class="line">    <span class="comment">//     // write your code here</span></span><br><span class="line">    <span class="comment">//     if(root==null) return new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     if(k2&lt;root.val) return searchRange(root.left, k1, k2);</span></span><br><span class="line">    <span class="comment">//     if(k1&gt;root.val) return searchRange(root.right,k1, k2);</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);</span></span><br><span class="line">    <span class="comment">//     res.addAll(left);</span></span><br><span class="line">    <span class="comment">//     res.add(root.val);</span></span><br><span class="line">    <span class="comment">//     res.addAll(right);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, k1, k2, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in-order binary tree iteration</span></span><br><span class="line">        helper(root.left, k1, k2, result);</span><br><span class="line">        <span class="keyword">if</span> (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k1, k2, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">int</span> candidate_1= nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> candidate_2= nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> count_1=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]==candidate_1)&#123;</span><br><span class="line">        count_1++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]== candidate_2)&#123;</span><br><span class="line">        count_2++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count_1==<span class="number">0</span>)&#123;</span><br><span class="line">        count_1=<span class="number">1</span>;</span><br><span class="line">      	candidate_1=nums[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count_2==<span class="number">0</span>)&#123;</span><br><span class="line">        count_2=<span class="number">1</span>;</span><br><span class="line">      	candidate_2= nums[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        count_1--;</span><br><span class="line">      	count_2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count_1=<span class="number">0</span>;</span><br><span class="line">  count_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">      <span class="keyword">if</span>(num==candidate_1) count_1++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num==candidate_2) count_2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count_1&gt; nums.length/<span class="number">3</span>) res.add(candidate_1);</span><br><span class="line">  <span class="keyword">if</span>(count_2&gt; nums.length/<span class="number">3</span>)</span><br><span class="line">    res.add(candidate_2);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfix</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstBuy= Integer.MIN_VALUE;</span><br><span class="line">  	<span class="keyword">int</span> firstSell=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> secondBuy= Integer.MIN_VALUE;</span><br><span class="line">  	<span class="keyword">int</span> secondSell= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">        secondSell= Math.max(secondBuy+price, secondSell);</span><br><span class="line">      	secondBuy= Math.max(firstSell- price, secondBuy);</span><br><span class="line">      	firstSell= Math.max(firstBuy+price, firstSell);</span><br><span class="line">      	firstBuy= Math.max(firstBuy, -price);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state 1: after buy;</span></span><br><span class="line">        <span class="comment">// state 2: after sell;</span></span><br><span class="line">        <span class="comment">// buy[i] means until day i, the last action is buy, the max profit;</span></span><br><span class="line">        <span class="comment">// buy[i]=sell[i-2]-price[i];</span></span><br><span class="line">        <span class="comment">// sell[i] means until day j, the last action is sell, the max profit;</span></span><br><span class="line">        <span class="comment">// sell[i]=buy[i-1]+ price[i];</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] buy= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] sell= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        buy[<span class="number">0</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            buy[i]= Math.max(buy[i-<span class="number">1</span>], (i&gt;=<span class="number">2</span>?sell[i-<span class="number">2</span>]:<span class="number">0</span>)-prices[i]);</span><br><span class="line">            sell[i]= Math.max(sell[i-<span class="number">1</span>], buy[i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfix</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] buy= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">  	<span class="keyword">int</span>[] sell= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">  	buy[<span class="number">0</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">  	sell[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        buy[i]= Math.max(sell[i-<span class="number">1</span>]-prices[i], buy[i-<span class="number">1</span>]);</span><br><span class="line">      	sell[i]= Math.max(buy[i-<span class="number">1</span>]+prices[i]- fee, sell[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros  &amp;&amp; Sort Colors"></a>Move zeros  &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> p2= nums.length-<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(index&lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index]==<span class="number">0</span> &amp;&amp; index&gt; p1)&#123;</span><br><span class="line">            swap(p1, index, nums);</span><br><span class="line">          	p1++;</span><br><span class="line">          	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span>(nums[index]==<span class="number">2</span> &amp;&amp; index&lt;p2)&#123;</span><br><span class="line">            swap(p2, index, nums);</span><br><span class="line">          	p2--;</span><br><span class="line">          	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	index++;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2, <span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp= nums[p1];</span><br><span class="line">      	nums[p1]= nums[p2];</span><br><span class="line">      	nums[p2]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>
<p>这里还有一道follow up： </p>
<p>Given an array of integers, remove the duplicate number in it. You should:</p>
<ol>
<li>Do it in place in the array.</li>
<li>Move the unique numbers to the front of the array</li>
<li>Return the total number of the unique numbers.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deduplicatation</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]!= nums[len])&#123;</span><br><span class="line">      swap(i, ++len, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-220-Contains-Duplicate"><a href="#Leetcode-220-Contains-Duplicate" class="headerlink" title="Leetcode 220. Contains Duplicate"></a>Leetcode 220. Contains Duplicate</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k;</p>
<p>这道题其实是一道很不错的题目， 对于这道题目， 我们可以有两个解法。</p>
<p>解法1： 利用TreeSet, 维持一个k大小的TreeSet， 每次进行查看， 复杂度 O(n lgk);</p>
<p>解法2： 利用bucket sort，限制bucket的大小， 使得处于一个bucket内的两个数字之差不能大于t, 这里我们选取t+1为bucket size， 而后每次查看前后两个两个bucket是否存在符合条件的点（因为两个相邻bucket之间也有可能存在的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span> || t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> remappedNum= (<span class="keyword">long</span>) nums[i]- Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">long</span> bucket= remappedNum/((<span class="keyword">long</span>) t +<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(bucket)</span><br><span class="line">                    || (map.containsKey(bucket-<span class="number">1</span>) &amp;&amp; remappedNum- map.get(bucket-<span class="number">1</span>)&lt;=t)</span><br><span class="line">                    || (map.containsKey(bucket+<span class="number">1</span>) &amp;&amp; map.get(bucket+<span class="number">1</span>)-remappedNum&lt;=t))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.entrySet().size()&gt;=k)&#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket=((<span class="keyword">long</span>) nums[i-k]- Integer.MIN_VALUE)/((<span class="keyword">long</span>) t+<span class="number">1</span>);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Solution 1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">  <span class="comment">// floor(x) is the maximum number but still &lt;x</span></span><br><span class="line">  <span class="comment">// ceiling(x) is the minimum number but still&gt;x</span></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span> || k&lt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">final</span> TreeSet&lt;Integer&gt; values= <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> ind=<span class="number">0</span>; ind&lt;nums.length; ind++)&#123;</span><br><span class="line">      <span class="keyword">final</span> Integer floor= values.floor(nums[ind]+ t);</span><br><span class="line">    <span class="keyword">final</span> Integer ceil= values.ceiling(nums[ind]-t);</span><br><span class="line">    <span class="keyword">if</span>((floor!=<span class="keyword">null</span> &amp;&amp; floor&gt;nums[ind])  || (ceil!=<span class="keyword">null</span> &amp;&amp; ceil&lt;=nums[ind]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    values.add(nums[ind]);</span><br><span class="line">            <span class="keyword">if</span> (ind &gt;= k) &#123;</span><br><span class="line">                values.remove(nums[ind - k]);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287. Find the Duplicate Number"></a>Leetcode 287. Find the Duplicate Number</h3><p>Given an array nums containing n+1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> slow= nums[<span class="number">0</span>];</span><br><span class="line">  	<span class="keyword">int</span> fast= nums[nums[<span class="number">0</span>]];</span><br><span class="line">  	<span class="keyword">while</span>(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">  	fast=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有一些细节需要注意： </p>
<ol>
<li>对于slow和fast的初始化， 我们为什么要这么设；</li>
<li>在找到交点之后我们为什么又设置为0；</li>
</ol>
<p>以上两点都要从我们对于这道题目原理的理解进行出发开始解答， fast走了多远， slow走了多远， 把带环的linkedlist示意图画出来大概就能理解了。</p>
<h3 id="Leetcode-41-First-Missing-Positive"><a href="#Leetcode-41-First-Missing-Positive" class="headerlink" title="Leetcode 41. First Missing Positive"></a>Leetcode 41. First Missing Positive</h3><p>Given an unsorted integer array, find the first missing positive integer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums)&#123;</span><br><span class="line">  int end= nums.length -1;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">     if(nums[i]==i+1) continue;</span><br><span class="line">     int index= nums[i]-1;</span><br><span class="line">     if(index&gt;=0 &amp;&amp; index&lt;nums.length &amp;&amp; nums[index]!= nums[i])&#123;</span><br><span class="line">       swap(index, i, nums);</span><br><span class="line">       i--;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= i+1) return i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums.length+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两边扫描的方法， 第一遍扫描， 将可以放入正确slot的值放入其正确的slot， 第二遍扫描， 找到第一个不属于自己地方的num。</p>
<h3 id="Find-Two-missing-numbers"><a href="#Find-Two-missing-numbers" class="headerlink" title="Find Two missing numbers"></a>Find Two missing numbers</h3><p>Given an array of n unique integers where each element in the array is in range(1, n). The array has all distinct elements and size of array is(n-2). Hence Two numbers from the range are missing from this array. Find the two missing numbers.</p>
<p>Below are steps:</p>
<ol>
<li><p>Find XOR of all array elements and natural numbers from 1 to n. </p>
</li>
<li><p>As per the property of XOR, same elements will cancel out and we will be left with the two missing numbers A XOR B. But we don’t know the exact numbers.</p>
</li>
<li><p>A bit is set in XOR only of corresponding bits in A and B are different. This is the crucial step to understand.</p>
</li>
<li><p>We take a set bit in XOR. Let us consider the rightmost set bit in XOR, for example , we miss 2 and 4 in {1, 3, 5, 6}. the OXR we get is 110, then set_bit_no= 010.</p>
</li>
<li><p>Now again if we XOR all the elements of arr[] and 1 to n that  have rightmost bit set we will get one of the repeating numbers, say x.</p>
<p>Ex: </p>
<p>Elements in arr[] with bit set: {3, 6}</p>
<p>Elements from 1 to n with bit set {2, 3, 6}</p>
<p>Result of XOR all these is x=2;</p>
</li>
<li><p>Similarly, if we XOR all the elements of arr[] and 1 to n that have rightmost bit not set, we will get the other element, say y.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void findTwoMissingNumbers(int[] arr, int n)&#123;</span><br><span class="line">  int XOR= arr[0];</span><br><span class="line">  for(int i=1; i&lt;n-2; i++)&#123;</span><br><span class="line">    XOR^=arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    XOR^=i;</span><br><span class="line">  &#125;</span><br><span class="line">  //Get a set bit of XOR(we get the rightmost set bit)</span><br><span class="line">  int set_bit_no= XOR &amp; ~(XOR-1);</span><br><span class="line">  // now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element.</span><br><span class="line">  int x=0, y=0;</span><br><span class="line">  for(int i=0; i&lt;n-2; i++)&#123;</span><br><span class="line">    if((arr[i] &amp; set_bit_no)&gt; 0)&#123;</span><br><span class="line">      x= x^arr[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y ^arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    if((i&amp; set_bit_no)&gt;0)&#123;</span><br><span class="line">      x= x^i;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y^i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // Here we get x and y, which is the result;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><a href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。" class="headerlink" title="给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。"></a>给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</h3><p>For each node:</p>
<ol>
<li>add node to a HashSet</li>
<li>increment the block count by one.</li>
<li>If the node’s previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counter blocks.</li>
</ol>
<h3 id="What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><a href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists" class="headerlink" title="What’s the  time complexity of merge k sorted linked lists;"></a>What’s the  time complexity of merge k sorted linked lists;</h3><p>Given K sorted linked lists of size n each, merge them and print the sorted output.</p>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>A Simple Solution is to initialize result as first list. Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way. Time complexity of this solution is O(N2) where N is total number of nodes, i.e., N = kn.</p>
<h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>A better solution is to use Min Heap based solution. Time complexity of this solution would be O(nk Log k); n is the size of the list.</p>
<h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><p>Merge recursively,  the time complexity is just like method 2;</p>
<h3 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472 Concatenated Words"></a>Leetcode472 Concatenated Words</h3><p>Given a list of words(without duplicates). Please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of least shorter words in the given array,</p>
<p>其实这道题目本质上就是wordbreak， 用wordbreak的思路就能做出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(words, (s1, s2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s1.length()- s2.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        Set&lt;String&gt; dict= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canForm(dict, words[i]))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dict.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canForm</span><span class="params">(Set&lt;String&gt; dict, String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp= <span class="keyword">new</span> <span class="keyword">boolean</span>[word.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dict.contains(word.substring(j, i)))&#123;</span><br><span class="line">                    dp[i]= <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="491-Increasing-subsequence"><a href="#491-Increasing-subsequence" class="headerlink" title="491. Increasing subsequence"></a>491. Increasing subsequence</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.</p>
<p>这道题目， 属于对于去重的考察比较好的一道题目， 为了完成去重， 我们要确定， 每一次加进去的数字都是第一次被访问的。 并且， 这是一个未排序的数列， 所以只能用hashset来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(<span class="number">0</span>, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; unit, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unit.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(unit));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; used= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= pos; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(unit.size()==<span class="number">0</span> || unit.get(unit.size()-<span class="number">1</span>)&lt;=nums[i])&#123;</span><br><span class="line">                used.add(nums[i]);</span><br><span class="line">                unit.add(nums[i]);</span><br><span class="line">                helper(i+<span class="number">1</span>, nums, unit, res);</span><br><span class="line">                unit.remove(unit.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zuma-Game"><a href="#Zuma-Game" class="headerlink" title="Zuma Game"></a>Zuma Game</h3><p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>
<p>Each time, you may choose a ball in your hand, and insert it into the row(including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>
<p>Find the minimum balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> MAXCOUNT = <span class="number">6</span>;   <span class="comment">// the max balls you need will not exceed 6 since "The number of balls in your hand won't exceed 5"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] handCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hand.length(); ++i) ++handCount[hand.charAt(i) - <span class="string">'A'</span>];</span><br><span class="line">    <span class="keyword">int</span> rs = helper(board + <span class="string">"#"</span>, handCount);  <span class="comment">// append a "#" to avoid special process while j==board.length, make the code shorter.</span></span><br><span class="line">    <span class="keyword">return</span> rs == MAXCOUNT ? -<span class="number">1</span> : rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span>[] h)</span> </span>&#123;</span><br><span class="line">    s = removeConsecutive(s);     </span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  rs = MAXCOUNT, need = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span> ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) <span class="keyword">continue</span>;</span><br><span class="line">        need = <span class="number">3</span> - (j - i);     <span class="comment">//balls need to remove current consecutive balls.</span></span><br><span class="line">        <span class="keyword">if</span> (h[s.charAt(i) - <span class="string">'A'</span>] &gt;= need) &#123;</span><br><span class="line">            h[s.charAt(i) - <span class="string">'A'</span>] -= need;</span><br><span class="line">            rs = Math.min(rs, need + helper(s.substring(<span class="number">0</span>, i) + s.substring(j), h));</span><br><span class="line">            h[s.charAt(i) - <span class="string">'A'</span>] += need;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//remove consecutive balls longer than 3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">removeConsecutive</span><span class="params">(String board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; board.length(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.charAt(j) == board.charAt(i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (j - i &gt;= <span class="number">3</span>) <span class="keyword">return</span> removeConsecutive(board.substring(<span class="number">0</span>, i) + board.substring(j));</span><br><span class="line">        <span class="keyword">else</span> i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解， 每次计算需要多少个球进行一次消失， 然后对board进行更新。进行递归计算。</p>
<h3 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210. Course Schedule II"></a>Leetcode 210. Course Schedule II</h3><p>除了喜闻乐见的bfs（即 topologic sort）做法来完成这一道题， 还可以用dfs来做， 所不同的是， 我们在这里用stack进行递归， 这样保证， 如果p-&gt;q, 那么p肯定属于stack的外层， 也就是说 整个stack的结构肯定是符合Schedule的。 这个做法还是非常之骚气的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> hasCycle=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map= <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] prerequisite: prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr=prerequisite[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prev=prerequisite[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(prev))&#123;</span><br><span class="line">                map.put(prev, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(prev).add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited= <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            dfs(i, visited, map, stack);</span><br><span class="line">            <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res= <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res[index++]=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="keyword">int</span>[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; map, Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[curr]==<span class="number">1</span>)&#123;</span><br><span class="line">            hasCycle=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited[curr]==-<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(curr))&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            visited[curr]=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// we have find the terminate, which means the end of one chain;</span></span><br><span class="line">        &#125;</span><br><span class="line">        visited[curr]=<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; next= map.get(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: next)&#123;</span><br><span class="line">            dfs(num, visited, map, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// post order</span></span><br><span class="line">        visited[curr]=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-57-Insert-Interval"><a href="#Leetcode-57-Insert-Interval" class="headerlink" title="Leetcode 57. Insert Interval"></a>Leetcode 57. Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals(merge if necessary). You may assume that the intervals were initially sorted according to their start time.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Interval prev= newInterval;</span><br><span class="line">        <span class="keyword">for</span>(Interval curr: intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev==<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prev!= <span class="keyword">null</span> &amp;&amp; curr.end&lt;prev.start)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prev!= <span class="keyword">null</span> &amp;&amp; curr.start&lt;=prev.end)&#123;</span><br><span class="line">                prev.start = Math.min(prev.start,curr.start);</span><br><span class="line">                prev.end= Math.max(prev.end, curr.end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(prev);</span><br><span class="line">                res.add(curr);</span><br><span class="line">                prev= <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prev!=<span class="keyword">null</span>) res.add(prev);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清楚思路， 对于这道题， 我们所要完成的功能是把interval插进去。</p>
<ol>
<li>interval 已经插入过了， 那么interval是null， 我们直接continue;</li>
<li>interval在左边， 我们插入interval， 插入当前， 然后将interval置为null,表示已经插入过了。</li>
<li>interval在右边， 我们将curr插入， 继续遍历。</li>
<li>interval和当前重叠， 我们将curr 与interval merge， 作为新的interval；</li>
</ol>
<h3 id="Leetcode-630-Course-Schedule-III"><a href="#Leetcode-630-Course-Schedule-III" class="headerlink" title="Leetcode 630 Course Schedule III"></a>Leetcode 630 Course Schedule III</h3><p>There are n different online courses numbered from 1 to n. Each course has some duration(course length) t, and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given n online courses represented by pairs(t, d), your task is to find the maximal number of courses that can be taken;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">  public int scheduleCourse(int[][] courses)&#123;</span><br><span class="line">    Arrays.sort(courses, (a, b)-&gt; a[1]-b[1]);// sort the courses by their deadlines. Greedy! We have to deal with courses with early deadlines first</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;&gt;((a, b)-&gt; b-a);</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int[] c: courses)&#123;</span><br><span class="line">      time+=c[0];</span><br><span class="line">      pq.add(c[0]);</span><br><span class="line">      if(time&gt;c[1]) time-=pq.poll();// if time exceeds, drop the previous course which costs the most time.</span><br><span class="line">    &#125;</span><br><span class="line">    return pq.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题算是比较蛋疼的了。 记住做法就是了， 每一步， 我们先放入队列中， 如果发现不能满足条件的话， 我们删除占用时间最多的， 这样的话得到的结果总是最好的。</p>
<p>其实还是比较intuitive的。</p>
<h3 id="Leetcode-621-Task-Scheduler"><a href="#Leetcode-621-Task-Scheduler" class="headerlink" title="Leetcode 621. Task Scheduler"></a>Leetcode 621. Task Scheduler</h3><p>其实这道题目， 如果能够理解题目的话， 并不难。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] c= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">char</span> t: tasks)&#123;</span><br><span class="line">    c[t-<span class="string">'A'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(c);</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">25</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; c[i]==c[<span class="number">25</span>]) i--;</span><br><span class="line">  <span class="keyword">return</span> Math.max(tasks.length, (c[<span class="number">25</span>]-<span class="number">1</span>)*(n+<span class="number">1</span>)+<span class="number">25</span>-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于形成了一个框架， 然后往这个框架里面放元素。</p>
<h3 id="Leetcode-546-Remove-Boxes"><a href="#Leetcode-546-Remove-Boxes" class="headerlink" title="Leetcode 546. Remove Boxes"></a>Leetcode 546. Remove Boxes</h3><p>Given several boxes with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color(composed of k boxes, k&gt;=1), remove them and get k*k points.</p>
<p>Find the maximum points you can get.</p>
<p>暴力 backtracking 做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(<span class="keyword">int</span>[] boxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(boxes.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> box: boxes)&#123;</span><br><span class="line">            list.add(box);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removeBoxes(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(List&lt;Integer&gt; boxes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(boxes.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;boxes.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start=i;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;boxes.size() &amp;&amp; boxes.get(i)==boxes.get(start)) i++;</span><br><span class="line">            List&lt;Integer&gt; next= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;boxes.size(); idx++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(idx&gt;=start &amp;&amp; idx&lt;i) <span class="keyword">continue</span>;</span><br><span class="line">                next.add(boxes.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res, removeBoxes(next)+ (i-start)*(i-start));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top-down dp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int remooveBoxes(int[] boxes)&#123;</span><br><span class="line">  int n= boxes.length;</span><br><span class="line">  int[][][] dp= new int[n][n][n];</span><br><span class="line">  return removeBoxesSum(boxes, 0, n-1, 0, dp);</span><br><span class="line">&#125;</span><br><span class="line">private int removeBoxesSub(int[] boxes, int i, int j, int k, int[][] dp)&#123;</span><br><span class="line">  if(i&gt;j) return 0;</span><br><span class="line">  if(dp[i][j][k]&gt;0) return dp[i][j][k];</span><br><span class="line">  for(; i+1&lt;= j &amp;&amp; boxes[i+1]==boxes[i], i++, k++);// optimization: all boxes of the same color counted continuously from the first box should be grouped together;</span><br><span class="line">  int res=(k+1)*(k+1)+ removeBoxesSub(i+1, j. 0, dp);</span><br><span class="line">  for(int m= i+1; m&lt;=j; m++)&#123;</span><br><span class="line">    if(boxes[i]==boxes[m])&#123;</span><br><span class="line">      res= Math.max(res, removeBoxesSub(boxes, i+1, m-1, 0, dp)+ removeBoxesSub(boxes, m, j, k+1, dp));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> dp[i][j][k]= res;</span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k)&#123;</span><br><span class="line">  int[] count= new int[128];</span><br><span class="line">  int max=0;</span><br><span class="line">  int start=0;</span><br><span class="line">  for(int end=0; end&lt; s.length(); end++)&#123;</span><br><span class="line">    max= Math.max(max, ++count[s.charAt(end)]);</span><br><span class="line">    if(max+k&lt;=end-start)&#123;</span><br><span class="line">      count[s.charAt(start++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s.length()- start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n);</p>
<p>For example:</p>
<p>S=”ADOBECODEBANC”</p>
<p>T=”ABC”</p>
<p>Minimum window is “BANC”</p>
<p>这道题是window的一道很经典的题目了， 碰到这种题目的时候， 我们需要让window满足一个性质， 然后移动左右边界去更新。 得到我们想要的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t)&#123;</span><br><span class="line">  int count=0;</span><br><span class="line">  int[] cnt= new int[256];</span><br><span class="line">  for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">    cnt[t.charAt(i)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  int left= 0;</span><br><span class="line">  int min= Integer.MAX_VALUE;</span><br><span class="line">  String res= &quot;&quot;;</span><br><span class="line">  for(int right= 0; right&lt;s.length(); right++)&#123;</span><br><span class="line">    cnt[s.charAt(right)]--;</span><br><span class="line">    if(cnt[s.charAt(right)]&gt;=0) count++;</span><br><span class="line">    while(count&gt;= t.length())&#123;</span><br><span class="line">      if(right-left+1&lt;min)&#123;</span><br><span class="line">        min= right- left+1;</span><br><span class="line">        res=s.substring(left, right+1);</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[s.charAt(left)]++;</span><br><span class="line">      if(cnt[s.charAt(left)]&gt;0) count--;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-84-Largest-Rectangle-in-Histogram"><a href="#Leetcode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="Leetcode 84. Largest Rectangle in Histogram"></a>Leetcode 84. Largest Rectangle in Histogram</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>这道题目很经典， 在面试的时候stack基本都是这样用， 用来维持一个顺序， 我们在这里维持一个递增的stack， 每次发现数字比栈顶的数字要小的情况时， 对于栈顶而言， 我们找到了以栈顶为最高点的最大的长方形， 因此该长方形面积也能算出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//maintain a stack which is strictly non-decreasing</span></span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[heights.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.length; i++)&#123;</span><br><span class="line">            arr[i]=heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&gt;arr[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height= arr[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> right=i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left=(stack.isEmpty()?-<span class="number">1</span>:stack.peek())+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//System.out.println("height="+ height);</span></span><br><span class="line">               <span class="comment">// System.out.println("width="+ (right-left+1));</span></span><br><span class="line">                res= Math.max(res, (right-left+<span class="number">1</span>)* height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-218-the-skyline-problem"><a href="#Leetcode-218-the-skyline-problem" class="headerlink" title="Leetcode 218 the skyline problem"></a>Leetcode 218 the skyline problem</h3><p>在这道题里面， 我们给定了每个建筑的位置以及高度， 要我们输出一系列点（天际线）： A key point is the left endpoint of a horizontal line segment.</p>
<p>想法： </p>
<p>for position in sorted(all start points and all end points)</p>
<p>if this position is a start point:</p>
<p>​    add its height</p>
<p>if this position is a end point:</p>
<p>​    delete its height</p>
<p>Compare current max height with previous height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;int[]&gt; getSkyline(int[][] buildings)&#123;</span><br><span class="line">  List&lt;int[]&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;int[]&gt; height= new ArrayList&lt;&gt;();</span><br><span class="line">  for(int[] b: buildings)&#123;</span><br><span class="line">    height.add(new int[]&#123;b[0], -b[2]&#125;);</span><br><span class="line">    height.add(new int[]&#123;b[1], b[2]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(height, (a, b)-&gt;&#123;</span><br><span class="line">    if(a[0]==b[0])&#123;</span><br><span class="line">      return a[1]-b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0]-b[0];</span><br><span class="line">  &#125;);</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;Integer&gt;((a, b)-&gt;&#123;return b-a;&#125;);</span><br><span class="line">  pq.offer(0);</span><br><span class="line">  int prev_max=0;</span><br><span class="line">  for(int[] h: height)&#123;</span><br><span class="line">    if(h[1]&lt;0)&#123;</span><br><span class="line">      pq.offer(-h[1]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pq.remove(h[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int max= pq.peek();</span><br><span class="line">    if(prev_max!= max)&#123;</span><br><span class="line">      res.add(new int[]&#123;h[0], max&#125;);</span><br><span class="line">      prev_max= max;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-239-Sliding-Window-Maximum"><a href="#Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="Leetcode 239. Sliding Window Maximum"></a>Leetcode 239. Sliding Window Maximum</h3><p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>这道题目还是关于stack的题目， 所不同的是， 由于其特殊性， 这个栈的大小不能大于k， 所以在这里， 我们维持一个不大于k且递减的栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// maintain a decreasing linkedlist;</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length- k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(deque.size()!=<span class="number">0</span> &amp;&amp; nums[i]&gt;nums[deque.peekLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            <span class="keyword">if</span>(i-deque.peekFirst()+<span class="number">1</span>&gt;k)&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k-<span class="number">1</span>) res[index++]= nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315. Count of Smaller Numbers After Self."></a>Leetcode 315. Count of Smaller Numbers After Self.</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p>这道题可以用不同的方式来做， 比如说建树， merge sort， binarySearch等等， 这里我们使用建树和binarySearch两种方式来做。</p>
<h4 id="buildTree"><a href="#buildTree" class="headerlink" title="buildTree:"></a>buildTree:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> size; <span class="comment">// to kept the size node on his left;</span></span><br><span class="line">        <span class="keyword">int</span> duplicate;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val=val;</span><br><span class="line">            <span class="keyword">this</span>.size=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.duplicate=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode root= <span class="keyword">new</span> TreeNode(nums[nums.length-<span class="number">1</span>]);</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            TreeNode node=<span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">            insert(root, node, <span class="number">0</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root, TreeNode node, <span class="keyword">int</span> curr, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.val&gt;root.val)&#123;</span><br><span class="line">            curr+=root.size+root.duplicate;</span><br><span class="line">            root.right=insert(root.right, node, curr, res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val==root.val)&#123;</span><br><span class="line">            root.duplicate++;</span><br><span class="line">            res.add(root.size+curr);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.size++;</span><br><span class="line">            root.left=insert(root.left, node, curr, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> index= findIndex(list, nums[i]);</span><br><span class="line">            <span class="comment">//System.out.println(index);</span></span><br><span class="line">            res.add(index);</span><br><span class="line">            <span class="keyword">if</span>(index==list.size()) list.add(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> list.add(index, nums[i]);</span><br><span class="line">            <span class="comment">//System.out.println(list);</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi= list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= lo+(hi- lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi= mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种做法可以延伸至 reverse pairs 这一道题目。</p>
<h3 id="Leetcode-312-Burst-Balloons"><a href="#Leetcode-312-Burst-Balloons" class="headerlink" title="Leetcode 312. Burst Balloons"></a>Leetcode 312. Burst Balloons</h3><p>注意思维方式： 我们关注的是最后一个爆掉的气球。 关于dp的话， 注意边界和构造就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            arr[i+<span class="number">1</span>]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[nums.length+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp= <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;  len&lt;=arr.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len&lt;arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> start= i;</span><br><span class="line">                <span class="keyword">int</span> end=i+len;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j= start+<span class="number">1</span>; j&lt;end; j++)&#123;</span><br><span class="line">                    dp[start][end]= Math.max(dp[start][j]+ dp[j][end]+ arr[start]*arr[end]*arr[j], dp[start][end]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][dp.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/01/Big-Data-Interview-Questions/" rel="next" title="Big Data Interview Questions">
                <i class="fa fa-chevron-left"></i> Big Data Interview Questions
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/05/Interview-Record/" rel="prev" title="Interview Record">
                Interview Record <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Liyan Chen" />
            
              <p class="site-author-name" itemprop="name">Liyan Chen</p>
              <p class="site-description motion-element" itemprop="description">千江有水千江月， 万里无云万里天</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Lic128" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:lic128@eng.ucsd.edu" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-efficiently-hash-the-ip-address"><span class="nav-number">1.</span> <span class="nav-text">How to efficiently hash the ip-address</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-Two-Balanced-Binary-Search-Trees"><span class="nav-number">2.</span> <span class="nav-text">Merge Two Balanced Binary Search Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-1-Insert-elements-of-first-tree-to-second"><span class="nav-number">2.1.</span> <span class="nav-text">Method 1 : Insert elements of first tree to second.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-2-Merge-Inorder-Traversals"><span class="nav-number">2.2.</span> <span class="nav-text">Method 2: Merge Inorder Traversals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cherry-Picker"><span class="nav-number">3.</span> <span class="nav-text">Cherry Picker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">4.</span> <span class="nav-text">Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sqrt-x"><span class="nav-number">5.</span> <span class="nav-text">Sqrt(x)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-K"><span class="nav-number">6.</span> <span class="nav-text">Top K</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数据全部排序"><span class="nav-number">6.1.</span> <span class="nav-text">将数据全部排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部淘汰法"><span class="nav-number">6.2.</span> <span class="nav-text">局部淘汰法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Heap"><span class="nav-number">6.3.</span> <span class="nav-text">Heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分治法"><span class="nav-number">6.4.</span> <span class="nav-text">分治法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="nav-number">7.</span> <span class="nav-text">Leetcode 332. Reconstruct Itinerary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-handle-id-generation-on-a-hadoop-cluster"><span class="nav-number">8.</span> <span class="nav-text">How to handle id generation on a hadoop cluster?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Map-Reduce-to-implement-outer-left-join"><span class="nav-number">9.</span> <span class="nav-text">Using Map Reduce to implement outer left join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Can-you-Override-Main-method-in-Java"><span class="nav-number">10.</span> <span class="nav-text">Can you Override Main method in Java?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intersection-of-Two-Arrays"><span class="nav-number">11.</span> <span class="nav-text">Intersection of Two Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Follow-up"><span class="nav-number">11.1.</span> <span class="nav-text">Follow up:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Answer-to-follow-up"><span class="nav-number">11.2.</span> <span class="nav-text">Answer to follow up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code"><span class="nav-number">11.3.</span> <span class="nav-text">code:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subsequence-with-sub-closest-to-t"><span class="nav-number">12.</span> <span class="nav-text">Subsequence with sub closest to t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Robber"><span class="nav-number">13.</span> <span class="nav-text">House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="nav-number">14.</span> <span class="nav-text">Leetcode 329. Longest Increasing Path in a Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#code-1"><span class="nav-number">14.1.</span> <span class="nav-text">code</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coins-in-a-line"><span class="nav-number">15.</span> <span class="nav-text">Coins in a line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stone-Game"><span class="nav-number">16.</span> <span class="nav-text">Stone Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小调整代价"><span class="nav-number">17.</span> <span class="nav-text">最小调整代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ugly-Number"><span class="nav-number">18.</span> <span class="nav-text">Ugly Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树查找树中搜索区间"><span class="nav-number">19.</span> <span class="nav-text">二叉树查找树中搜索区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Majority-Element-II"><span class="nav-number">20.</span> <span class="nav-text">Majority Element II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">21.</span> <span class="nav-text">Leetcode 123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><span class="nav-number">22.</span> <span class="nav-text">Leetcode 309. Best Time to Buy and Sell Stock with cooldown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-zeros-amp-amp-Sort-Colors"><span class="nav-number">23.</span> <span class="nav-text">Move zeros  && Sort Colors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-220-Contains-Duplicate"><span class="nav-number">24.</span> <span class="nav-text">Leetcode 220. Contains Duplicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-287-Find-the-Duplicate-Number"><span class="nav-number">25.</span> <span class="nav-text">Leetcode 287. Find the Duplicate Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-41-First-Missing-Positive"><span class="nav-number">26.</span> <span class="nav-text">Leetcode 41. First Missing Positive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-Two-missing-numbers"><span class="nav-number">27.</span> <span class="nav-text">Find Two missing numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><span class="nav-number">28.</span> <span class="nav-text">给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><span class="nav-number">29.</span> <span class="nav-text">What’s the  time complexity of merge k sorted linked lists;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-1"><span class="nav-number">29.1.</span> <span class="nav-text">Method 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-2"><span class="nav-number">29.2.</span> <span class="nav-text">Method 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-3"><span class="nav-number">29.3.</span> <span class="nav-text">Method 3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode472-Concatenated-Words"><span class="nav-number">30.</span> <span class="nav-text">Leetcode472 Concatenated Words</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#491-Increasing-subsequence"><span class="nav-number">31.</span> <span class="nav-text">491. Increasing subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zuma-Game"><span class="nav-number">32.</span> <span class="nav-text">Zuma Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-210-Course-Schedule-II"><span class="nav-number">33.</span> <span class="nav-text">Leetcode 210. Course Schedule II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-57-Insert-Interval"><span class="nav-number">34.</span> <span class="nav-text">Leetcode 57. Insert Interval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-630-Course-Schedule-III"><span class="nav-number">35.</span> <span class="nav-text">Leetcode 630 Course Schedule III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-621-Task-Scheduler"><span class="nav-number">36.</span> <span class="nav-text">Leetcode 621. Task Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-546-Remove-Boxes"><span class="nav-number">37.</span> <span class="nav-text">Leetcode 546. Remove Boxes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-424-Longest-Repeating-Character-Replacement"><span class="nav-number">38.</span> <span class="nav-text">Leetcode 424. Longest Repeating Character Replacement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-76-Minimum-Window-Substring"><span class="nav-number">39.</span> <span class="nav-text">Leetcode 76. Minimum Window Substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-84-Largest-Rectangle-in-Histogram"><span class="nav-number">40.</span> <span class="nav-text">Leetcode 84. Largest Rectangle in Histogram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-218-the-skyline-problem"><span class="nav-number">41.</span> <span class="nav-text">Leetcode 218 the skyline problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-239-Sliding-Window-Maximum"><span class="nav-number">42.</span> <span class="nav-text">Leetcode 239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self"><span class="nav-number">43.</span> <span class="nav-text">Leetcode 315. Count of Smaller Numbers After Self.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#buildTree"><span class="nav-number">43.1.</span> <span class="nav-text">buildTree:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Search"><span class="nav-number">43.2.</span> <span class="nav-text">Binary Search</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-312-Burst-Balloons"><span class="nav-number">44.</span> <span class="nav-text">Leetcode 312. Burst Balloons</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyan Chen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
