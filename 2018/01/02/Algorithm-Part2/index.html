<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Usin">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm Part 2">
<meta property="og:url" content="http://yoursite.com/2018/01/02/Algorithm-Part2/index.html">
<meta property="og:site_name" content="Rock of SisyPhus">
<meta property="og:description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Using the IP’s themselves as a key is a bad">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-01-12T21:28:54.474Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm Part 2">
<meta name="twitter:description" content="How to efficiently hash the ip-addressQuestion: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses. Hint: Using the IP’s themselves as a key is a bad">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/02/Algorithm-Part2/"/>





  <title>Algorithm Part 2 | Rock of SisyPhus</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock of SisyPhus</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/Algorithm-Part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liyan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock of SisyPhus">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Algorithm Part 2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-02T19:12:06-08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==p || root==q || root==<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left= lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right= lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span> ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=Math.min(p.val, q.val);</span><br><span class="line">        <span class="keyword">int</span> max=Math.max(p.val, q.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;min)  <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;max)  <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> hi=x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= lo+ (hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt; x/mid)&#123;</span><br><span class="line">                lo= mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid== x/mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi= mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Left Table: Transaction Table</span><br><span class="line">Left Mapper: </span><br><span class="line"><span class="function">the transaction <span class="title">map</span><span class="params">()</span> <span class="title">reads</span><span class="params">(transaction_id, product_id, user_id, quantity, amout)</span> and emits a key-value pair composed <span class="title">of</span> <span class="params">(user_id, product_id)</span></span>;</span><br><span class="line"></span><br><span class="line">Right Table: User Table</span><br><span class="line">Right Mapper:</span><br><span class="line"><span class="function">the user <span class="title">map</span><span class="params">()</span> <span class="title">reads</span><span class="params">(user_id, location_id)</span> and emits a key-value pair composed <span class="title">of</span> <span class="params">(user_id, location_id)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Transaction mapper</span></span></span><br><span class="line"><span class="function"><span class="title">map</span><span class="params">(key value)</span></span>&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, <span class="string">"\t"</span>);</span><br><span class="line">  String productID=tokens[<span class="number">1</span>];</span><br><span class="line">  String userID= tokens[<span class="number">2</span>];</span><br><span class="line">  outputKey= Pair(userID, <span class="number">2</span>);</span><br><span class="line">  outputValue= Pair(<span class="string">"P"</span>, productID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User mapper</span></span><br><span class="line">map(key, value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, <span class="string">"\t"</span>);</span><br><span class="line">  String userID= tokens[<span class="number">0</span>];</span><br><span class="line">  String locationID= tokens[<span class="number">1</span>];</span><br><span class="line">  outputKey= Pair(userID, <span class="number">1</span>);<span class="comment">// make sure location shows before produ</span></span><br><span class="line">  outputValue=Pair(<span class="string">"L"</span>, locationID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values=List&lt;&gt;&#123;</span></span><br><span class="line">  Pair&lt;<span class="string">"L"</span>, locationID&gt;,</span><br><span class="line">  Pair&lt;<span class="string">"P"</span>, productID1&gt;,</span><br><span class="line">  Pair&lt;<span class="string">"P"</span>, productID2&gt;,</span><br><span class="line">&#125;</span><br><span class="line">reduce(key, values)&#123;</span><br><span class="line">  locationID=<span class="string">"undefined"</span>;</span><br><span class="line">  <span class="keyword">for</span>(Pair&lt;left, right&gt; value: values)&#123;</span><br><span class="line">    <span class="keyword">if</span>(value.left.equals(<span class="string">"L"</span>))&#123;</span><br><span class="line">      locationID= value.right;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    productID= value.right;</span><br><span class="line">    emit(productID, locationID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的意思就是要设置label。 </p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths  of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity  is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash. </li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(num)==<span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125; </span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)&#123;</span><br><span class="line">            arr[i]= res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">closestToT</span><span class="params">(<span class="keyword">double</span>[] x, <span class="keyword">double</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> prefix=<span class="number">0</span>;</span><br><span class="line">  TreeSet&lt;Double&gt; set= <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">  set.add(prefix);</span><br><span class="line">  <span class="keyword">double</span> leastDiff= Double.MAX_VALUE;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">double</span> i: x)&#123;</span><br><span class="line">      prefix+=i;</span><br><span class="line">    <span class="keyword">double</span> rest= prefix-t;</span><br><span class="line">    <span class="comment">// the next step is binary search, we can coporate the tree set api into it to solve this.</span></span><br><span class="line">    <span class="keyword">if</span>(set.first()&lt;= rest)&#123;</span><br><span class="line">        <span class="keyword">double</span> theSum= prefix- set.floor(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(set.last()&gt; last)&#123;</span><br><span class="line">        <span class="keyword">double</span> theSum= prefix- set.ceiling(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set.add(prefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> leastDiff;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ifRobbedPrevious= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> ifDidntRobPrevious=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> currRobbed= ifDidntRobPrevious+nums[i];</span><br><span class="line">      <span class="keyword">int</span> currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);</span><br><span class="line">      </span><br><span class="line">      ifDidntRobPrevious= currNotRobbed;</span><br><span class="line">      ifRobbedPrevious= currRobbed;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Math.max(ifRobbedPrevious, ifDidntRobPrevious);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] direction= <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] len= <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len[i][j]==<span class="number">0</span>) dfs(i, j, len, matrix);</span><br><span class="line">                res= Math.max(res, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] len, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len[x][y]!=<span class="number">0</span>) <span class="keyword">return</span> len[x][y];</span><br><span class="line">        len[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;direction.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newX= x+ direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newY= y+ direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y])&#123;</span><br><span class="line">                len[x][y]= Math.max(len[x][y], <span class="number">1</span>+ dfs(newX, newY, len, matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: an integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: a boolean which equals to true if the first player will win</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(values.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(values.length&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// so here we are get to take number from left, so what happens h</span></span><br><span class="line">    <span class="comment">// dp[i] means the max value we can get from i~end;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);</span></span><br><span class="line">    <span class="comment">// choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=values.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i]=Math.max(values[i]+ Math.min((i+<span class="number">2</span>&lt;dp.length?dp[i+<span class="number">2</span>]:<span class="number">0</span>),(i+<span class="number">3</span>&lt;dp.length?dp[i+<span class="number">3</span>]:<span class="number">0</span>)), values[i]+ (i+<span class="number">1</span>&lt;values.length? values[i+<span class="number">1</span>]: <span class="number">0</span>)+ Math.min((i+<span class="number">3</span>&lt;dp.length?dp[i+<span class="number">3</span>]:<span class="number">0</span>), (i+<span class="number">4</span>&lt;dp.length?dp[i+<span class="number">4</span>]:<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print(dp);</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: values)&#123;</span><br><span class="line">        sum+= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]&gt;sum- dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]= sum[i]-max(dp[i-1], dp[i-2]);</span></span><br><span class="line">    <span class="keyword">int</span>[] sum= <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">int</span>[] dp= <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=values.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        sum[i]= (i+<span class="number">1</span>&lt;values.length?sum[i+<span class="number">1</span>]:<span class="number">0</span>)+values[i];</span><br><span class="line">        dp[i]= sum[i]- Math.min((i+<span class="number">1</span>&lt;dp.length?dp[i+<span class="number">1</span>]:<span class="number">0</span>), (i+<span class="number">2</span>&lt;dp.length?dp[i+<span class="number">2</span>]:<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//System.out.println(dp[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum[<span class="number">0</span>]-dp[<span class="number">0</span>]&lt;dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can  merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Merge second and third piles =&gt; [4, 2, 4], score +2</span><br><span class="line">2. Merge the first two piles =&gt; [6, 4]，score +6</span><br><span class="line">3. Merge the last two piles =&gt; [10], score +10</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stonegame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxScore</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">        <span class="comment">//int[][] sum= new int[nums.length][nums.length];</span></span><br><span class="line">        <span class="keyword">int</span>[] sum= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum[i]= (i&gt;<span class="number">0</span>?sum[i-<span class="number">1</span>]:<span class="number">0</span>)+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=nums.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len-<span class="number">1</span>&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left= i;</span><br><span class="line">                <span class="keyword">int</span> right= i+len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(left!=right)</span><br><span class="line">                    dp[left][right]=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> mid= left; mid&lt;right; mid++)&#123;</span><br><span class="line">                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+<span class="number">1</span>][right]+sum[right]-(left&gt;<span class="number">0</span>?sum[left-<span class="number">1</span>]:<span class="number">0</span>), dp[left][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][dp.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(getMaxScore(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h2><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost  if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minAdjustCost</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个</span></span><br><span class="line"><span class="comment">     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价</span></span><br><span class="line"><span class="comment">     * 之和最小是多少。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinAdjustmentCost</span><span class="params">(ArrayList&lt;Integer&gt;A, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= A.size();</span><br><span class="line">        <span class="keyword">int</span>[][] f= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">100</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i-<span class="number">1</span>][j]!= Integer.MAX_VALUE)&#123;<span class="comment">// if the previous is restricted to the condition;</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=<span class="number">100</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(j-k)&lt;= target)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(f[i][k]&gt; f[i-<span class="number">1</span>][j]+Math.abs(A.get(i-<span class="number">1</span>)-k))</span><br><span class="line">                                f[i][k] = f[i-<span class="number">1</span>][j] + Math.abs(A.get(i-<span class="number">1</span>)-k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (f[n][i] &lt; ans)</span><br><span class="line">                ans = f[n][i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_2= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index_3= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index_5= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// we say it's a merge process;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> candidate_2=<span class="number">2</span>* dp[index_2];</span><br><span class="line">            <span class="keyword">int</span> candidate_3=<span class="number">3</span>* dp[index_3];</span><br><span class="line">            <span class="keyword">int</span> candidate_5=<span class="number">5</span>* dp[index_5];</span><br><span class="line">            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_2) index_2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_3) index_3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]== candidate_5) index_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param root: param root: The root of the binary search tree</span></span><br><span class="line"><span class="comment">     * @param k1: An integer</span></span><br><span class="line"><span class="comment">     * @param k2: An integer</span></span><br><span class="line"><span class="comment">     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span></span><br><span class="line">    <span class="comment">//     // write your code here</span></span><br><span class="line">    <span class="comment">//     if(root==null) return new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     if(k2&lt;root.val) return searchRange(root.left, k1, k2);</span></span><br><span class="line">    <span class="comment">//     if(k1&gt;root.val) return searchRange(root.right,k1, k2);</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);</span></span><br><span class="line">    <span class="comment">//     res.addAll(left);</span></span><br><span class="line">    <span class="comment">//     res.add(root.val);</span></span><br><span class="line">    <span class="comment">//     res.addAll(right);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, k1, k2, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in-order binary tree iteration</span></span><br><span class="line">        helper(root.left, k1, k2, result);</span><br><span class="line">        <span class="keyword">if</span> (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k1, k2, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">int</span> candidate_1= nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> candidate_2= nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> count_1=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]==candidate_1)&#123;</span><br><span class="line">        count_1++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]== candidate_2)&#123;</span><br><span class="line">        count_2++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count_1==<span class="number">0</span>)&#123;</span><br><span class="line">        count_1=<span class="number">1</span>;</span><br><span class="line">      	candidate_1=nums[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count_2==<span class="number">0</span>)&#123;</span><br><span class="line">        count_2=<span class="number">1</span>;</span><br><span class="line">      	candidate_2= nums[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        count_1--;</span><br><span class="line">      	count_2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count_1=<span class="number">0</span>;</span><br><span class="line">  count_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">      <span class="keyword">if</span>(num==candidate_1) count_1++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num==candidate_2) count_2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count_1&gt; nums.length/<span class="number">3</span>) res.add(candidate_1);</span><br><span class="line">  <span class="keyword">if</span>(count_2&gt; nums.length/<span class="number">3</span>)</span><br><span class="line">    res.add(candidate_2);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfix</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstBuy= Integer.MIN_VALUE;</span><br><span class="line">  	<span class="keyword">int</span> firstSell=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> secondBuy= Integer.MIN_VALUE;</span><br><span class="line">  	<span class="keyword">int</span> secondSell= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">        secondSell= Math.max(secondBuy+price, secondSell);</span><br><span class="line">      	secondBuy= Math.max(firstSell- price, secondBuy);</span><br><span class="line">      	firstSell= Math.max(firstBuy+price, firstSell);</span><br><span class="line">      	firstBuy= Math.max(firstBuy, -price);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state 1: after buy;</span></span><br><span class="line">        <span class="comment">// state 2: after sell;</span></span><br><span class="line">        <span class="comment">// buy[i] means until day i, the last action is buy, the max profit;</span></span><br><span class="line">        <span class="comment">// buy[i]=sell[i-2]-price[i];</span></span><br><span class="line">        <span class="comment">// sell[i] means until day j, the last action is sell, the max profit;</span></span><br><span class="line">        <span class="comment">// sell[i]=buy[i-1]+ price[i];</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] buy= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] sell= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        buy[<span class="number">0</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            buy[i]= Math.max(buy[i-<span class="number">1</span>], (i&gt;=<span class="number">2</span>?sell[i-<span class="number">2</span>]:<span class="number">0</span>)-prices[i]);</span><br><span class="line">            sell[i]= Math.max(sell[i-<span class="number">1</span>], buy[i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfix</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] buy= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">  	<span class="keyword">int</span>[] sell= <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">  	buy[<span class="number">0</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">  	sell[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        buy[i]= Math.max(sell[i-<span class="number">1</span>]-prices[i], buy[i-<span class="number">1</span>]);</span><br><span class="line">      	sell[i]= Math.max(buy[i-<span class="number">1</span>]+prices[i]- fee, sell[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros  &amp;&amp; Sort Colors"></a>Move zeros  &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1= <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> p2= nums.length-<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(index&lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index]==<span class="number">0</span> &amp;&amp; index&gt; p1)&#123;</span><br><span class="line">            swap(p1, index, nums);</span><br><span class="line">          	p1++;</span><br><span class="line">          	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span>(nums[index]==<span class="number">2</span> &amp;&amp; index&lt;p2)&#123;</span><br><span class="line">            swap(p2, index, nums);</span><br><span class="line">          	p2--;</span><br><span class="line">          	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	index++;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2, <span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp= nums[p1];</span><br><span class="line">      	nums[p1]= nums[p2];</span><br><span class="line">      	nums[p2]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/01/Big-Data-Interview-Questions/" rel="next" title="Big Data Interview Questions">
                <i class="fa fa-chevron-left"></i> Big Data Interview Questions
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/05/Interview-Record/" rel="prev" title="Interview Record">
                Interview Record <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Liyan Chen" />
            
              <p class="site-author-name" itemprop="name">Liyan Chen</p>
              <p class="site-description motion-element" itemprop="description">千江有水千江月， 万里无云万里天</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Lic128" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:lic128@eng.ucsd.edu" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-efficiently-hash-the-ip-address"><span class="nav-number">1.</span> <span class="nav-text">How to efficiently hash the ip-address</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-Two-Balanced-Binary-Search-Trees"><span class="nav-number">2.</span> <span class="nav-text">Merge Two Balanced Binary Search Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-1-Insert-elements-of-first-tree-to-second"><span class="nav-number">2.1.</span> <span class="nav-text">Method 1 : Insert elements of first tree to second.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-2-Merge-Inorder-Traversals"><span class="nav-number">2.2.</span> <span class="nav-text">Method 2: Merge Inorder Traversals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cherry-Picker"><span class="nav-number">3.</span> <span class="nav-text">Cherry Picker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">4.</span> <span class="nav-text">Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sqrt-x"><span class="nav-number">5.</span> <span class="nav-text">Sqrt(x)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-K"><span class="nav-number">6.</span> <span class="nav-text">Top K</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数据全部排序"><span class="nav-number">6.1.</span> <span class="nav-text">将数据全部排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部淘汰法"><span class="nav-number">6.2.</span> <span class="nav-text">局部淘汰法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Heap"><span class="nav-number">6.3.</span> <span class="nav-text">Heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分治法"><span class="nav-number">6.4.</span> <span class="nav-text">分治法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="nav-number">7.</span> <span class="nav-text">Leetcode 332. Reconstruct Itinerary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-handle-id-generation-on-a-hadoop-cluster"><span class="nav-number">8.</span> <span class="nav-text">How to handle id generation on a hadoop cluster?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Map-Reduce-to-implement-outer-left-join"><span class="nav-number">9.</span> <span class="nav-text">Using Map Reduce to implement outer left join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Can-you-Override-Main-method-in-Java"><span class="nav-number">10.</span> <span class="nav-text">Can you Override Main method in Java?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intersection-of-Two-Arrays"><span class="nav-number">11.</span> <span class="nav-text">Intersection of Two Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Follow-up"><span class="nav-number">11.1.</span> <span class="nav-text">Follow up:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Answer-to-follow-up"><span class="nav-number">11.2.</span> <span class="nav-text">Answer to follow up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code"><span class="nav-number">11.3.</span> <span class="nav-text">code:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subsequence-with-sub-closest-to-t"><span class="nav-number">12.</span> <span class="nav-text">Subsequence with sub closest to t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Robber"><span class="nav-number">13.</span> <span class="nav-text">House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="nav-number">14.</span> <span class="nav-text">Leetcode 329. Longest Increasing Path in a Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#code-1"><span class="nav-number">14.1.</span> <span class="nav-text">code</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coins-in-a-line"><span class="nav-number">15.</span> <span class="nav-text">Coins in a line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stone-Game"><span class="nav-number">16.</span> <span class="nav-text">Stone Game</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小调整代价"><span class="nav-number"></span> <span class="nav-text">最小调整代价</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ugly-Number"><span class="nav-number">1.</span> <span class="nav-text">Ugly Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树查找树中搜索区间"><span class="nav-number">2.</span> <span class="nav-text">二叉树查找树中搜索区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Majority-Element-II"><span class="nav-number">3.</span> <span class="nav-text">Majority Element II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">4.</span> <span class="nav-text">Leetcode 123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><span class="nav-number">5.</span> <span class="nav-text">Leetcode 309. Best Time to Buy and Sell Stock with cooldown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-zeros-amp-amp-Sort-Colors"><span class="nav-number">6.</span> <span class="nav-text">Move zeros  && Sort Colors</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyan Chen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
