<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Detect Cycle in Graph | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Detect cycle in graphDetect cycle in an undirected graphGiven an undirected graph, how to check if there is a cycle in the graph? We have discussed cycle detection for directed graph, We have also dis">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Detect Cycle in Graph">
<meta property="og:url" content="http://yoursite.com/2018/02/03/Detect-Cycle-in-Graph/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Detect cycle in graphDetect cycle in an undirected graphGiven an undirected graph, how to check if there is a cycle in the graph? We have discussed cycle detection for directed graph, We have also dis">
<meta property="og:updated_time" content="2018-02-04T05:50:36.019Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Detect Cycle in Graph">
<meta name="twitter:description" content="Detect cycle in graphDetect cycle in an undirected graphGiven an undirected graph, how to check if there is a cycle in the graph? We have discussed cycle detection for directed graph, We have also dis">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Detect-Cycle-in-Graph" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Detect-Cycle-in-Graph/" class="article-date">
  <time datetime="2018-02-04T05:47:46.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Detect Cycle in Graph
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Detect-cycle-in-graph"><a href="#Detect-cycle-in-graph" class="headerlink" title="Detect cycle in graph"></a>Detect cycle in graph</h1><h2 id="Detect-cycle-in-an-undirected-graph"><a href="#Detect-cycle-in-an-undirected-graph" class="headerlink" title="Detect cycle in an undirected graph"></a>Detect cycle in an undirected graph</h2><p>Given an undirected graph, how to check if there is a cycle in the graph?</p>
<p>We have discussed cycle detection for directed graph, We have also discussed a union-find algorithm for cycle detection in undirected graphs. The time complexity of the union-find algorithm is O(ElogV). Like directed graph, we can use DFS to detect cycle in an undirected graph in O(V+E) time. We do a DFS traversal of the given graph. For every visited vertex ‘v’, if there is an adjacent ‘u’ such that u is already visited and u is not parent of v, then there is a cycle in graph. If we don’t find such an adjacent for any vertex, we say that there is no cycle. The assumption of this approach is that there are no parallel edges between ant two vertices.</p>
<h2 id="Detect-Cycle-in-a-Directed-Graph"><a href="#Detect-Cycle-in-a-Directed-Graph" class="headerlink" title="Detect Cycle in a Directed Graph"></a>Detect Cycle in a Directed Graph</h2><p>Given a directed graph, check whether the graph contains a cycle or not. Your function should return true if the given graph contains at least one cycle, else return false;</p>
<p>Depth first Traversal can be used to detect cycle in a Graph. DFS for a connected graph produces a tree, There is a cycle in a graph only if there is a back edge present in the graph. A back edge is an edge that is from a node to itself or one of its ancestor in the tree produced by DFS.</p>
<p>For a disconnected graph, we get the DFS forest as output. To detect cycle, we can check for cycle in individual trees by checking back edges.</p>
<p>To detect a back edge, we can keep track of vertices currently in recursion stack of function for DFS traversal. If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree. The edge that connects current vertex to the vertex in the recursion stack is back edge.</p>
<h2 id="Leetcode-261-Graph-Valid-Tree"><a href="#Leetcode-261-Graph-Valid-Tree" class="headerlink" title="Leetcode 261. Graph Valid Tree"></a>Leetcode 261. Graph Valid Tree</h2><p><a href="https://discuss.leetcode.com/category/330" target="_blank" rel="noopener">Discuss</a><a href="https://leetcode.com/problems/random-one-question/" target="_blank" rel="noopener">**Pick One</a></p>
<hr>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // Union- Find</span><br><span class="line">    // public boolean validTree(int n, int[][] edges) &#123;</span><br><span class="line">    //     int[] root= new int[n];</span><br><span class="line">    //     int count=n;</span><br><span class="line">    //     for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    //         root[i]= i;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     for(int[] edge: edges)&#123;</span><br><span class="line">    //         int root1= find(root, edge[0]);</span><br><span class="line">    //         int root2= find(root, edge[1]);</span><br><span class="line">    //         if(root1==root2) return false;</span><br><span class="line">    //         root[root1]= root2;</span><br><span class="line">    //         count--;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return count==1;</span><br><span class="line">    // &#125;</span><br><span class="line">    // private int find(int[] root, int id)&#123;</span><br><span class="line">    //     while(root[id]!= id)&#123;</span><br><span class="line">    //         root[id]= root[root[id]];</span><br><span class="line">    //         id= root[id];</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return id;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">    // bfs</span><br><span class="line">    // public boolean validTree(int n, int[][] edges)&#123;</span><br><span class="line">    //     Map&lt;Integer, Set&lt;Integer&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">    //     int[] degree= new int[n];</span><br><span class="line">    //     for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    //         map.put(i, new HashSet&lt;Integer&gt;());</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     for(int[] edge: edges)&#123;</span><br><span class="line">    //         map.get(edge[0]).add(edge[1]);</span><br><span class="line">    //         map.get(edge[1]).add(edge[0]);</span><br><span class="line">    //         degree[edge[0]]++;</span><br><span class="line">    //         degree[edge[1]]++;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     Queue&lt;Integer&gt; queue= new LinkedList&lt;&gt;();</span><br><span class="line">    //     boolean[] visited= new boolean[n];</span><br><span class="line">    //     int count=0;</span><br><span class="line">    //     for(int i=0; i&lt;degree.length; i++)&#123;</span><br><span class="line">    //         if(degree[i]&lt;=1)&#123;</span><br><span class="line">    //             queue.offer(i);</span><br><span class="line">    //             count++;</span><br><span class="line">    //             visited[i]= true;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     while(!queue.isEmpty())&#123;</span><br><span class="line">    //         int size= queue.size();</span><br><span class="line">    //         for(int i=0; i&lt;size; i++)&#123;</span><br><span class="line">    //             int node= queue.poll();</span><br><span class="line">    //             for(int next: map.get(node))&#123;</span><br><span class="line">    //                 degree[next]--;</span><br><span class="line">    //                 if(degree[next]&lt;=1 &amp;&amp; !visited[next])&#123;</span><br><span class="line">    //                     queue.offer(next);</span><br><span class="line">    //                     visited[next]= true;</span><br><span class="line">    //                     count++;</span><br><span class="line">    //                 &#125;</span><br><span class="line">    //             &#125;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return count==n &amp;&amp; edges.length==n-1;</span><br><span class="line">    // &#125;</span><br><span class="line">    // dfs</span><br><span class="line">    boolean hasCycle= false;</span><br><span class="line">    public boolean validTree(int n, int[][] edges)&#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">            map.put(i, new HashSet&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for(int[] edge: edges)&#123;</span><br><span class="line">            map.get(edge[0]).add(edge[1]);</span><br><span class="line">            map.get(edge[1]).add(edge[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] visited= new boolean[n];</span><br><span class="line">        dfs(map, visited, 0, 0);</span><br><span class="line">        if(hasCycle) return false;</span><br><span class="line">        for(int i=0; i&lt;visited.length; i++)&#123;</span><br><span class="line">            if(!visited[i]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dfs(Map&lt;Integer, Set&lt;Integer&gt;&gt; map, boolean[] visited, int curr, int prev)&#123;</span><br><span class="line">        visited[curr]= true;</span><br><span class="line">        for(int next: map.get(curr))&#123;</span><br><span class="line">            if(visited[next] &amp;&amp; next!= prev)&#123;</span><br><span class="line">                hasCycle= true;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if(visited[next]) continue;</span><br><span class="line">            dfs(map, visited, next, curr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Detect-Cycle-in-Graph/" data-id="cjd8dvpvg000148zhpy40oyz8" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/03/Intro-to-Python/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Intro to Python
        
      </div>
    </a>
  
  
    <a href="/2018/02/03/Behavior-Questions/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Behavior Questions</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Data-Structure/">Java, Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java-Algorithm/" style="font-size: 15px;">Java, Algorithm</a> <a href="/tags/Java-Data-Structure/" style="font-size: 10px;">Java, Data Structure</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/03/Java面试问题/">Java面试问题</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(一)/">算法(一)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(二)/">算法(二)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试问题之海量数据/">面试问题之海量数据</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Java线程简介/">Java线程简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>