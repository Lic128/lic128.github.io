<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java面试问题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java Interview QuestionsWhat if the main method is declared as private?The program compiles properly but at runtime it will give “Main method not public.” message. What if the static modifier is remov">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试问题">
<meta property="og:url" content="http://yoursite.com/2018/02/03/Java面试问题/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java Interview QuestionsWhat if the main method is declared as private?The program compiles properly but at runtime it will give “Main method not public.” message. What if the static modifier is remov">
<meta property="og:updated_time" content="2018-02-04T05:56:27.566Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试问题">
<meta name="twitter:description" content="Java Interview QuestionsWhat if the main method is declared as private?The program compiles properly but at runtime it will give “Main method not public.” message. What if the static modifier is remov">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Java面试问题/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java面试问题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-Interview-Questions"><a href="#Java-Interview-Questions" class="headerlink" title="Java Interview Questions"></a>Java Interview Questions</h1><h2 id="What-if-the-main-method-is-declared-as-private"><a href="#What-if-the-main-method-is-declared-as-private" class="headerlink" title="What if the main method is declared as private?"></a>What if the main method is declared as private?</h2><p>The program compiles properly but at runtime it will give “Main method not public.” message.</p>
<h2 id="What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method"><a href="#What-if-the-static-modifier-is-removed-from-the-signature-of-the-main-method" class="headerlink" title="What if the static modifier is removed from the signature of the main method?"></a>What if the static modifier is removed from the signature of the main method?</h2><p>Program compiles. But at runtime throws an error “NoSuchMethodError”.</p>
<h2 id="What-if-I-write-static-public-void-instead-of-public-static-void"><a href="#What-if-I-write-static-public-void-instead-of-public-static-void" class="headerlink" title="What if I write static public void instead of public static void?"></a>What if I write static public void instead of public static void?</h2><p>Program compiles and runs properly.</p>
<h2 id="What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method"><a href="#What-if-I-do-not-provide-the-String-array-as-the-argument-to-the-method" class="headerlink" title="What if I do not provide the String array as the argument to the method?"></a>What if I do not provide the String array as the argument to the method?</h2><p>Program compiles but throws a runtime error “NoSuchMethodError”.</p>
<h2 id="What-is-the-first-argument-of-the-String-array-in-main-method"><a href="#What-is-the-first-argument-of-the-String-array-in-main-method" class="headerlink" title="What is the first argument of the String array in main method?"></a>What is the first argument of the String array in main method?</h2><p>The String array is empty. It does not have any element. This is unlike C/C++ where the first element by default is the program name.</p>
<h2 id="If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null"><a href="#If-I-do-not-provide-any-arguments-on-the-command-line-them-the-String-array-of-Main-method-will-be-empty-or-null" class="headerlink" title="If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?"></a>If I do not provide any arguments on the command line, them the String array of Main method will be empty or null?</h2><p>It is empty. But not null.</p>
<h2 id="How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code"><a href="#How-can-one-prove-that-the-array-is-not-null-but-empty-using-one-line-of-code" class="headerlink" title="How can one prove that the array is not null but empty using one line of code?"></a>How can one prove that the array is not null but empty using one line of code?</h2><p>Print args.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print args.length.</p>
<h2 id="What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs"><a href="#What-environment-variables-do-I-need-to-set-on-my-machine-in-order-to-be-able-to-run-Java-programs" class="headerlink" title="What environment variables do I need to set on my machine in order to be able to run Java programs?"></a>What environment variables do I need to set on my machine in order to be able to run Java programs?</h2><p>CLASPATH and PATH are the two variables.</p>
<h2 id="Can-an-application-have-multiple-classes-having-main-method"><a href="#Can-an-application-have-multiple-classes-having-main-method" class="headerlink" title="Can an application have multiple classes having main method?"></a>Can an application have multiple classes having main method?</h2><p>Yes it is possible. While starting the application we mention the class name to be run. The JVM will look for the Main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.</p>
<h2 id="Can-I-have-multiple-methods-in-the-same-class"><a href="#Can-I-have-multiple-methods-in-the-same-class" class="headerlink" title="Can I have multiple methods in the same class?"></a>Can I have multiple methods in the same class?</h2><p>No the program fails to compile. The compiler says that the main method is already defined in the class.</p>
<h2 id="Do-I-need-to-import-java-lang-package-any-time-Why"><a href="#Do-I-need-to-import-java-lang-package-any-time-Why" class="headerlink" title="Do I need to import java.lang package any time? Why?"></a>Do I need to import java.lang package any time? Why?</h2><p>No. It is by default loaded internally by the JVM.</p>
<h2 id="Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime"><a href="#Can-I-import-same-package-class-twice-will-the-JVM-load-the-package-twice-at-runtime" class="headerlink" title="Can I import same package/class twice? will the JVM load the package twice at runtime?"></a>Can I import same package/class twice? will the JVM load the package twice at runtime?</h2><p>one can import the same package or same class multiple times. Neither complier nor JVM complains about it. And the JVM will internally load the class only once no matter how many times you import the same class.</p>
<h2 id="What-are-Checked-and-UnChecked-Exception"><a href="#What-are-Checked-and-UnChecked-Exception" class="headerlink" title="What are Checked and UnChecked Exception?"></a>What are Checked and UnChecked Exception?</h2><p>A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses.<br>Making an exception checked forces client programmers to deal with the possibility that the exception will be thrown. eg, IOException thrown by java.io.FileInputStream’s read() method·<br>Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked. With an unchecked exception, however, the compiler doesn’t force client programmers either to catch the<br>exception or declare it in a throws clause. In fact, client programmers may not even know that the exception could be thrown. eg, StringIndexOutOfBoundsException thrown by String’s charAt() method· Checked exceptions must be caught at compile time. Runtime exceptions do not need to be. Errors often cannot be.</p>
<h2 id="What-is-Overriding"><a href="#What-is-Overriding" class="headerlink" title="What is Overriding?"></a>What is Overriding?</h2><p>When a class defines a method using the same name, return type, and arguments as a method in its superclass, the method in the class overrides the method in the superclass. when the method is invoked for an object of the class, it is the new definition of the method that is called,and not the method definition from the superclass. Methods may be overridden to be more public, not more private.</p>
<h2 id="What-are-different-types-of-inner-classes"><a href="#What-are-different-types-of-inner-classes" class="headerlink" title="What are different types of inner classes?"></a>What are different types of inner classes?</h2><h3 id="Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes"><a href="#Nested-top-level-classes-Member-classes-Local-classes-Anonymous-classes" class="headerlink" title="Nested top-level classes, Member classes, Local classes, Anonymous classes."></a>Nested top-level classes, Member classes, Local classes, Anonymous classes.</h3><p>参考： <a href="https://www.jianshu.com/p/3ec6aa56fe6a" target="_blank" rel="noopener">java中的四种内部类</a></p>
<h4 id="Nested-top-level-classes"><a href="#Nested-top-level-classes" class="headerlink" title="Nested top-level classes"></a>Nested top-level classes</h4><p>If you declare a class within a class and specify the static modifier, the compiler treats the class just like any other top-level class.</p>
<p>Any class outside the declaring class accesses the nested class with the declaring class name acting similarly to a package. eg, outer.inner. Top-level inner classes implicitly have access only to static variables. There can also be inner interfaces. All of these are of the nested top-level variety.</p>
<p>静态内部类也是定义在另一个类里面的类， 只不过在类的前面多了一个关键字static。 静态内部类是不需要依赖于外部类的， 这点和类的静态成员属性有点类似。并且它不能使用内部类的非static成员变量或者方法， 这点很好理解， 因为在没有外部类的对象的情况下， 可以创建静态内部类的对象， 如果允许访问外部类的非static成员就会产生矛盾， 因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">	static class Inner &#123;</span><br><span class="line">		void go() &#123;</span><br><span class="line">			System.out.println(&quot;Inner class reference is: &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer.Inner n = new Outer.Inner();</span><br><span class="line">		n.go();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Member-classes"><a href="#Member-classes" class="headerlink" title="Member classes"></a>Member classes</h4><p>Member inner classes are just like other member methods and member variables and access to the member class is restricted, just like methods and variables. This means a public member classes acts similarly to a nested top-level class. The primary difference between member classes and nested top-level classes is that member classes is that member classes have access to the specific instance of the enclosing class.</p>
<p>成员内部类， 就是作为外部类的成员， 可以直接使用外部类的所有成员和方法， 即使是private的。 同时外部类要访问内部类的所有成员变量/方法， 则需要通过内部类的对象来获取。</p>
<p>要注意的是， 成员内部类不能含有static的变量和方法。 因为成员内部类需要先创建了外部类， 才能创建它自己的。</p>
<p>在成员内部类要引用外部类对象时， 使用outer.this 来表示外部类对象； 创建内部类对象， 可以使用 outer.inner obj= outerobj. new innier();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int x = 100;</span><br><span class="line"> </span><br><span class="line">    public void makeInner()&#123;</span><br><span class="line">        Inner in = new Inner();</span><br><span class="line">        in.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Inner&#123;</span><br><span class="line">        public void seeOuter()&#123;</span><br><span class="line">            System.out.println(&quot;Outer x is &quot; + x);</span><br><span class="line">            System.out.println(&quot;Inner class reference is &quot; + this);</span><br><span class="line">            System.out.println(&quot;Outer class reference is &quot; + Outer.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">    	Outer o = new Outer();</span><br><span class="line">        Inner i = o.new Inner();</span><br><span class="line">        i.seeOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Local-classes"><a href="#Local-classes" class="headerlink" title="Local classes"></a>Local classes</h4><p>Local classes are like local variables, specific to a block of code. Their visibility is only within the block of their declaration. In order for the class to be useful beyond the declaration block, it would need to implement a more publicly available interface.Because local classes are not members, the modifiers public, protected, private, and static are not usable.</p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类， 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">	private String x = &quot;outer&quot;;</span><br><span class="line"> </span><br><span class="line">	public void doStuff() &#123;</span><br><span class="line">		class MyInner &#123;</span><br><span class="line">			public void seeOuter() &#123;</span><br><span class="line">				System.out.println(&quot;x is &quot; + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		MyInner i = new MyInner();</span><br><span class="line">		i.seeOuter();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outer o = new Outer();</span><br><span class="line">		o.doStuff();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Anonymous-classes"><a href="#Anonymous-classes" class="headerlink" title="Anonymous classes"></a>Anonymous classes</h4><p>Anonymous inner classes extend local inner classes one level further. As anonymous classes have no name, you cannot provide a constructor.</p>
<p>匿名内部类最常使用的情况就是在多线程的实现上， 因为要实现多线程必须继承Thread类或者实现Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(new ActionListener()&#123;</span><br><span class="line">     public void actionPerformed(ActionEvent e)&#123;</span><br><span class="line">         comp.setText(&quot;Button has been clicked&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="What-is-the-difference-between-an-Interface-and-an-abstract-class"><a href="#What-is-the-difference-between-an-Interface-and-an-abstract-class" class="headerlink" title="What is the difference between an Interface and an abstract class?"></a>What is the difference between an Interface and an abstract class?</h2><p>An abstract class can have instance methods that implement a default behavior. An Interface can only declare constants and instance methods, but cannot implements default behavior and all methods are implicitly abstract . An interface has all public members and no implementation. Am abstract class is a class which may have the usual flavors of class members(private , protected, etc.), but has some abstract methods.</p>
<p>抽象类是用来捕捉子类中的通用特性的。 它不能被实例化， 只能被用作子类的超类。 抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;</span><br><span class="line">    // abstract method</span><br><span class="line">    abstract void service(ServletRequest req, ServletResponse res);</span><br><span class="line"> </span><br><span class="line">    void init() &#123;</span><br><span class="line">        // Its implementation</span><br><span class="line">    &#125;</span><br><span class="line">    // other method related to Servlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当HttpServlet类继承GenericServlet 时， 它提供了service方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServlet extends GenericServlet &#123;</span><br><span class="line">    void service(ServletRequest req, ServletResponse res) &#123;</span><br><span class="line">        // implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        // Implementation</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // some other methods related to HttpServlet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是抽象方法的集合。 如果一个类实现了某个接口， 那么它就继承了这个接口的抽象方法。 这就像契约模式， 如果实现了这个接口， 那么就必须确保使用这些方法。 接口只是一种形式， 接口自身不能做任何事情。 以Externalizable接口为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Externalizable extends Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    void writeExternal(ObjectOutput out) throws IOException;</span><br><span class="line"> </span><br><span class="line">    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你实现这个接口时， 你就需要实现上面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements Externalizable &#123;</span><br><span class="line"> </span><br><span class="line">    int employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<p>Oracle已经开始尝试向接口中引入默认方法和静态方法， 以此来减少抽象类和接口之间的差异。 现在， 我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。</p>
<h2 id="Describe-synchronization-in-respect-to-multithreading"><a href="#Describe-synchronization-in-respect-to-multithreading" class="headerlink" title="Describe synchronization in respect to multithreading."></a>Describe synchronization in respect to multithreading.</h2><p>With respect to multithreading, synchronization is the capability to control the access of multiple threads to shared resources. Without synchronization, it is possible for one thread to modify a shared variables while another thread is in the process of using or updating same shared variable. This usually leads to significant errors.</p>
<h2 id="Explain-different-way-of-using-thread"><a href="#Explain-different-way-of-using-thread" class="headerlink" title="Explain different way of using thread?"></a>Explain different way of using thread?</h2><p>The thread could be implemented by using runnable interface or by inheriting from the Thread class. The former is more advantageous, ‘cause when you are going for multiple inheritance, the only interface can help.</p>
<h2 id="Difference-between-HashMap-and-HashTable"><a href="#Difference-between-HashMap-and-HashTable" class="headerlink" title="Difference between HashMap and HashTable?"></a>Difference between HashMap and HashTable?</h2><p>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesnt allow). HashMap does not guarantee that the order of the map will remain constant over time. HashMap is unsynchronized and Hashtable is synchronized.</p>
<h2 id="What-is-the-difference-between-a-constructor-and-a-method"><a href="#What-is-the-difference-between-a-constructor-and-a-method" class="headerlink" title="What is the difference between a constructor and a method?"></a>What is the difference between a constructor and a method?</h2><p>A constructor is a member function of a class that is used to create objects of that class. It has the same name as the class itself, has no return type, and is invoked using the new operator.<br>A method is an ordinary member function of a class. It has its own name, a return type (which may be void), and is invoked using the dot operator.</p>
<h2 id="What-is-an-Iterator"><a href="#What-is-an-Iterator" class="headerlink" title="What is an Iterator?"></a>What is an Iterator?</h2><p>Some of the collection classes provide traversal of their contents via a java.util.Iterator interface. This interface allows you to walk through a collection of objects, operating on each object in turn. Remember when using Iterators that they contain a snapshot of the collection at the time the Iterator was obtained; generally it is not advisable to modify the collection itself while traversing an Iterator.</p>
<h2 id="State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers"><a href="#State-the-significance-of-public-private-protected-default-modifiers-both-singly-and-in-combination-and-state-the-effect-of-package-relationships-on-declared-items-qualified-by-these-modifiers" class="headerlink" title="State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers."></a>State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers.</h2><p><strong><em>public : \</em></strong>Public class is visible in other packages, field is visible everywhere (class must be public too)<br><strong><em>private :\</em></strong> Private variables or methods may be used only by an instance of the same class that declares the variable or method, A private feature may only be accessed by the class that owns the feature.<br><strong><em>protected :\</em></strong> Is available to all classes in the same package and also available to all subclasses of the class that owns the protected feature.This access is provided even to subclasses that reside in a different package from the class that owns the protected feature.<br><strong><em>default :\</em></strong>What you get by default ie, without any access modifier (ie, public private or protected).It means that it is visible to all within a particular package.</p>
<h2 id="What-is-static-in-Java"><a href="#What-is-static-in-Java" class="headerlink" title="What is static in Java?"></a>What is static in Java?</h2><p>static means one per class, not one for each object no matter how many instance of a class might exist. This means that you can use them without creating an instance of a class. Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can’t override a static method with a non-static method. In other words, you can’t change a static method into an instance method in a subclass.</p>
<p>Static methods can be overriden, but they cannot be overriden to be non-static,Whereas final methods cannot be overridden.</p>
<p>A static method is a method that’s invoked through a class, rather than a specific object of that class. Static methods can only access static variables – they can’t use anything that’s specific to a particular object. Nonstatic methods (or instance methods) must be called on a specific object and can use the object’s instance data.<br>A final method is just a method that cannot be overridden – while static methods are implicitly final, you might also want to create an final instance method.</p>
<p>In this code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    public static void method() &#123;</span><br><span class="line">        System.out.println(&quot;in Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the static method in Bar ‘hides’ the static method declared in Foo, as opposed to overriding it in the polymorphism sense.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Foo.method();</span><br><span class="line">        Bar.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>will output:</p>
<p>in Foo<br>in Bar</p>
<p>Re-defining method() as final in Foo will disable the ability for Bar to hide it, and re-running main() will output:</p>
<p>in Foo<br>in Foo</p>
<p>Compilation fails when you mark the method as final, and only runs again when remove Bar.method()</p>
<p>Final will prevent the method from being hidden by subclasses .</p>
<h2 id="Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests"><a href="#Does-importing-a-package-imports-the-subpackages-as-well-e-g-Does-importing-com-Test-also-import-com-MyTest-UnitTests" class="headerlink" title="Does importing a package imports the subpackages as well? e.g. Does importing com.Test. also import com.MyTest.UnitTests.?"></a>Does importing a package imports the subpackages as well? e.g. Does importing com.Test.<em> also import com.MyTest.UnitTests.</em>?</h2><p>No you will have to import the subpackage explicitly. Importing com.MyTest.* will import classes in the package MyTest only. It will not import any class in any of it’s subpackage.</p>
<h2 id="What-is-serialization"><a href="#What-is-serialization" class="headerlink" title="What is serialization?"></a>What is serialization?</h2><p>Serialization is a mechanism by which you can save the state of an object by converting it to a byte stream.</p>
<p>The serializable interface is an empty interface. It does not contain any methods. So we do not implement ant methods.</p>
<h2 id="What-is-the-common-usage-of-serialization"><a href="#What-is-the-common-usage-of-serialization" class="headerlink" title="What is the common usage of serialization?"></a>What is the common usage of serialization?</h2><p>Whenever an object is to be sent over the network, objects need to be serialized. Moreover if the state of an object is to be saved, objects need to be serialized.</p>
<h2 id="What-are-wrapper-classes"><a href="#What-are-wrapper-classes" class="headerlink" title="What are wrapper classes?"></a>What are wrapper classes?</h2><p>java provides specialized classes corresponding to each of the primitive data types. These are called wrapper classes. They are e.g. Integer, Character, Double etc.</p>
<h2 id="What-are-the-different-ways-to-handle-exceptions"><a href="#What-are-the-different-ways-to-handle-exceptions" class="headerlink" title="What are the different ways to handle exceptions?"></a>What are the different ways to handle exceptions?</h2><p>There are two ways to handle exceptions,</p>
<ol>
<li>By wrapping the desired code in a try block followed by a catch block to catch the exceptions.</li>
<li>Lit the desired exceptions in the throws clause of the method and let the caller of the method handle those exceptions.</li>
</ol>
<h2 id="Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block"><a href="#Is-it-necessary-that-each-try-block-must-be-followed-by-a-catch-block" class="headerlink" title="Is it necessary that each try block must be followed by a catch block?"></a>Is it necessary that each try block must be followed by a catch block?</h2><p>It is not necessary that each catch block must be followed by a catch block. It should be followed by either a catch block or a finally block. And whatever exceptions are likely to be thrown should be declared in the throws clause if the method.</p>
<h2 id="If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt"><a href="#If-I-write-return-at-the-end-of-the-try-block-will-the-finally-block-still-execute-gt" class="headerlink" title="If I write return at the end of the try block, will the finally block still execute&gt;"></a>If I write return at the end of the try block, will the finally block still execute&gt;</h2><p>Yes even if you write return as the last statement in the try block and no exception occurs, the finally block will execute. The finally block will execute and then the control system.</p>
<h2 id="If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute"><a href="#If-I-write-System-exit-0-at-the-end-of-the-try-block-will-the-finally-block-still-execute" class="headerlink" title="If I write System.exit (0); at the end of the try block, will the finally block still execute?"></a>If I write System.exit (0); at the end of the try block, will the finally block still execute?</h2><p>No in this case the finally block will not execute because when you say System.exit (0); the control immediately goes out of the program, and thus finally never executes.</p>
<h2 id="Can-a-java-file-contain-more-than-one-java-classes"><a href="#Can-a-java-file-contain-more-than-one-java-classes" class="headerlink" title="Can a .java file contain more than one java classes?"></a>Can a .java file contain more than one java classes?</h2><p>Yes, a .java file contain more than one java classes, provided at the most one of of them is a public class.</p>
<h2 id="What-is-the-default-value-of-the-local-variables"><a href="#What-is-the-default-value-of-the-local-variables" class="headerlink" title="What is the default value of the local variables?"></a><strong>What is the default value of the local variables?</strong></h2><p>The local variables are not initialized to any default value, neither primitives nor object references. If you try to use these variables without initializing them explicitly, the java compiler will not compile the code. It will complain abt the local variable not being initialized.</p>
<h2 id="Can-we-Overload-main-method"><a href="#Can-we-Overload-main-method" class="headerlink" title="Can we Overload main() method?"></a>Can we Overload main() method?</h2><p>Yes. We can overload main() method. A java class can have any number of main() methods. But to run the java class. class should have main() method with signature as “public static void main(String[] args)”. If you do any modification to this signature, compilation will be successful. But, you can’t run the java program. You will get run time error as main method not found.</p>
<h2 id="Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier"><a href="#Can-we-declare-main-method-as-private-or-protected-or-with-no-access-modifier" class="headerlink" title="Can we declare main() method as private or protected or with no access modifier?"></a>Can we declare main() method as private or protected or with no access modifier?</h2><p>No, main() method must be public. You can’t define main() methods as private or protected or with no access modifier. This is because to make the main() method accessible to JVM. If you define main() method other than public, compilation will be successful but you will get run time error as no main method found.</p>
<h2 id="Can-we-Declare-main-Method-As-Non-Static"><a href="#Can-we-Declare-main-Method-As-Non-Static" class="headerlink" title="Can we Declare main() Method As Non-Static?"></a>Can we Declare main() Method As Non-Static?</h2><p>No, main() method must be declared as static so than JVM can call main() method without instantiating it’s class. If you remove “static” from main() method signature, compilation will be successful but program fails at run time.</p>
<h2 id="Can-we-change-return-type-of-main-method"><a href="#Can-we-change-return-type-of-main-method" class="headerlink" title="Can we change return type of main() method?"></a>Can we change return type of main() method?</h2><p>No. The return type of main() method must be void only. Any other type is not acceptable.</p>
<h2 id="Can-we-run-java-class-without-main-method"><a href="#Can-we-run-java-class-without-main-method" class="headerlink" title="Can we run java class without main() method?"></a>Can we run java class without main() method?</h2><p>No, you can’t run java class without main method. But, there are some scenarios like if super class has main() method. then sub class can be run without defining main() method in it.</p>
<h3 id="What-is-Thread-in-Java"><a href="#What-is-Thread-in-Java" class="headerlink" title="What is Thread in Java?"></a>What is Thread in Java?</h3><p>The thread is an independent path of execution. It’s way to take advantage of multiple CPU available in a machine. By employing multiple threads you can speed up CPU bound task. For example, if one thread takes 100 milliseconds to do a job, you can use 10 threads to reduce that task into 10 milliseconds. Java provides excellent support for multithreading at the language level, and it’s one of the strong selling points.</p>
<h3 id="What-is-the-difference-between-Thread-and-Process-in-Java"><a href="#What-is-the-difference-between-Thread-and-Process-in-Java" class="headerlink" title="What is the difference between Thread and Process in Java?"></a>What is the difference between Thread and Process in Java?</h3><p>The thread is a subset of Process, in other words, one process can contain multiple threads. Two process runs on different memory space, but all threads share same memory space. Don’t confuse this with stack memory, which is different for the different thread and used to store local data to that thread.</p>
<h3 id="How-do-you-implement-Thread-in-Java"><a href="#How-do-you-implement-Thread-in-Java" class="headerlink" title="How do you implement Thread in Java?"></a>How do you implement Thread in Java?</h3><p>At the language level, there are two ways to implement Thread in Java. An instance of java.lang.Thread represent a thread but it needs a task to execute, which is an instance of interface java.lang.Runnable. Since Thread class itself implement Runnable, you can override run() method by extending Thread class or just implementing Runnable interface.</p>
<h3 id="When-to-use-Runnable-vs-Thread-in-Java"><a href="#When-to-use-Runnable-vs-Thread-in-Java" class="headerlink" title="When to use Runnable vs Thread in Java?"></a>When to use Runnable vs Thread in Java?</h3><p>This question will be easy to answer if you know that Java programming language doesn’t support multiple inheritances of class, but it allows you to implement multiple interfaces. Which means, it’s better to implement Runnable then extends Thread if you also want to extend another class.</p>
<h3 id="What-is-the-difference-between-start-and-run-method-of-Thread-class"><a href="#What-is-the-difference-between-start-and-run-method-of-Thread-class" class="headerlink" title="What is the difference between start() and run() method of Thread class?"></a>What is the difference between start() and run() method of Thread class?</h3><p>start() method is used to start newly created thread, while start() internally calls run() method, there is difference calling run() method directly. When you invoke run() as normal method, it’s called in the same thread, no new thread is started, which is the case when you call start() method.</p>
<h3 id="What-is-the-difference-between-Runnable-and-Callable-in-Java"><a href="#What-is-the-difference-between-Runnable-and-Callable-in-Java" class="headerlink" title="What is the difference between Runnable and Callable in Java?"></a>What is the difference between Runnable and Callable in Java?</h3><p>Both Runnable and Callable represent task which is intended to be executed in a separate thread. Runnable is there from JDK 1.0 while Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. See my <a href="http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html" target="_blank" rel="noopener">blog post</a> on the same topic for a more in-depth answer to this question.</p>
<h3 id="What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java"><a href="#What-is-the-difference-between-CyclicBarrier-and-CountDownLatch-in-Java" class="headerlink" title="What is the difference between CyclicBarrier and CountDownLatch in Java?"></a>What is the difference between CyclicBarrier and CountDownLatch in Java?</h3><p>Though both CyclicBarrier and CountDownLatch wait for number of threads on one or more events, the main difference between them is that you can not re-use CountDownLatch once count reaches to zero, but you can reuse same CyclicBarrier even after barrier is broken.</p>
<h3 id="What-is-volatile-variable-in-Java"><a href="#What-is-volatile-variable-in-Java" class="headerlink" title="What is volatile variable in Java?"></a>What is volatile variable in Java?</h3><p>volatile is a special modifier, which can only be used with instance variables. In concurrent Java programs, changes made by multiple threads on instance variables is not visible to other in absence of any synchronizers e.g. synchronized keyword or locks. Volatile variable guarantees that a write will happen before any subsequent read: as stated:”volatile variable rule”.</p>
<h3 id="What-is-thread-safety-is-a-Vector-a-thread-safe-class"><a href="#What-is-thread-safety-is-a-Vector-a-thread-safe-class" class="headerlink" title="What is thread-safety? is a Vector a thread-safe class?"></a>What is thread-safety? is a Vector a thread-safe class?</h3><p>Thread-safety is a property of an object or code which guarantees that if executed or used by multiple threads in any manner. For example, a thread-safe counter object will not miss any count if same instance of that counter is shared among multiple threads. Apparently, you can also divide collection classes in two category, thread-safe and non-thread-safe. Vector is indeed a thread-safe class and it achieves thread-safety by synchronizing methods which modify state of Vector, on the other hand, its counterpart ArrayList is not thread-safe.</p>
<h3 id="How-to-stop-a-thread-in-Java"><a href="#How-to-stop-a-thread-in-Java" class="headerlink" title="How to stop a thread in Java?"></a>How to stop a thread in Java?</h3><p>I always said that Java provides rich APIs for everything but ironically Java doesn’t provide a sure shot way of stopping thread. There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which was deprecated in later releases due to potential deadlock threats, from then Java API designers has not made any effort to provide a consistent, thread-safe and elegant way to stop threads. Programmers mainly rely on the fact that thread stops automatically as soon as they finish execution of run() or call() method. To manually stop, programmers either take advantage of volatile boolean variable and check in every iteration if run method has loops or interrupt threads to abruptly cancel tasks. See this <a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="noopener">tutorial</a> for sample code of stopping thread in Java.</p>
<h3 id="What-happens-when-an-Exception-occurs-in-a-thread"><a href="#What-happens-when-an-Exception-occurs-in-a-thread" class="headerlink" title="What happens when an Exception occurs in a thread?"></a>What happens when an Exception occurs in a thread?</h3><p>This is one of the good <a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="noopener">tricky Java question</a> I have seen in interviews. In simple words, If not caught thread will die, if an uncaught exception handler is registered then it will get a call back. Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments.</p>
<h3 id="What-is-the-difference-between-notify-and-notifyAll-in-Java"><a href="#What-is-the-difference-between-notify-and-notifyAll-in-Java" class="headerlink" title="What is the difference between notify and notifyAll in Java?"></a>What is the difference between notify and notifyAll in Java?</h3><p>This is another tricky questions from core Java interviews, since multiple threads can wait on single monitor lock, Java API designer provides method to inform only one of them or all of them, once waiting condition changes, but they provide half implementation. There notify() method doesn’t provide any way to choose a particular thread, that’s why its only useful when you know that there is only one thread is waiting. On the other hand, notifyAll() sends notification to all threads and allows them to compete for locks, which ensures that at-least one thread will proceed further. See my <a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="noopener">blog post</a> on similar topic for a more detailed answer and code example.</p>
<h3 id="Why-wait-notify-and-notifyAll-are-not-inside-thread-class"><a href="#Why-wait-notify-and-notifyAll-are-not-inside-thread-class" class="headerlink" title="Why wait, notify and notifyAll are not inside thread class?"></a>Why wait, notify and notifyAll are not inside thread class?</h3><p>This is a design related question, which checks what candidate thinks about existing system or does he ever thought of something which is so common but looks in-appropriate at first. In order to answer this question, you have to give some reasons why it make sense for these three method to be in Object class, and why not on Thread class. One reason which is obvious is that Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object.</p>
<h3 id="What-is-ThreadLocal-variable-in-Java"><a href="#What-is-ThreadLocal-variable-in-Java" class="headerlink" title="What is ThreadLocal variable in Java?"></a>What is ThreadLocal variable in Java?</h3><p>ThreadLocal variables are special kind of variable available to Java programmer. Just like instance variable is per instance, ThreadLocal variable is per thread. It’s a nice way to achieve thread-safety of expensive-to-create objects, for example you can make SimpleDateFormat thread-safe using ThreadLocal. Since that class is expensive, its not good to use it in local scope, which requires separate instance on each invocation. By providing each thread their own copy, you shoot two birds with one arrow. First, you reduce number of instance of expensive object by reusing fixed number of instances, and Second, you achieve thread-safety without paying cost of synchronization or immutability. Another good example of thread local variable is ThreadLocalRandom class, which reduces number of instances of expensive-to-create Random object in multi-threading environment. See this <a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="noopener">answer</a> to learn more about thread local variables in Java.</p>
<h3 id="What-is-FutureTask-in-Java"><a href="#What-is-FutureTask-in-Java" class="headerlink" title="What is FutureTask in Java?"></a>What is FutureTask in Java?</h3><p>FutureTask represents a cancellable asynchronous computation in concurrent Java application. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get methods will block if the computation has not yet completed. A FutureTask object can be used to wrap a Callable or Runnable object. Since FutureTask also implements Runnable, it can be submitted to an Executor for execution.</p>
<h3 id="What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java"><a href="#What-is-the-difference-between-the-interrupted-and-isInterrupted-method-in-Java" class="headerlink" title="What is the difference between the interrupted() and isInterrupted() method in Java?"></a>What is the difference between the interrupted() and isInterrupted() method in Java?</h3><p>Main difference between interrupted() and isInterrupted() is that former clears the interrupt status while later does not. The interrupt mechanism in Java multi-threading is implemented using an internal flag known as the interrupt status. Interrupting a thread by calling Thread.interrupt() sets this flag. When interrupted thread checks for an interrupt by invoking the <a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="noopener">static method</a> Thread.interrupted(), interrupt status is cleared. The non-static isInterrupted() method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag. By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it’s always possible that interrupt status will immediately be set again, by another thread invoking interrupt</p>
<h3 id="Why-wait-and-notify-method-are-called-from-synchronized-block"><a href="#Why-wait-and-notify-method-are-called-from-synchronized-block" class="headerlink" title="Why wait and notify method are called from synchronized block?"></a>Why wait and notify method are called from synchronized block?</h3><p>Main reason for calling wait and notify method from either synchronized block or method is that it made mandatory by Java API. If you don’t call them from synchronized context, your code will throw IllegalMonitorStateException. A more subtle reason is to avoid the race condition between wait and notify calls.</p>
<h3 id="What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java"><a href="#What-is-the-difference-between-synchronized-and-concurrent-collection-in-Java" class="headerlink" title="What is the difference between synchronized and concurrent collection in Java?"></a>What is the difference between synchronized and concurrent collection in Java?</h3><p>Though both synchronized and concurrent collection provides thread-safe collection suitable for multi-threaded and concurrent access, later is more scalable than former. Before Java 1.5, Java programmers only had synchronized collection which becomes source of contention if multiple thread access them concurrently, which hampers scalability of system. Java 5 introduced concurrent collections like ConcurrentHashMap, which not only provides thread-safety but also improves scalability by using modern techniques like lock stripping and partitioning internal table.</p>
<h3 id="What-is-the-difference-between-Stack-and-Heap-in-Java"><a href="#What-is-the-difference-between-Stack-and-Heap-in-Java" class="headerlink" title="What is the difference between Stack and Heap in Java?"></a>What is the difference between Stack and Heap in Java?</h3><p>Why does someone this question as part of multi-threading and concurrency? because Stack is a memory area which is closely associated with threads. To answer this question, both stack and heap are specific memories in Java application. Each thread has their own stack, which is used to store local variables, method parameters and call stack. Variable stored in one Thread’s stack is not visible to other. On another hand, the heap is a common memory area which is shared by all threads. Objects whether local or at any level is created inside heap. To improve performance thread tends to cache values from heap into their stack, which can create problems if that variable is modified by more than one thread, this is where volatile variables come into the picture. volatile suggest threads read the value of variable always from main memory.</p>
<h3 id="What-is-thread-pool-Why-should-you-thread-poll-in-Java"><a href="#What-is-thread-pool-Why-should-you-thread-poll-in-Java" class="headerlink" title="What is thread pool? Why should you thread poll in Java?"></a>What is thread pool? Why should you thread poll in Java?</h3><p>Creating thread is expensive in terms of time and resource. If you create thread at time of request processing it will slow down your response time, also there is only a limited number of threads a process can create. To avoid both of these issues, a pool of thread is created when application starts-up and threads are reused for request processing. This pool of thread is known as “thread pool” and threads are known as worker thread. From JDK 1.5 release, Java API provides Executor framework, which allows you to create different types of thread pools e.g. single thread pool, which process one task at a time, fixed thread pool (a pool of fixed number of threads) or cached thread pool (an expandable thread pool suitable for applications with many short lived tasks).</p>
<h3 id="How-do-you-check-if-a-Thread-holds-a-lock-or-not"><a href="#How-do-you-check-if-a-Thread-holds-a-lock-or-not" class="headerlink" title="How do you check if a Thread holds a lock or not?"></a>How do you check if a Thread holds a lock or not?</h3><p>I didn’t even know that you can check if a Thread already holds lock before this question hits me in a telephonic round of Java interview. There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object.</p>
<h3 id="What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java"><a href="#What-is-the-difference-between-synchronized-and-ReentrantLock-in-Java" class="headerlink" title="What is the difference between synchronized and ReentrantLock in Java?"></a>What is the difference between synchronized and ReentrantLock in Java?</h3><p>There were days when the only way to provide mutual exclusion in Java was via synchronized keyword, but it has several shortcomings e.g. you can not extend lock beyond a method or block boundary, you can not give up trying for a lock etc. Java 5 solves this problem by providing more sophisticated control via Lock interface. ReentrantLock is a common implementation of Lock interface and provides re-entrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p>
<h3 id="There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java"><a href="#There-are-three-threads-T1-T2-and-T3-How-do-you-ensure-sequence-T1-T2-T3-in-Java" class="headerlink" title="There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?"></a>There are three threads T1, T2 and T3? How do you ensure sequence T1, T2, T3 in Java?</h3><p>Sequencing in multi-threading can be achieved by different means but you can simply use the join() method of thread class to start a thread when another one has finished its execution. To ensure three threads execute you need to start the last one first e.g. T3 and then call join methods in reverse order e.g. T3 calls T2. join and T2 calls T1.join, these ways T1 will finish first and T3 will finish last.</p>
<h3 id="What-does-yield-method-of-Thread-class-do"><a href="#What-does-yield-method-of-Thread-class-do" class="headerlink" title="What does yield method of Thread class do?"></a>What does yield method of Thread class do?</h3><p>Yield method is one way to request current thread to relinquish CPU so that other thread can get a chance to execute. Yield is a static method and only guarantees that current thread will relinquish the CPU but doesn’t say anything about which other thread will get CPU. Its possible for the same thread to get CPU back and start its execution again.</p>
<h3 id="What-is-Semaphore-in-Java"><a href="#What-is-Semaphore-in-Java" class="headerlink" title="What is Semaphore in Java?"></a>What is Semaphore in Java?</h3><p>Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool.</p>
<h3 id="What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled"><a href="#What-happens-if-you-submit-a-task-when-the-queue-of-the-thread-pool-is-already-filled" class="headerlink" title="What happens if you submit a task when the queue of the thread pool is already filled?"></a>What happens if you submit a task when the queue of the thread pool is already filled?</h3><p>This is another tricky question on my list. Many programmers will think that it will block until a task is cleared but its true. ThreadPoolExecutor’s submit() method throws RejectedExecutionException if the task cannot be scheduled for execution.</p>
<h3 id="What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java"><a href="#What-is-the-difference-between-the-submit-and-execute-method-thread-pool-in-Java" class="headerlink" title="What is the difference between the submit() and execute() method thread pool in Java?"></a>What is the difference between the submit() and execute() method thread pool in Java?</h3><p>Both methods are ways to submit a task to thread pools but there is a slight difference between them. execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. Its return type is void. On other hand submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods.</p>
<h3 id="What-is-ReadWriteLock-in-Java"><a href="#What-is-ReadWriteLock-in-Java" class="headerlink" title="What is ReadWriteLock in Java?"></a>What is ReadWriteLock in Java?</h3><p>In general, read write lock is the result of lock stripping technique to improve the performance of concurrent applications. In Java, ReadWriteLock is an interface which was added in Java 5 release. A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive. If you want you can implement this interface with your own set of rules, otherwise you can use ReentrantReadWriteLock, which comes along with JDK and supports a maximum of 65535 recursive write locks and 65535 read locks.</p>
<h3 id="What-is-the-difference-between-the-volatile-and-atomic-variable-in-java"><a href="#What-is-the-difference-between-the-volatile-and-atomic-variable-in-java" class="headerlink" title="What is the difference between the volatile and atomic variable in java?"></a>What is the difference between the volatile and atomic variable in java?</h3><p>This is an interesting question for Java programmer, at first, volatile and atomic variable look very similar, but they are different. Volatile variable provides you happens-before guarantee that a write will happen before any subsequent write, it doesn’t guarantee atomicity. For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly you have atomic version for other data type and reference variable as well.</p>
<h3 id="What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block"><a href="#What-happens-if-a-thread-throws-an-Exception-inside-synchronized-block" class="headerlink" title="What happens if a thread throws an Exception inside synchronized block?"></a>What happens if a thread throws an Exception inside synchronized block?</h3><p>This is one more tricky question for average Java programmer, if he can bring the fact about whether lock is released or not is a key indicator of his understanding. To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a <a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="noopener">finally block</a>.</p>
<h3 id="What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading"><a href="#What-is-the-difference-between-calling-wait-and-sleep-method-in-Java-multi-threading" class="headerlink" title="What is the difference between calling wait() and sleep() method in Java multi-threading?"></a>What is the difference between calling wait() and sleep() method in Java multi-threading?</h3><p>Though both wait and sleep introduce some form of pause in Java application, they are the tool for different needs. Wait method is used for inter-thread communication, it relinquishes lock if waiting for a condition is true and wait for notification when due to an action of another thread waiting condition becomes false. On the other hand sleep() method is just to relinquish CPU or stop execution of current thread for specified time duration. Calling sleep method doesn’t release the lock held by the current thread.</p>
<p>中文版： <a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">http://www.importnew.com/12773.html</a></p>
<p>When you synchronize a method, you are effectively synchronizing to the object itself. In the case of a static method, you’re synchronizing to the class of the object.</p>
<h3 id="how-does-Java-object-casting-work-behind-the-scene"><a href="#how-does-Java-object-casting-work-behind-the-scene" class="headerlink" title="how does Java object casting work behind the scene?"></a>how does Java object casting work behind the scene?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class parent&#123;</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends parent&#123;</span><br><span class="line">  @override</span><br><span class="line">  void A()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent p= new Parent();</span><br><span class="line">Child c= (Child) p;</span><br></pre></td></tr></table></figure>
<p>Essentially the parent class is treated like an interface might be. when you cast the child to the Parent, only the Parent API is available. However, the overridden method will still be called. So , if you do:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent p= (Parent) new Child()</span><br><span class="line">p.a()</span><br></pre></td></tr></table></figure>
<p>the Child’s public void a() will be called, even though it is being seem through the lens of the Parent class. However if you were to have a second method in the Child that the parent does not have, you would not be able to call that without casting the object back to a Child.</p>
<h3 id="hashcode-and-equals"><a href="#hashcode-and-equals" class="headerlink" title="hashcode() and equals()"></a>hashcode() and equals()</h3><p>我们以“类的用途”来讲hashCode()和equals()的关系分两种情况来说明。</p>
<ul>
<li><p>第一种， 不会创建类所对应的散列表</p>
<p>这里所说的不会创建类所对应的散列表是说： 我们不会在HashSet, hashTable, HashMap等等这些本质是散列表的数据结构中， 用到此类。</p>
<p>在这种情况下， 该类的hashCode()和equals没有关系。</p>
<p>在这种情况下， equals()用来比较该类的两个对象是否相等。 而hashCode()则根本没有任何作用， 所以不用理会hashcode()</p>
</li>
<li><p>第二种， 会创建类所对应的散列表</p>
<p>这里所说的会创建类对应的散列表是说， 我们会在hashset， hashtable， hashtable等等这些本质是散列表的数据结构中， 用到该类。</p>
<p>在这种情况下， 该类的hashCode() 和 equals()是有关系的:</p>
<ul>
<li><p>如果两个对象相等， 那么它们的hashCode()值一定相同。</p>
<p>这里的相等是指， 通过equals()比较两个对象时返回true。</p>
</li>
<li><p>如果两个对象hashCode()相等， 它们并不一定相等。</p>
</li>
</ul>
<p>因为在散列表中， hashcode()相等， 即两个键值对的哈希值相等， 然而哈希值相等， 并不一定能得出键值对相等。</p>
<p>此外， 在这种情况下， 若要判断两个对象是否相等， 除了要覆盖equals之外， 也要覆盖hashCode()函数。 否则， equals()无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest2&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        Person p4 = new Person(&quot;EEE&quot;, 100);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象 </span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 比较p1 和 p4， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc重写hashCode </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode()&#123;  </span><br><span class="line">            int nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">            return nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * @desc 覆盖equals方法 </span><br><span class="line">         */  </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;  </span><br><span class="line">            if(obj == null)&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //如果是同一个对象返回true，反之返回false  </span><br><span class="line">            if(this == obj)&#123;  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            //判断是否类型相同  </span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>这里有个比较好的例子， 由这个例子， 我们可以看出来， 因为通过这个来讲的话， hashset在进行add的时候， 我们先比较hashcode， 然后再进行equal。 所以， hashcode这个只和分桶有关， 我们还要通过equals的比较才能进行更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/Java面试问题/" data-id="cjd8dst4t000bauzhrp2sg99g" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/03/Node.js 学习笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Node.js 学习笔记
        
      </div>
    </a>
  
  
    <a href="/2018/02/03/Java-中HashMap的实现机制/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Java 中HashMap的实现机制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Data-Structure/">Java, Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java，-Algorithm/">Java， Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java-Algorithm/" style="font-size: 10px;">Java, Algorithm</a> <a href="/tags/Java-Data-Structure/" style="font-size: 10px;">Java, Data Structure</a> <a href="/tags/Java，-Algorithm/" style="font-size: 10px;">Java， Algorithm</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/03/Resume Review/">关于简历</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(一)/">算法(一)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(二)/">算法(二)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试问题之海量数据/">面试问题之海量数据</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试中的随机算法/">面试中的随机算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>