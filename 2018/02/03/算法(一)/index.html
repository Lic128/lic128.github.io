<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            算法(一) | 
        
        Sisyphus
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="这是一个找不到工作/妹子的老实人">
    <meta name="keywords" content="Programming,Java, Algorithm">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Sisyphus">
    <meta name="msapplication-starturl" content="http://lic128.me/2018/02/03/算法(一)/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Sisyphus">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://lic128.me/2018/02/03/算法(一)/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="算法(一) | Sisyphus">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="这是一个找不到工作/妹子的老实人">
    <meta property="og:article:tag" content="Java, Algorithm"> 

    
        <meta property="article:published_time" content="Sat Feb 03 2018 21:54:11 GMT-0800">
        <meta property="article:modified_time" content="Sat Feb 03 2018 22:05:13 GMT-0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://lic128.me/2018/02/03/算法(一)/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://lic128.me/2018/02/03/算法(一)/index.html",
    "headline": "算法(一)",
    "datePublished": "Sat Feb 03 2018 21:54:11 GMT-0800",
    "dateModified": "Sat Feb 03 2018 22:05:13 GMT-0800",
    "author": {
        "@type": "Person",
        "name": "Liyan Chen",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "醉里不知天在水，满船清梦压星河"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Sisyphus",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",Java, AlgorithmProgramming",
    "description": "这是一个找不到工作/妹子的老实人",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LeetCode-146-LRU-Cache"><span class="post-toc-number">1.</span> <span class="post-toc-text">LeetCode 146. LRU Cache</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-199-Evaluate-Division"><span class="post-toc-number">2.</span> <span class="post-toc-text">leetcode 199. Evaluate Division</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-1-dumb-dfs"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Solution 1: dumb dfs</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-2-union-find-algorithm"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Solution 2: union-find algorithm</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-628-Maximum-Product-of-Three-Numbers"><span class="post-toc-number">3.</span> <span class="post-toc-text">Leetcode 628. Maximum Product of Three Numbers</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><span class="post-toc-number">4.</span> <span class="post-toc-text">leetcode 159. Longest Substring with At Most Two Distinct Characters</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-465-Optimal-Account-Balancing"><span class="post-toc-number">5.</span> <span class="post-toc-text">leetcode 465. Optimal Account Balancing</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-464-Can-I-Win"><span class="post-toc-number">6.</span> <span class="post-toc-text">Leetcode 464. Can I Win</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-1"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">Solution:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-297-Serialize-and-Deserialize-Binary-Tree"><span class="post-toc-number">7.</span> <span class="post-toc-text">leetcode 297. Serialize and Deserialize Binary Tree</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-2"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-339-Nested-List-Weight-Sum"><span class="post-toc-number">8.</span> <span class="post-toc-text">leetcode 339. Nested List Weight Sum</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-3"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-364-Nested-List-Weight-Sum-II"><span class="post-toc-number">9.</span> <span class="post-toc-text">Leetcode 364. Nested List Weight Sum II</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-4"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-405-Convert-a-Number-to-Hexadecimal"><span class="post-toc-number">10.</span> <span class="post-toc-text">leetcode 405. Convert a Number to Hexadecimal</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-5"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-Find-Leaves-of-Binary-Tree"><span class="post-toc-number">11.</span> <span class="post-toc-text">leetcode: Find Leaves of Binary Tree</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-6"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-15-3Sum"><span class="post-toc-number">12.</span> <span class="post-toc-text">Leetcode 15: 3Sum</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-7"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-33-Search-in-Rotated-Sorted-Array"><span class="post-toc-number">13.</span> <span class="post-toc-text">Leetcode 33. Search in Rotated Sorted Array</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-8"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">Solution</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Follow-Up-1-what-if-there-are-duplicate-exists"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">Follow-Up 1, what if there are duplicate exists?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#follow-up-solution-1"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">follow-up solution 1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#follow-up-solution-2"><span class="post-toc-number">13.4.</span> <span class="post-toc-text">follow-up solution 2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array"><span class="post-toc-number">13.5.</span> <span class="post-toc-text">Follow-up 2 Find Minimum in Rotated Sorted Array</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Follow-up-3-What-if-there-are-duplicates-in-follow-up-2"><span class="post-toc-number">13.6.</span> <span class="post-toc-text">Follow-up 3 What if there are duplicates in follow-up 2</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-72"><span class="post-toc-number">14.</span> <span class="post-toc-text">Leetcode 72</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#solution"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-324-Wiggle-Sort-II"><span class="post-toc-number">15.</span> <span class="post-toc-text">Leetcode 324. Wiggle Sort II</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-9"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-215-Kth-Largest-Element-in-An-Array"><span class="post-toc-number">16.</span> <span class="post-toc-text">Leetcode 215 . Kth Largest Element in An Array</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-10"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-376-Wiggle-Subsequence"><span class="post-toc-number">17.</span> <span class="post-toc-text">Leetcode. 376 Wiggle Subsequence</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-11"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">Solution:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-227-Basic-Calculator"><span class="post-toc-number">18.</span> <span class="post-toc-text">Leetcode 227. Basic Calculator</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-12"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="post-toc-number">19.</span> <span class="post-toc-text">Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-13"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-609-Find-Duplicate-File-in-System"><span class="post-toc-number">20.</span> <span class="post-toc-text">Leetcode 609. Find Duplicate File in System</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-450-Delete-Node-in-a-BST"><span class="post-toc-number">21.</span> <span class="post-toc-text">Leetcode 450. Delete Node in a BST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-14"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-32-Longest-Valid-Parentheses"><span class="post-toc-number">22.</span> <span class="post-toc-text">Leetcode 32. Longest Valid Parentheses</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-15"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-34-Search-for-a-Range"><span class="post-toc-number">23.</span> <span class="post-toc-text">Leetcode 34. Search for a Range</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-16"><span class="post-toc-number">23.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><span class="post-toc-number">24.</span> <span class="post-toc-text">Leetcode 114. Flatten Binary Tree to Linked List</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-17"><span class="post-toc-number">24.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-44-Wildcard-Matching"><span class="post-toc-number">25.</span> <span class="post-toc-text">Leetcode 44. Wildcard Matching</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#solution-1"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-10-Regular-Expression-Matching"><span class="post-toc-number">26.</span> <span class="post-toc-text">Leetcode 10. Regular Expression Matching</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leetcode-222-Count-Complete-Tree-Nodes"><span class="post-toc-number">27.</span> <span class="post-toc-text">leetcode 222. Count Complete Tree Nodes.</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-18"><span class="post-toc-number">27.1.</span> <span class="post-toc-text">Solution:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-322-Coin-Change"><span class="post-toc-number">28.</span> <span class="post-toc-text">Leetcode 322. Coin Change</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-518-Coin-Change2"><span class="post-toc-number">29.</span> <span class="post-toc-text">Leetcode 518 Coin Change2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-312-Burst-Ballons"><span class="post-toc-number">30.</span> <span class="post-toc-text">Leetcode 312. Burst Ballons</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-143-Reorder-List"><span class="post-toc-number">31.</span> <span class="post-toc-text">Leetcode 143. Reorder List</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-19"><span class="post-toc-number">31.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-92-Reverse-Linked-List-II"><span class="post-toc-number">32.</span> <span class="post-toc-text">Leetcode 92. Reverse Linked List II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Solution-20"><span class="post-toc-number">33.</span> <span class="post-toc-text">Solution</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-274-H-Index"><span class="post-toc-number">34.</span> <span class="post-toc-text">Leetcode 274 H- Index</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-21"><span class="post-toc-number">34.1.</span> <span class="post-toc-text">Solution</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#FollowUp"><span class="post-toc-number">34.2.</span> <span class="post-toc-text">FollowUp</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="post-toc-number">35.</span> <span class="post-toc-text">Leetcode 378. Kth Smallest Element in a Sorted Matrix</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-22"><span class="post-toc-number">35.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Where-和-having-区别"><span class="post-toc-number">36.</span> <span class="post-toc-text">Where 和 having 区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Median-of-Two-Sorted-Arrays"><span class="post-toc-number">37.</span> <span class="post-toc-text">Median of Two Sorted Arrays</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-136-Single-Number"><span class="post-toc-number">38.</span> <span class="post-toc-text">Leetcode 136. Single Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Roman-to-Integer"><span class="post-toc-number">39.</span> <span class="post-toc-text">Roman to Integer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-204-Count-Primes"><span class="post-toc-number">40.</span> <span class="post-toc-text">Leetcode 204. Count Primes</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用-Array实现一个Queue"><span class="post-toc-number">41.</span> <span class="post-toc-text">用 Array实现一个Queue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#背包问题Review"><span class="post-toc-number">42.</span> <span class="post-toc-text">背包问题Review</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java中对JSON文件的读取"><span class="post-toc-number">43.</span> <span class="post-toc-text">Java中对JSON文件的读取</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-68-Text-Justification"><span class="post-toc-number">44.</span> <span class="post-toc-text">Leetcode 68. Text Justification</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-23"><span class="post-toc-number">44.1.</span> <span class="post-toc-text">Solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MapReduce-入门"><span class="post-toc-number">45.</span> <span class="post-toc-text">MapReduce 入门</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Find-the-row-with-maximum-number-of-1s"><span class="post-toc-number">46.</span> <span class="post-toc-text">Find the row with maximum number of 1s</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TSP"><span class="post-toc-number">47.</span> <span class="post-toc-text">TSP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Diamond"><span class="post-toc-number">48.</span> <span class="post-toc-text">Diamond</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#格子取数问题"><span class="post-toc-number">48.1.</span> <span class="post-toc-text">格子取数问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OfferUp-Sumologic-Quantcast-公司投递"><span class="post-toc-number">49.</span> <span class="post-toc-text">OfferUp. Sumologic, Quantcast 公司投递</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#K-Sorted-Array"><span class="post-toc-number">50.</span> <span class="post-toc-text">K Sorted Array</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution-1"><span class="post-toc-number">50.1.</span> <span class="post-toc-text">Solution 1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Solution2-maintain-a-k-1-size-priorityQueue"><span class="post-toc-number">50.2.</span> <span class="post-toc-text">Solution2: maintain a (k+1) size priorityQueue</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Is-this-a-tree"><span class="post-toc-number">51.</span> <span class="post-toc-text">Is this a tree?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-261-Valid-Tree"><span class="post-toc-number">52.</span> <span class="post-toc-text">Leetcode 261. Valid Tree</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Binary-Search-找距离最近的数字。"><span class="post-toc-number">53.</span> <span class="post-toc-text">Binary Search 找距离最近的数字。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；"><span class="post-toc-number">54.</span> <span class="post-toc-text">flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#leetcode-341-Flatten-Nested-List-Iterator"><span class="post-toc-number">54.1.</span> <span class="post-toc-text">leetcode 341. Flatten Nested List Iterator</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#leetcode-251-Flatten-2D-vector"><span class="post-toc-number">54.2.</span> <span class="post-toc-text">leetcode 251 Flatten 2D vector</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Leetcode-385-Mini-Parser"><span class="post-toc-number">54.3.</span> <span class="post-toc-text">Leetcode 385. Mini Parser</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Find-the-intersection-of-two-lists"><span class="post-toc-number">55.</span> <span class="post-toc-text">Find the intersection of two lists</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Abstract-class-interface-and-threading-issues"><span class="post-toc-number">56.</span> <span class="post-toc-text">Abstract class, interface and threading issues.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Merge-Intervals"><span class="post-toc-number">57.</span> <span class="post-toc-text">Merge Intervals</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#More-about-drawbridge"><span class="post-toc-number">58.</span> <span class="post-toc-text">More about drawbridge</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Knight’s-travel"><span class="post-toc-number">59.</span> <span class="post-toc-text">Knight’s travel</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-Frog-Jump"><span class="post-toc-number">60.</span> <span class="post-toc-text">Leetcode Frog Jump</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Jump-Game-I-amp-amp-II"><span class="post-toc-number">61.</span> <span class="post-toc-text">Jump Game I &amp;&amp; II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Verify-Preorder-Serialization-of-a-Binary-Tree"><span class="post-toc-number">62.</span> <span class="post-toc-text">Verify Preorder Serialization of a Binary Tree</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最短路径算法"><span class="post-toc-number">63.</span> <span class="post-toc-text">最短路径算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Check-whether-a-given-array-is-a-k-sorted-array-or-not"><span class="post-toc-number">64.</span> <span class="post-toc-text">Check whether a given array is a k sorted array or not.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何计算数据的方差"><span class="post-toc-number">65.</span> <span class="post-toc-text">如何计算数据的方差</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#很多数，-找到k个最大的数，-stream操作。"><span class="post-toc-number">66.</span> <span class="post-toc-text">很多数， 找到k个最大的数， stream操作。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#很大个文本如何应用mapreduce，-找到anagram"><span class="post-toc-number">67.</span> <span class="post-toc-text">很大个文本如何应用mapreduce， 找到anagram</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。"><span class="post-toc-number">68.</span> <span class="post-toc-text">mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#public-static-void-main-String-args-为啥要用static。"><span class="post-toc-number">69.</span> <span class="post-toc-text">public static void main (String[] args) 为啥要用static。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如果不用static-是否能够通过？"><span class="post-toc-number">70.</span> <span class="post-toc-text">如果不用static 是否能够通过？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。"><span class="post-toc-number">71.</span> <span class="post-toc-text">最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java-heap和stack都分别存什么"><span class="post-toc-number">72.</span> <span class="post-toc-text">Java heap和stack都分别存什么</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java-Heap-Space"><span class="post-toc-number">72.1.</span> <span class="post-toc-text">Java Heap Space</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java-Stack-Memory"><span class="post-toc-number">72.2.</span> <span class="post-toc-text">Java Stack Memory</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Difference-between-Java-Heap-Space-and-Stack-Memory"><span class="post-toc-number">73.</span> <span class="post-toc-text">Difference between Java Heap Space and Stack Memory</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SQL有几种join，-join的内部实现，-sql-index内部实现。"><span class="post-toc-number">74.</span> <span class="post-toc-text">SQL有几种join， join的内部实现， sql index内部实现。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#What’s-the-difference-between-B-Tree-and-B-Tree"><span class="post-toc-number">75.</span> <span class="post-toc-text">What’s the difference between B Tree and B+ Tree.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Overfitting-如何处理"><span class="post-toc-number">76.</span> <span class="post-toc-text">Overfitting 如何处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#count-min-sketch-数据结构"><span class="post-toc-number">77.</span> <span class="post-toc-text">count-min-sketch 数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。"><span class="post-toc-number">78.</span> <span class="post-toc-text">A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#cc-150上-4-8-subtree那道题"><span class="post-toc-number">79.</span> <span class="post-toc-text">cc 150上 4.8 subtree那道题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#solution-2"><span class="post-toc-number">79.1.</span> <span class="post-toc-text">solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode：-Largest-Number"><span class="post-toc-number">80.</span> <span class="post-toc-text">Leetcode： Largest Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SQL刷题。"><span class="post-toc-number">81.</span> <span class="post-toc-text">SQL刷题。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Move-zeros"><span class="post-toc-number">82.</span> <span class="post-toc-text">Move zeros</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones"><span class="post-toc-number">83.</span> <span class="post-toc-text">From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SQL"><span class="post-toc-number">84.</span> <span class="post-toc-text">SQL</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strstr变形"><span class="post-toc-number">85.</span> <span class="post-toc-text">strstr变形</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#merge-two-BST"><span class="post-toc-number">86.</span> <span class="post-toc-text">merge two BST</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#group-anagram"><span class="post-toc-number">87.</span> <span class="post-toc-text">group anagram</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级"><span class="post-toc-number">88.</span> <span class="post-toc-text">给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？"><span class="post-toc-number">89.</span> <span class="post-toc-text">two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego"><span class="post-toc-number">90.</span> <span class="post-toc-text">use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hash-IP-address"><span class="post-toc-number">91.</span> <span class="post-toc-text">hash IP address</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Partition-Array"><span class="post-toc-number">92.</span> <span class="post-toc-text">Partition Array</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-721-Accounts-Merge"><span class="post-toc-number">93.</span> <span class="post-toc-text">Leetcode 721. Accounts Merge</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#solution-3"><span class="post-toc-number">93.1.</span> <span class="post-toc-text">solution</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#海量数据如何去重"><span class="post-toc-number">94.</span> <span class="post-toc-text">海量数据如何去重</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Find-K-th-Smallest-Pair-Distance"><span class="post-toc-number">95.</span> <span class="post-toc-text">Find K-th Smallest Pair Distance</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                算法(一)
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Liyan Chen</strong>
        <span>Feb 03, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Java-Algorithm/">Java, Algorithm</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://lic128.me/2018/02/03/算法(一)/index.html&title=算法(一)" target="_blank">
            <li class="mdl-menu__item">
                Share to LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h3 id="LeetCode-146-LRU-Cache"><a href="#LeetCode-146-LRU-Cache" class="headerlink" title="LeetCode 146. LRU Cache"></a>LeetCode 146. LRU Cache</h3><p>Design and implement a data structure for Lease Recently Used cache. It should support the following operations:<code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<pre><code>class LRUCache {
    private class Node{
        Node pre;
        Node next;
        int key;
        int val;
        public Node(int key, int val){
            this.key= key;
            this.val= val;
        }
    }
    Node head=null;
    Node tail=null;
    public void removeTail(){
        Node node= tail.pre.pre;
        node.next=tail;
        tail.pre= node;
    }
    public void addToHead(Node node){
        Node next= head.next;
        next.pre= node;
        node.next= next;
        node.pre= head;
        head.next=node;
    }
    public void moveToHead(Node node){
        Node next= node.next;
        Node pre= node.pre;
        pre.next= next;
        next.pre=pre;
        addToHead(node);
    }
    private Map&lt;Integer, Node&gt; map= new HashMap&lt;Integer, Node&gt;();
    private int capacity;
    private int count;
    public LRUCache(int capacity) {
        this.capacity= capacity;
        head=new Node(0, 0);
        tail=new Node(0, 0);
        head.next=tail;
        tail.pre= head;
    }

    public int get(int key) {
        if(!map.containsKey(key)){
            return -1;
        }else{
            Node node= map.get(key);
            moveToHead(node);
            return node.val;
        }
    }

    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node node= map.get(key);
            node.val= value;
            moveToHead(node);
        }else{
            Node node= new Node(key, value);
            map.put(key, node);
            addToHead(node);
            count++;
            if(count&gt;capacity){
                map.remove(tail.pre.key);
                removeTail();
                count--;
            }
        }
    }
}
</code></pre><h3 id="leetcode-199-Evaluate-Division"><a href="#leetcode-199-Evaluate-Division" class="headerlink" title="leetcode 199. Evaluate Division"></a>leetcode 199. Evaluate Division</h3><p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p><strong>Example:</strong><br>Given <code>a / b = 2.0, b / c = 3.0.</code><br>queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code><br>return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector&lt;double&gt;</code>.</p>
<p>According to the example above:</p>
<pre><code>equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],
values = [2.0, 3.0],
queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].
</code></pre><p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<h4 id="Solution-1-dumb-dfs"><a href="#Solution-1-dumb-dfs" class="headerlink" title="Solution 1: dumb dfs"></a>Solution 1: dumb dfs</h4><pre><code>class Solution {
    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {
        Map&lt;String, Set&lt;String&gt;&gt; map= new HashMap&lt;String, Set&lt;String&gt;&gt;();
        Map&lt;String, Double&gt; dict= new HashMap&lt;String, Double&gt;();
        for(int i=0; i&lt;equations.length; i++){
            String p= equations[i][0];
            String q= equations[i][1];
            double val= values[i];
            if(!map.containsKey(p)) map.put(p, new HashSet&lt;String&gt;());
            if(!map.containsKey(q)) map.put(q, new HashSet&lt;String&gt;());
            map.get(p).add(q);
            map.get(q).add(p);
            dict.put(p+&quot;/&quot;+q, val);
            dict.put(q+&quot;/&quot;+p, 1/val);
        }
        double[] res= new double[queries.length];
        Set&lt;String&gt; visited;
        for(int i=0; i&lt;queries.length; i++){
            String p= queries[i][0];
            String q= queries[i][1];
            if(!map.containsKey(p) || !map.containsKey(q)){
                res[i]=-1.0;
                continue;
            }
            visited= new HashSet&lt;String&gt;();
            visited.add(p);
            res[i]= isConnected(p, q, map, dict, visited);
        }
        return res;
    }
    public double isConnected(String p, String q, Map&lt;String, Set&lt;String&gt;&gt; map, Map&lt;String, Double&gt; dict, Set&lt;String&gt; visited){
        String equ= p+ &quot;/&quot;+q;
        String rev_equ=q+&quot;/&quot;+p;
        if(dict.containsKey(equ)) return dict.get(equ);
        for(String next: map.get(p)){
            if(visited.contains(next)) continue;
            visited.add(next);
            double res= dict.get(p+&quot;/&quot;+ next);
            double residual= isConnected(next, q, map, dict, visited);
            if(residual==-1.0){
                continue;
            }
            dict.put(equ, res*residual);
            dict.put(rev_equ, 1/(res*residual));
            return res*residual;
        }
        dict.put(equ, -1.0);
        dict.put(rev_equ, -1.0);
        return -1;
    }
}
</code></pre><h4 id="Solution-2-union-find-algorithm"><a href="#Solution-2-union-find-algorithm" class="headerlink" title="Solution 2: union-find algorithm"></a>Solution 2: union-find algorithm</h4><pre><code>public class solution{
    Map&lt;String, String&gt; parent= new HashMap&lt;&gt;();
    Map&lt;String, Double&gt; weight= new HashMap&lt;&gt;();// parent/son
    // here we use weight to record the quotient between the root  and the child;
    public double[] calcEquation(String[][] equations, double[] values, String[][] queries){
        for(int i=0; i&lt;equations.length; i++){
            String[] eq= equations[i];
            initialize(eq[0]);
            initialize(eq[1]);
            union(eq[0], eq[1], values[i]);
        }
        double[] res= new double[queries.length];
        for(int i=0; i&lt;queries.length; i++){
            res[i]= getProduct(queries[i][0], queries[i][1]);
        }
        return res;
    }
    private void initialize(String a){
        if(!parent.containsKey(a)){
            parent.put(a, a);
            weight.put(a, 1d);// sufix d after number means double, sufix f means float;
        }
    }
    private void union(String a, String b, double quotient){
        String aRoot= find(a);
        String bRoot= find(b);
        if(!aRoot.equals(bRoot)){
            parent.put(bRoot, aRoot);
            weight.put(bRoot, quotient*weight.get(a)/weight.get(b));
        }
    }
    private String find(String a){
        if(parent.get(a).equals(a)){
            return a;
        }
        String oldRoot= parent.get(a);
        String root= find(oldRoot);
        if(!oldRoot.equals(root)){
            parent.put(a, root);
            weight.put(a, weight.get(oldRoot)*weight.get(a));// here is important, we use the recursive thought to override the previous value of the record;
        }
        return root;
    }
    private double getProduct(String a, String b){
        if(!parent.containsKey(a) || !parent.containsKey(b)){
            return -1;
        }
        String aRoot= find(a);
        String bRoot= find(b);
        if(!aRoot.equals(bRoot)){
            return -1;
        }
        return weight.get(b)/weight.get(a);
    }
}
</code></pre><p>另外一种方式的Union-find:</p>
<pre><code>class Solution {
    // Using union-find to solve the problem;
    // or we can use bfs/dfs, which will take a lot time;
    Map&lt;String, String&gt; id= new HashMap&lt;String, String&gt;();
    Map&lt;String, Double&gt; dict=new HashMap&lt;String, Double&gt;();
    public String find(String p){
        while(!p.equals(id.get(p))){
            p=id.get(p);
        }
        return p;
    }
    public double getValue(String p){
        double res= 1.0;
        while(!p.equals(id.get(p))){
            double mult=dict.get(p+&quot;/&quot;+id.get(p));
            res*=mult;
            p=id.get(p);
        }

        return res;
    }
    public double cal(String p, String q){
        if(!id.containsKey(p) || !id.containsKey(q)) return -1;
        String p_root= find(p);
        String q_root= find(q);
        if(!p_root.equals(q_root)) return -1;
        double p_res= getValue(p);
        double q_res= getValue(q);
        return p_res/q_res;
    }
    public void union(String p, String q, double value){
        String p_root= find(p);
        String q_root= find(q);
        double p_val= getValue(p);
        double q_val= getValue(q);
        id.put(p_root, q_root);
        dict.put(p_root+&quot;/&quot;+ q_root, value*q_val/p_val);
        // when we union here, we also need to update the edges;

    }
    public double[] calcEquation(String[][] equations, double[] values, String[][] queries){
        for(int i= 0; i&lt;equations.length; i++){
            String p= equations[i][0];
            String q=equations[i][1];
            double val= values[i];
            id.put(p, p);
            id.put(q, q);
            dict.put(p+&quot;/&quot;+ q, val);
            dict.put(q+&quot;/&quot;+ p, 1/val);
        }
        //System.out.println(&quot;done!&quot;);
        for(int i=0; i&lt;equations.length; i++){
            String p=equations[i][0];
            String q=equations[i][1];
            union(p, q, values[i]);
        }
        //System.out.println(&quot;done!&quot;);
        double[] res= new double[queries.length];
        for(int i=0; i&lt;res.length; i++){
            //System.out.println(queries[i][0]);
            //System.out.println(queries[i][1]);
            res[i]=cal(queries[i][0], queries[i][1]);
        }
        return res;
    }
    }
</code></pre><h3 id="Leetcode-628-Maximum-Product-of-Three-Numbers"><a href="#Leetcode-628-Maximum-Product-of-Three-Numbers" class="headerlink" title="Leetcode 628. Maximum Product of Three Numbers"></a>Leetcode 628. Maximum Product of Three Numbers</h3><pre><code>class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        int res=0;
        int first= nums[0]*nums[1]*nums[nums.length-1];
        int last= nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3];
        return Math.max(first, last);
    }
}
</code></pre><p>or we can just find the corresponding 5 value using one-pass scan:</p>
<pre><code>public int maximumProduct(int[] nums) {
       int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
       for (int n : nums) {
           if (n &gt; max1) {
               max3 = max2;
               max2 = max1;
               max1 = n;
           } else if (n &gt; max2) {
               max3 = max2;
               max2 = n;
           } else if (n &gt; max3) {
               max3 = n;
           }

           if (n &lt; min1) {
               min2 = min1;
               min1 = n;
           } else if (n &lt; min2) {
               min2 = n;
           }
       }
       return Math.max(max1*max2*max3, max1*min1*min2);
   }
</code></pre><h3 id="leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="leetcode 159. Longest Substring with At Most Two Distinct Characters"></a>leetcode 159. Longest Substring with At Most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>
<p>For example, Given s = <code>“eceba”</code>,</p>
<p>T is “ece” which its length is 3.</p>
<pre><code>class Solution {
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        Map&lt;Character, Integer&gt; map= new HashMap&lt;Character, Integer&gt;();
        int left=0;
        int res=0;
        for(int right=0; right&lt;s.length(); right++){
            char ch= s.charAt(right);
            map.put(ch, map.getOrDefault(ch, 0)+1);
            while(map.size()&gt;2){
                char delete=s.charAt(left);
                map.put(delete, map.get(delete)-1);
                if(map.get(delete)==0) map.remove(delete);
                left++;
            }
            res=Math.max(res, right-left+1);
        }
        return res;
    }
}
</code></pre><p>This Solution can be extended to the general k-different solutions;</p>
<h3 id="leetcode-465-Optimal-Account-Balancing"><a href="#leetcode-465-Optimal-Account-Balancing" class="headerlink" title="leetcode 465. Optimal Account Balancing"></a>leetcode 465. Optimal Account Balancing</h3><p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill’s lunch for 10. Then later Chris gave Alice 5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person’s ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>
<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>
<p><strong>Note:</strong></p>
<ol>
<li>A transaction will be given as a tuple (x, y, z). Note that <code>x ≠ y</code> and <code>z &gt; 0</code>.</li>
<li>Person’s IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input:
[[0,1,10], [2,0,5]]

Output:
2

Explanation:
Person #0 gave person #1 $10.
Person #2 gave person #0 $5.

Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input:
[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]

Output:
1

Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.

Therefore, person #1 only need to give person #0 $4, and all debt is settled.
</code></pre><p>题目属于NPC问题， 在这种情况下， 进行暴力解就好， 解法： 借西墙补东墙，将位于第一位的数字放入可以放入的其他位中， 然后将第一位清零， 进行下一次更替。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code>class Solution {
    public int minTransfers(int[][] transactions) {
        Map&lt;Integer, Integer&gt; map= new HashMap&lt;Integer, Integer&gt;();
        for(int i=0; i&lt;transactions.length; i++){
            int give=transactions[i][0];
            int take=transactions[i][1];
            int val= transactions[i][2];
            map.put(give, map.getOrDefault(give, 0)-val);
            map.put(take, map.getOrDefault(take, 0)+val);
        }
        List&lt;Integer&gt; debts= new ArrayList&lt;Integer&gt;();
        for(int debt: map.values()){
            if(debt!=0){
                debts.add(debt);
            }
        }
        Collections.sort(debts);
        return helper(0, 0, debts);
    }
    private int helper(int pos, int count, List&lt;Integer&gt; debts){
        while(pos&lt;debts.size() &amp;&amp; debts.get(pos)==0) pos++;
        if(pos==debts.size()) return count;
        int val= debts.get(pos);
        int res=Integer.MAX_VALUE;
        for(int i= pos+1; i&lt;debts.size(); i++){
            if(debts.get(i)*val&lt;0){
                while(i+1&lt;debts.size() &amp;&amp; debts.get(i)==debts.get(i+1)) i++;
                debts.set(i, debts.get(i)+ val);
                res=Math.min(res, helper(pos+1, count+1, debts));
                debts.set(i, debts.get(i)-val);
            }
        }
        return res;
    }
}
</code></pre><h3 id="Leetcode-464-Can-I-Win"><a href="#Leetcode-464-Can-I-Win" class="headerlink" title="Leetcode 464. Can I Win"></a>Leetcode 464. Can I Win</h3><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p><strong>Example</strong></p>
<pre><code>Input:
maxChoosableInteger = 10
desiredTotal = 11

Output:
false

Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h4><p>很经典的Backtracking+ Game Theory+ Hash的题目， 我们要做的就是考虑下一步的反面就好了， 如果下一步的对手不能赢， 说明我们这一步就可以赢。</p>
<p>需要注意的是优化， 这里采用的是hash+memorization， 但是效果可能不是特别好。</p>
<pre><code>class Solution {
    Map&lt;String, Boolean&gt; map= new HashMap&lt;String, Boolean&gt;();
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        int sum=(maxChoosableInteger+1)*maxChoosableInteger/2;
        if(sum&lt;desiredTotal) return false;
        if(desiredTotal&lt;=0) return true;
        boolean[] visited= new boolean[maxChoosableInteger+1];
        return canIWin(visited, desiredTotal);
    }
    public boolean canIWin(boolean[] visited, int desiredTotal){
        if(desiredTotal&lt;=0) return false;
        String key= encode(visited);
        if(map.containsKey(key)) return map.get(key);
        for(int i=1; i&lt;visited.length; i++){
            if(visited[i]) continue;
            visited[i]= true;
            if(!canIWin(visited, desiredTotal-i)){// if the remaining one cannot win, then we say we can win.
                map.put(key, true);
                visited[i]=false;//here we need to refresh the visited;
                return true;
            }
            visited[i]=false;
        }
        return false;
    }
    public String encode(boolean[] visited){
        StringBuilder sb= new StringBuilder();
        for(int i=0; i&lt;visited.length; i++){
            if(visited[i]){
                sb.append(1);
            }else{
                sb.append(0);
            }
        }
        return sb.toString();
    }
}
</code></pre><h3 id="leetcode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#leetcode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="leetcode 297. Serialize and Deserialize Binary Tree"></a>leetcode 297. Serialize and Deserialize Binary Tree</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<pre><code>  1
 / \
2   3
   / \
  4   5
</code></pre><p>as</p>
<pre><code>&quot;[1,2,3,null,null,4,5]&quot;
</code></pre><p>, just the same as</p>
<p>how LeetCode OJ serializes a binary tree</p>
<p>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目也很经典啊， 利用preorder对tree进行遍历， 然后利用相同的过程进行重建。 具体看代码吧。</p>
<pre><code>public class Code {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb= new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }
    // preorder traverse the tree
    public void serialize(TreeNode root, StringBuilder sb){
        if(root==null){
            sb.append(&quot;,null&quot;);
            return ;
        }
        sb.append(&quot;,&quot;).append(root.val);
        serialize(root.left, sb);
        serialize(root.right, sb);
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] tokens= data.split(&quot;,&quot;);
        Queue&lt;String&gt; queue= new LinkedList&lt;String&gt;();
        for(int i=0; i&lt;tokens.length; i++){
            if(tokens[i].length()==0 || tokens[i].equals(&quot;,&quot;)){
                continue;
            }
            queue.offer(tokens[i]);
        }
        return buildTree(queue);
    }
    public TreeNode buildTree(Queue&lt;String&gt; queue){
        if(queue.size()==0) return null;
        String val= queue.poll();
        if(val.equals(&quot;null&quot;)) return null;
        TreeNode root= new TreeNode(Integer.valueOf(val));
        root.left = buildTree(queue);
        root.right= buildTree(queue);
        return root;
    }
}
</code></pre><h3 id="leetcode-339-Nested-List-Weight-Sum"><a href="#leetcode-339-Nested-List-Weight-Sum" class="headerlink" title="leetcode 339. Nested List Weight Sum"></a>leetcode 339. Nested List Weight Sum</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>10</strong>. (four 1’s at depth 2, one 2 at depth 1)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>27</strong>. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>典型的DFS题目， 记录每一层的深度， 然后乘其数值即可得到。</p>
<pre><code>/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List&lt;NestedInteger&gt; getList();
 * }
 */
class Solution {
    public int depthSum(List&lt;NestedInteger&gt; nestedList) {
        int sum=0;
        for(NestedInteger i: nestedList){
            sum+=dfs(i, 1);
        }
        return sum;
    }
    public int dfs(NestedInteger num, int depth){
        if(num.isInteger()){
            return num.getInteger()*depth;
        }else{
            int sum=0;
            List&lt;NestedInteger&gt; list= num.getList();
            for(NestedInteger i: list){
                sum+=dfs(i, depth+1);
            }
            return sum;
        }
    }
}
</code></pre><h3 id="Leetcode-364-Nested-List-Weight-Sum-II"><a href="#Leetcode-364-Nested-List-Weight-Sum-II" class="headerlink" title="Leetcode 364. Nested List Weight Sum II"></a>Leetcode 364. Nested List Weight Sum II</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the <a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">previous question</a> where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>8</strong>. (four 1’s at depth 1, one 2 at depth 2)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>17</strong>. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><pre><code>/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List&lt;NestedInteger&gt; getList();
 * }
 */
class Solution {
    public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) {
        Map&lt;Integer, Integer&gt; level= new HashMap&lt;Integer, Integer&gt;();
        for(NestedInteger i: nestedList){
            getRank(level, i, 1);
        }
        int maxLevel=0;
        for(int i: level.keySet()){
            maxLevel= Math.max(maxLevel, i);
        }
        int sum=0;
        for(int i: level.keySet()){
            sum+=(maxLevel-i+1)*level.get(i);
        }
        return sum;
    }
    public void getRank(Map&lt;Integer, Integer&gt; level, NestedInteger num, int depth){
        if(num.isInteger()){
            level.put(depth, level.getOrDefault(depth, 0)+ num.getInteger());
            return;
        }else{
            List&lt;NestedInteger&gt; list= num.getList();
            for(NestedInteger i: list){
                getRank(level, i, depth+1);
            }
        }
        return;
    }
}
</code></pre><h3 id="leetcode-405-Convert-a-Number-to-Hexadecimal"><a href="#leetcode-405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="leetcode 405. Convert a Number to Hexadecimal"></a>leetcode 405. Convert a Number to Hexadecimal</h3><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">two’s complement</a> method is used.</p>
<p><strong>Note:</strong></p>
<ol>
<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>
<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>&#39;0&#39;</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input:
26

Output:
&quot;1a&quot;
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input:
-1

Output:
&quot;ffffffff&quot;
</code></pre><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>进制转换， 也算比较不错的一道题目了， 需要注意的是16进制向 2进制的转换， 以及map的这个操作。</p>
<p>Basic idea: each time we take a look at the last four digits of binary version of input, and maps that to a hex char, shift the input to the right by 4 bits, do it again until input becomes 0.</p>
<pre><code>class Solution {
    //
    public String toHex(int num) {
        char[] map = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};
        if(num==0) return &quot;0&quot;;
        String result= &quot;&quot;;
        while(num!=0){
            result= map[(num&amp;15)] + result;
            num= (num&gt;&gt;&gt;4);
        }
        return result;
    }
}
</code></pre><h3 id="leetcode-Find-Leaves-of-Binary-Tree"><a href="#leetcode-Find-Leaves-of-Binary-Tree" class="headerlink" title="leetcode: Find Leaves of Binary Tree"></a>leetcode: Find Leaves of Binary Tree</h3><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<p>Example:<br>Given binary tree</p>
<pre><code>    1
   / \
  2   3
 / \     
4   5
</code></pre><p>Returns [4, 5, 3], [2], [1].</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>这道题给了我们一个二叉树， 让我们返回其每层的叶节点， 就像剥洋葱一样， 将这个二叉树一层层剥掉， 最后一个剥掉根节点。 思路是这样的， 每一个节点从左子节点和右子节点分开走可以得到两个深度， 由于成为叶节点的条件是左右子结点都为空， 所以我们取左右子节点中较大值加1 为当前节点的深度值， 知道了深度值就可以将节点值加入到结果res中的正确位置了。</p>
<p>实现代码：</p>
<pre><code>public class solution{
    public static List&lt;List&lt;Integer&gt;&gt; findLeaves{
         List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();
          getDepth(root, res);
          return res;
    }
  public static int getDepth(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root){
          if(root==null) return 0;
        int left= getDepth(res, root.left);
        int right= getDepth(res, root.right);
        int depth= Math.max(left, right)+1;
        while(res.size()&lt;depth){
            res.add(new ArrayList&lt;Integer&gt;());
        }
        res.get(depth-1).add(root.val);
      }
}
</code></pre><p>还有一种解法， 使用naive的一层层剥离的方法， 思路是遍历二叉树， 找到叶节点， 将其值赋值为null， 然后加入leaves中， 这样一层层剥离就可以得到最终结果了。</p>
<pre><code>public class solution{
    public static List&lt;List&lt;Integer&gt;&gt; findLeaves{
         List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();
          while(root!=null){
              List&lt;Integer&gt; leaves= new ArrayList&lt;Integer&gt;()
            removeLeave(root, leaves);
          res.add(leaves);
        }
          return res;
    }
  public static TreeNode removeLeave(TreeNode root, List&lt;Integer&gt; leaves){
          if(root==null) return null;
        if(root.left==null &amp;&amp; root.right==null){
            leaves.add(root.val);
          return null;
        }
        root.left= removeLeave(root.left, leaves);
        root.right= removeLeave(root.right, leaves);
        return root;
  }

}
</code></pre><h3 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15: 3Sum"></a>Leetcode 15: 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>总的来说， 两个知识点的考察： 1. two pointers; 2. 如何去重。</p>
<p>这里我们主要的难点就是对于去重： 如何高效地去重。</p>
<p>这里我们直接看代码进行理解：</p>
<pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;List&lt;Integer&gt;&gt;();
        Arrays.sort(nums);
        for(int i=0; i&lt;nums.length-2; i++){
            if(nums[i]&gt;0) break;
            //if(res.size()&gt;0 &amp;&amp; res.get(res.size()-1).get(0)==nums[i]) continue;
            int target= -nums[i];
            int left= i+1;
            int right=nums.length-1;
            while(left&lt;right){
                if(nums[left]+nums[right]==target){
                    List&lt;Integer&gt; temp= new ArrayList&lt;Integer&gt;();
                    temp.add(-target);
                    temp.add(nums[left]);
                    temp.add(nums[right]);
                    res.add(temp);
                    while(++left&lt;right &amp;&amp; nums[left]==nums[left-1]);
                    while(--right&gt;left &amp;&amp; nums[right]==nums[right+1]);
                }else if(nums[left]+nums[right]&lt;target){
                    left++;
                }else{
                    right--;
                }
            }
            while(i+1&lt;nums.length-2 &amp;&amp; nums[i]==nums[i+1]) i++;
        }
        return res;
    }
}
</code></pre><h3 id="Leetcode-33-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode 33. Search in Rotated Sorted Array"></a>Leetcode 33. Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>无比经典的题目， 主要考察的是对binary search的理解。 这里search的array被分为两个部分， 而两个部分都是递增的， 比较直观的解释便是先判断mid处于哪一个部分， 然后再判断target处于哪一个part。具体代码实现如下：</p>
<pre><code>class Solution{
  public int search(int[] nums, int target){
    if(nums.length==0) return -1;
    int left=0;
    int right=nums.length-1;
    while(left&lt;=right){
      int mid= left+(right-left)/2;
      if(nums[mid]==target){
        return mid;
      }
      if(nums[mid]&gt;=nums[left]){//  judge which part does mid fall into
        if(target&lt;nums[mid] &amp;&amp; target&gt;= nums[left]) right= mid-1;
        else left= mid+1;
      }else{
        if(target&gt;nums[mid] &amp;&amp; target&lt;= nums[right]) left= mid+1;
        else right=mid-1;
      }
    }
    return -1;
  }
}
</code></pre><h4 id="Follow-Up-1-what-if-there-are-duplicate-exists"><a href="#Follow-Up-1-what-if-there-are-duplicate-exists" class="headerlink" title="Follow-Up 1, what if there are duplicate exists?"></a>Follow-Up 1, what if there are duplicate exists?</h4><p>The only difference is that due to the existence of duplicates, we can have nums[left]==nums[mid] and in that case, the first half could be out of order(i.e. NOT in the ascending order, e.g.[3,1,2,3,3,3,3]) and we have to deal with this case separately. In that case, it’s guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]==nums[left]==nums[right] before the original logic, if so, we can move left and right both towards the middle by 1. and repeat</p>
<h4 id="follow-up-solution-1"><a href="#follow-up-solution-1" class="headerlink" title="follow-up solution 1"></a>follow-up solution 1</h4><pre><code>class Solution {
public:
    bool search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0, right =  nums.size()-1, mid;

        while(left&lt;=right)
        {
            mid = (left + right) &gt;&gt; 1;
            if(nums[mid] == target) return true;

            // the only difference from the first one, trickly case, just updat left and right
            if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) {++left; --right;}

            else if(nums[left] &lt;= nums[mid])
            {
                if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1;
                else left = mid + 1; 
            }
            else
            {
                if((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+1;
                else right = mid-1;
            }
        }
        return false;
    }
};
</code></pre><h4 id="follow-up-solution-2"><a href="#follow-up-solution-2" class="headerlink" title="follow-up solution 2"></a>follow-up solution 2</h4><pre><code>public class Solution {
     public boolean search(int[] nums, int target) {
        if(nums.length==0) return false;
        int left=0;
        int right=nums.length-1;
        while(left&lt;=right){
            int mid=(left+right)/2;
            if(nums[mid]==target) return true;
            if(nums[mid]&gt;nums[left]){
               if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]){
                   right=mid-1;
               }else{
                   left=mid+1;
               }
           }else if(nums[mid]&lt;nums[left]){
               if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]){
                   left=mid+1;
               }else{
                   right=mid-1;
               }
           }else{
                left++;
           }
        }
        return false;
    }
}
</code></pre><h4 id="Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Follow-up 2 Find Minimum in Rotated Sorted Array"></a>Follow-up 2 Find Minimum in Rotated Sorted Array</h4><p>In such condition, we try to maintain the structure of the array, and delete part of it when we find mid, the most important case is that when the left pointer is already in the right part, which means we can stop the finding process.</p>
<pre><code>class Solution {
    public int findMin(int[] nums) {
        int left=0;
        int right= nums.length-1;
        while(left&lt;right){
            if(nums[left]&lt;nums[right]) return nums[left];
            int mid=(left+right)/2;
            if(nums[mid]&gt;=nums[left]){// mid fall into the left part
                left=mid+1;// then we can just move to the right
            }else{// else if mid fall into the right part
                right=mid;
            }
        }
        return nums[left];
    }
}
</code></pre><h4 id="Follow-up-3-What-if-there-are-duplicates-in-follow-up-2"><a href="#Follow-up-3-What-if-there-are-duplicates-in-follow-up-2" class="headerlink" title="Follow-up 3 What if there are duplicates in follow-up 2"></a>Follow-up 3 What if there are duplicates in follow-up 2</h4><p>Things become easy since we have solved problem 2.</p>
<pre><code>class Solution {
    public int findMin(int[] nums) {
        int left=0;
        int right= nums.length-1;
        while(left&lt;right){
            if(nums[left]&lt;nums[right]) return nums[left];
            int mid=(left+right)/2;
            if(nums[mid]&gt;nums[left]){
                left=mid+1;
            }else if(nums[mid]&lt;nums[left]){
                right=mid;
            }else{
                left++;
            }
        }
        return nums[left];
    }
}
</code></pre><p>when completed the three follow-up, things become easy when we want to find the median/max:</p>
<p>we just find the minimum, and then find it’s index, then we know the turn point, by which we can know the original structure of the array.</p>
<h3 id="Leetcode-72"><a href="#Leetcode-72" class="headerlink" title="Leetcode 72"></a>Leetcode 72</h3><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>典型的DP问题， 解决一道题解决所有题。</p>
<pre><code>class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp= new int[word1.length()+1][word2.length()+1];
        for(int i=0; i&lt;=word1.length(); i++){
            dp[i][0]=i;
        }
        for(int j=0; j&lt;=word2.length(); j++){
            dp[0][j]=j;
        }
        for(int i=1; i&lt;=word1.length(); i++){
            for(int j=1; j&lt;=word2.length(); j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    int delete=Math.min(dp[i][j-1], dp[i-1][j])+1;
                    int replace=dp[i-1][j-1]+1;
                    dp[i][j]=Math.min(delete, replace);
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
</code></pre><p>例如： leetcode 712. Minimum ASCII Delete Sum for Two Strings</p>
<pre><code>class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int[][] dp= new int[s1.length()+1][s2.length()+1];
        int min=Integer.MAX_VALUE;
        int sum=0;
        for(int i=0; i&lt;=s1.length(); i++){
            dp[i][0]=(i&gt;0? dp[i-1][0]+s1.charAt(i-1):0);
        }
        for(int j=0; j&lt;=s2.length(); j++){
            dp[0][j]=(j&gt;0? dp[0][j-1]+s2.charAt(j-1):0);
        }
        for(int i=1; i&lt;=s1.length(); i++){
            for(int j=1; j&lt;=s2.length(); j++){
                if(s1.charAt(i-1)==s2.charAt(j-1)) dp[i][j]= dp[i-1][j-1];
                else dp[i][j]=Math.min(dp[i][j-1]+ s2.charAt(j-1), dp[i-1][j]+s1.charAt(i-1));
            }
        }
        return dp[s1.length()][s2.length()];
    }
}
</code></pre><h3 id="Leetcode-324-Wiggle-Sort-II"><a href="#Leetcode-324-Wiggle-Sort-II" class="headerlink" title="Leetcode 324. Wiggle Sort II"></a>Leetcode 324. Wiggle Sort II</h3><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>这道题被categorized as medium， 但是实际上到达了hard的难度， 我们如何在O(n)的事件复杂度里面解决该题呢，基本的思想是， 我们要先找到array中的中位数， 然后依据该中位数进行排列， 使得排列后的数列满足我们的条件。</p>
<p>Code:</p>
<pre><code>class Solution {
    public void wiggleSort(int[] nums) {
        int median=findKthLargest(nums, (nums.length+1)/2);
        // here we just try to solve it in O(n);
        int[] temp= new int[nums.length];
        int s=0, t= nums.length-1, mid_index=(nums.length+1)&gt;&gt;1;
      //when we find the median,we try to rearrange the array to satisified the requirement.
        for(int i=0; i&lt;nums.length; i++){
            if(nums[i]&lt;median) temp[s++]= nums[i];
            else if(nums[i]&gt;median) temp[t--]= nums[i];
        }
        while(s&lt;mid_index) temp[s++]= median;
        while(t&gt;=mid_index) temp[t--]= median;
      // after three-way partition
        t= nums.length;
        for(int i=0; i&lt;nums.length; i++){
            nums[i]=(i&amp;1)==0? temp[--s]: temp[--t];
        }
    }
    public int findKthLargest(int[] nums, int k) {
        k= nums.length-k;
        int lo=0;
        int hi= nums.length-1;
        while(lo&lt;=hi){
            int idx= partition(nums, lo, hi);
            if(idx&gt;k){
                hi= idx-1;
            }else if(idx&lt;k){
                lo= idx+1;
            }else{
                return nums[idx];
            }
        }
        return nums[lo];
    }
    private int partition(int[] nums, int lo, int hi){
        if(lo&gt;=hi) return lo;
        int i=lo;
        int j=hi+1;
        int key=nums[lo];
        while(true){
            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);
            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);
            if(i&gt;=j) break;
            swap(nums, i, j);
        }
        swap(nums, lo, j);
        return j;
    }
    private void swap(int[] nums, int i, int j){
        int tmp= nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
}
</code></pre><h3 id="Leetcode-215-Kth-Largest-Element-in-An-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-An-Array" class="headerlink" title="Leetcode 215 . Kth Largest Element in An Array"></a>Leetcode 215 . Kth Largest Element in An Array</h3><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>The smart approach for this problem is to use the selection algorithm, based on the partition method - the same one as used in quicksort</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><pre><code>class Solution {
    public int findKthLargest(int[] nums, int k) {
        k= nums.length-k;
        int lo=0;
        int hi= nums.length-1;
        while(lo&lt;=hi){
            int idx= partition(nums, lo, hi);
            if(idx&gt;k){
                hi= idx-1;
            }else if(idx&lt;k){
                lo= idx+1;
            }else{
                return nums[idx];
            }
        }
        return nums[lo];
    }
    private int partition(int[] nums, int lo, int hi){
        if(lo&gt;=hi) return lo;
        int i=lo;
        int j=hi+1;
        int key=nums[lo];
        while(true){
            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);
            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);
            if(i&gt;=j) break;
            swap(nums, i, j);
        }
        swap(nums, lo, j);
        return j;
    }
    private void swap(int[] nums, int i, int j){
        int tmp= nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
}
</code></pre><h3 id="Leetcode-376-Wiggle-Subsequence"><a href="#Leetcode-376-Wiggle-Subsequence" class="headerlink" title="Leetcode. 376 Wiggle Subsequence"></a>Leetcode. 376 Wiggle Subsequence</h3><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题一开始用的是很蠢的dp； 如下</p>
<pre><code>class Solution {
     public int wiggleMaxLength(int[] nums){
        if(nums.length==0) return 0;
        if(nums.length==1) return 1;
        int[] decrease= new int[nums.length];// the previous is decrease
        int[] increase= new int[nums.length];// the previous is increase
        int res=0;
        increase[0]=1;
        decrease[0]=1;
        for(int i=1; i&lt;nums.length; i++){
            increase[i]=1;
            decrease[i]=1;
            for(int j=0; j&lt;i; j++){
                if(nums[i]&gt;nums[j])
                    increase[i]=Math.max(decrease[j]+1, increase[i]);
                if(nums[i]&lt;nums[j])
                    decrease[i]=Math.max(increase[j]+1, decrease[i]);
            }
            res=Math.max(increase[i], res);
            res=Math.max(decrease[i], res);
        }
        return res;

    }
}
</code></pre><p>时间复杂度是O(n^2)，属于能解出来但是没能对问题有深入理解的：</p>
<p>我们没有必要去追溯之前的每一个值， 只要最近的一个， 也就是i-1就可以了。画个图我们就能理解了。</p>
<pre><code>public class Solution{
    public int wiggleMaxLength(int[] nums){
        if(nums.length&lt;2) return nums.length;
      int down=1, up=1;
      for(int i=1; i&lt;nums.length; i++){
          if(nums[i]&gt;nums[i-1]) up=down+1;
        else if(nums[i]&lt;nums[i-1])
          down=up+1;
      }
      return Math.max(down, up);
    }
}
</code></pre><h3 id="Leetcode-227-Basic-Calculator"><a href="#Leetcode-227-Basic-Calculator" class="headerlink" title="Leetcode 227. Basic Calculator"></a>Leetcode 227. Basic Calculator</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>如何将中缀表达式转换为后缀表达式：</p>
<ol>
<li>当遇到数字直接送至输出队列中；</li>
<li>当读到运算符t时：<ol>
<li>将栈中所有优先级高于或等于t的运算符弹出， 送到输出队列中（aka, 从栈顶开始， 依次弹出比当前处理的运算符优先级高的运算符， 直到一个比他优先级低的或者遇到了一个左括号就停止）。</li>
<li>t进栈</li>
</ol>
</li>
</ol>
<ol>
<li>读到左括号时总是将它压入栈中；</li>
<li>读到右括号时， 将靠近栈顶的第一个左括号上面的运算符全部依次弹出， 送至输出队列后， 再丢弃左括号。</li>
<li>中缀表达式全部读完后， 若栈中仍有运算符， 将其送到输出队列中。</li>
</ol>
<p>运用后缀表达式进行运算：</p>
<ol>
<li><p>建立一个栈S;</p>
</li>
<li><p>从左到右读后缀表达式， 读到数字就让它转换成数值压入栈S中， 读到运算符则从栈中依次弹出两个树分别到Y和X， 然后以“X运算符Y”的形式计算机出结果， 再压入栈S中；</p>
</li>
<li><p>如果后缀表达式未读完， 就重复上面过程， 最后输出栈顶的数值则为结束。</p>
<pre><code>while there are tokens to be read:

read a token.

if the token is a number, then push it to the output queue.

if the token is an operator, then:

    while there is an operator at the top of the operator stack with
        greater than or equal to precedence and the operator is left associative:
            pop operators from the operator stack, onto the output queue.
    push the read operator onto the operator stack.

if the token is a left bracket (i.e. &quot;(&quot;), then:

    push it onto the operator stack.

if the token is a right bracket (i.e. &quot;)&quot;), then:

    while the operator at the top of the operator stack is not a left bracket:
        pop operators from the operator stack onto the output queue.
    pop the left bracket from the stack.
    /* if the stack runs out without finding a left bracket, then there are
    mismatched parentheses. */

if there are no more tokens to read:

    while there are still operator tokens on the stack:
    /* if the operator token on the top of the stack is a bracket, then
    there are mismatched parentheses. */
    pop the operator onto the output queue.

exit.
</code></pre><p>​</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4></li>
</ol>
<pre><code>class Solution {
    public  int calculate(String s){
        s=s.replace(&quot; &quot;,&quot;&quot;);
        Stack&lt;String&gt; operators= new Stack&lt;&gt;();
        List&lt;String&gt; tokens= new ArrayList&lt;String&gt;();
        // transfer to suffix expression
        for(int i=0; i&lt;s.length(); i++){
            char ch= s.charAt(i);
            if(ch==&#39;+&#39; || ch==&#39;-&#39;){
                while(!operators.isEmpty()){
                    tokens.add(operators.pop());
                }
                operators.push(String.valueOf(ch));
            }else if(ch==&#39;*&#39; || ch==&#39;/&#39;){
                while(!operators.isEmpty() &amp;&amp; (operators.peek().equals(&quot;*&quot;)||operators.peek().equals(&quot;/&quot;))){
                    tokens.add(operators.pop());
                }
                operators.push(String.valueOf(ch));
            }else{
                StringBuilder sb= new StringBuilder();
                while(i&lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i))){
                    sb.append(s.charAt(i));
                    i++;
                }
                i--;
                tokens.add(sb.toString());
            }
        }
        while(!operators.isEmpty()){
            tokens.add(operators.pop());
        }
        // calculate the suffix expression
        Stack&lt;Integer&gt; nums= new Stack&lt;Integer&gt;();
        for(String token: tokens){
            if(Character.isDigit(token.charAt(0))){
                nums.push(Integer.valueOf(token));
            }else{
                int num_2=nums.pop();
                int num_1=nums.pop();
                nums.push(cal(num_1,num_2, token));
            }
        }
        return nums.pop();
    }
    private int cal(int num1, int num2, String token){
        if(token.equals(&quot;+&quot;)) return num1+num2;
        if(token.equals(&quot;*&quot;)) return num1*num2;
        if(token.equals(&quot;-&quot;)) return num1-num2;
        if(token.equals(&quot;/&quot;)) return num1/num2;
        return 0;
    }
}
</code></pre><h3 id="Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee"></a>Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</h3><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</code></pre><h4 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h4><p>经典的状态机，Stock系列的新题， 但是基本上跟之前的题目差不多， 我们用两个状态 one and zero 来记录手上握有的股票数量， 利用更新dp公式进行两个状态的更新。</p>
<pre><code>class Solution {
public int maxProfit(int[] prices, int fee){
        // two state: one and zero;
        if(prices.length&lt;=1) return 0;
        long zero=0;
        long one=Integer.MIN_VALUE;
        for(int i=0; i&lt;prices.length; i++){
            long zero_prev=zero;
            long one_prev=one;
            zero=Math.max(zero_prev, one_prev+prices[i]-fee);
            one= Math.max(one_prev, zero_prev-prices[i]);
        }
        return (int)Math.max(one, zero);
    }
}
</code></pre><h3 id="Leetcode-609-Find-Duplicate-File-in-System"><a href="#Leetcode-609-Find-Duplicate-File-in-System" class="headerlink" title="Leetcode 609. Find Duplicate File in System"></a>Leetcode 609. Find Duplicate File in System</h3><h3 id="Leetcode-450-Delete-Node-in-a-BST"><a href="#Leetcode-450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode 450. Delete Node in a BST"></a>Leetcode 450. Delete Node in a BST</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<pre><code>root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
</code></pre><h4 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h4><p>骚的要死的递归， 代码如下：</p>
<pre><code>class Solution {
    public TreeNode deleteNode(TreeNode root, int key){
        if(root==null) return null;
        if(root.val&gt;key){
            root.left=deleteNode(root.left, key);
        }else if(root.val&lt;key){
            root.right= deleteNode(root.right, key);
        }else{
            root=deleteRoot(root);
        }
        return root;
    }
    public TreeNode deleteRoot(TreeNode root){
        if(root.left==null) return root.right;
        if(root.right==null) return root.left;
        TreeNode node= root.right;
        while(node.left!=null){
            node= node.left;
        }
        root.val=node.val;
        root.right=deleteNode(root.right, root.val);
        return root;
    }
      private TreeNode deleteRoot(TreeNode root) {
        ifs (root==null) return null;
        if (root.right==null) return root.left;
        TreeNode x=root.right; // root.right should be the new root
        while (x.left!=null) x=x.left; // find the left-most node
        x.left=root.left;
        return root.right;
    }
}
</code></pre><h3 id="Leetcode-32-Longest-Valid-Parentheses"><a href="#Leetcode-32-Longest-Valid-Parentheses" class="headerlink" title="Leetcode 32. Longest Valid Parentheses"></a>Leetcode 32. Longest Valid Parentheses</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p>
<p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p>
<h4 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h4><p>对于这一类问题， 基本都是two-pass， 从左到右扫描一遍， 再从右到做扫描一遍。</p>
<p>Code:</p>
<pre><code>public int longestValidParentheses(String s){
        int prev=-1;
        int count=0;
        int res=0;
        for(int i=0; i&lt;s.length(); i++){
            if(s.charAt(i)==&#39;(&#39;) count++;
            else{
                count--;
            }
            if(count&lt;0){
                count=0;
                prev=i;
            }else if(count==0){
                res=Math.max(res, i-prev);
            }
        }
        prev=s.length();
        count=0;
        for(int i=s.length()-1; i&gt;=0; i--){
            if(s.charAt(i)==&#39;)&#39;) count++;
            else{
                count--;
            }
            if(count&lt;0){
                count=0;
                prev=i;
            }else if(count==0){
                res= Math.max(res, prev-i);
            }
        }
        return res;
    }
</code></pre><h3 id="Leetcode-34-Search-for-a-Range"><a href="#Leetcode-34-Search-for-a-Range" class="headerlink" title="Leetcode 34. Search for a Range"></a>Leetcode 34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>非常经典的一道binary search， 考察对二分搜索的理解程度， 这里我们先看一个链接<a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">二分搜索有几种方式</a>。</p>
<p>首先有几个数字要注意</p>
<p>中位数有两个，</p>
<ol>
<li>下位中位数， lowerMedian=(length-2)/2</li>
<li>上位中位数， upperMedian=length/2</li>
</ol>
<p>常用的是下位中位数， 通用的写法如下， 语言int经常自动向下取整，</p>
<blockquote>
<p>median=(length-1)/2</p>
</blockquote>
<p>指针的区间当然可以开区间，也可以闭区间， 也可以半开半闭。 但老老实实两头取闭区间总是不会错。 上面的中位数， 转换成两头闭区间就会变成这样：</p>
<blockquote>
<p>median=low+(hight-low)/2；</p>
</blockquote>
<p>另一个关键点是<strong>终止条件</strong>。</p>
<p>不要以low=high做终止条件，会被跳过的。</p>
<p>不相信在[1,5]里面找0试试？</p>
<p>正确的终止条件是：</p>
<blockquote>
<p>low&gt;high</p>
</blockquote>
<p>也就是搜索空间为空。</p>
<p>满足终止条件之后， 返回值完全不需要纠结， 直接返回地位low。</p>
<p>因为回过头去放慢镜头， 二分查找到的过程就是一个维护low的过程：</p>
<blockquote>
<p>low从0 开始， 只在中位数遇到确定小于目的数时才前进， 并且永不后退。 low一直在朝着第一个目标数的位置在逼近。 直到最后到达。</p>
</blockquote>
<p>至于高位high， 就放心大胆地缩小目标数组的空间吧。</p>
<p>所以最后的代码非常简单。</p>
<pre><code>public int binarySearch(int[] nums, int target){
    int low=0, high= nums.length-1;
  while(low&lt;=high){
      int mid= low+(high-low)/2;
    if(nums[mid]&lt;target){
        low= mid+1;
    }
    if(nums[mid]&gt;target){
        high= mid-1;
    }
    if(nums[mid]==target) return mid;
  }
  return low;
}
</code></pre><p>但上面的代码能正常工作，有一个前提条件：</p>
<p>元素空间没有重复值。</p>
<p>推广到有重复值的空间， 二分查找问题就变成：</p>
<p>寻找元素第一次出现的位置。</p>
<pre><code>public int firstOccurrence(int[] nums, int target){
    int low=0, high= nums.length-1;
  while(low&lt;=high){
      int mid= low+(high-low)/2;
    if(nums[mid]&lt;target) low=mid+1;
    else high= mid-1;
  }
  return low;
}
</code></pre><p>由上述讲解， 我们有下面两种代码：</p>
<pre><code>public class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length==0) return new int[]{-1,-1};
        int left=searchInsertLo(nums, target);
        if(left==nums.length || nums[left]!=target){
            return new int[]{-1, -1};
        }
        int right=searchInsertHi(nums, target);
        return new int[]{left, right};
    }
    public int searchInsertLo(int[] nums, int target) {
        if(target&gt;nums[nums.length-1]) return nums.length;
        int lo=0;
        int hi=nums.length-1;
        while(lo&lt;=hi){
            int mid=(lo+hi)/2;
            if(nums[mid]&gt;=target){
                hi=mid-1;
            }else{
                lo=mid+1;
            }
        }
        return lo;
    }
    public int searchInsertHi(int[] nums, int target){
        if(target&gt;nums[nums.length-1]) return nums.length;
        if(target&lt;nums[0]) return 0;
        int lo=0;
        int hi=nums.length-1;
        while(lo&lt;=hi){
            int mid=(lo+hi+1)/2;
            if(nums[mid]&gt;target){
                hi=mid-1;
            }else{
                lo=mid+1;
            }
        }
        return hi;
    }
}
</code></pre><p>以及</p>
<pre><code>class Solution {
    public int[] searchRange(int[] nums, int target){
        if(nums.length==0) return new int[]{-1,-1};
        int left= searchLeft(nums, target);
        if(left==nums.length || nums[left]!=target){
            return new int[]{-1, -1};
        }
        int right= searchLeft(nums, target+1)-1;
        return new int[]{left, right};
    }
    public int searchLeft(int[] nums, int key){
        int lo=0;
        int hi=nums.length-1;
        while(lo&lt;=hi){
            int mid= lo+(hi-lo)/2;
            if(nums[mid]&lt;key){
                lo= mid+1;
            }else if(nums[mid]&gt;=key){
                hi= mid-1;
            }
        }
        return lo;
    }
}
</code></pre><h3 id="Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Leetcode 114. Flatten Binary Tree to Linked List"></a>Leetcode 114. Flatten Binary Tree to Linked List</h3><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,</p>
<p>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><h4 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h4><p>这道题是很经典的关于Tree的遍历以及对tree结构的修改的题目， 这里我们先观察输出的结构， 发现它是遵循preorder的顺序的， 于是这里我们先利用preorder得出整个tree的结构， 然后在这个过程里面进行修改。</p>
<p>先看下面一种解法：</p>
<pre><code>public void flatten_stack(TreeNode root){
        Stack&lt;TreeNode&gt; stack= new Stack&lt;TreeNode&gt;();
        TreeNode node= root;
        TreeNode prev= root;
        while(!stack.isEmpty() || node!=null){
            if(node!=null){
                stack.push(node);
                prev= node;
                node= node.left;
            }else{
                TreeNode pop= stack.pop();
                node= node.right;
                pop.right= null;
                prev.left= node;
            }
        }
        node= root;
        while(node!=null){
            TreeNode left= node.left;
            node.left= null;
            node.right= left;
            node= node.right;
        }
    }
</code></pre><p>先把树输出为向左的linkedlist， 而后再reverse就好了。</p>
<p>这个也可以使用recursive完成。</p>
<pre><code>class Solution {
    public void flatten(TreeNode root) {
        if(root==null) return;
        if(root.left==null){
            flatten(root.right);
            return;
        }
        flatten(root.left);
        flatten(root.right);
        TreeNode left= root.left;
        root.left= null;
        TreeNode right= root.right;
        TreeNode node= left;
        while(node.right!=null){
            node= node.right;
        }
        root.right=left;
        node.right= right;
    }
}
</code></pre><p>最神奇的做法：</p>
<pre><code>private TreeNode prev = null;

public void flatten(TreeNode root) {
    if (root == null)
        return;
    flatten(root.right);
    flatten(root.left);
    root.right = prev;
    root.left = null;
    prev = root;
}
</code></pre><p>这里我们重点讲解一下最后一个代码：</p>
<pre><code>private TreeNode prev = null;

public void flatten(TreeNode root) {
    if (root == null)
        return;
    flatten(root.right);
    flatten(root.left);
    prev = root;
}
</code></pre><p>这个结构是典型的post-order遍历， 我们得到的序列是什么呢？</p>
<p>以上面的tree为例子： root的输出结果是： null, 6， 5，4，3，2,1,我们就是依靠root， prev的结果进行对树的机构进行重构：</p>
<pre><code>root.right= prev;
root.left = null;
</code></pre><p>进行了上述结构之后， 我们就完成了重构。</p>
<h3 id="Leetcode-44-Wildcard-Matching"><a href="#Leetcode-44-Wildcard-Matching" class="headerlink" title="Leetcode 44. Wildcard Matching"></a>Leetcode 44. Wildcard Matching</h3><p>Implement wild card pattern matching with support for “?” and “*”;</p>
<pre><code>&#39;?&#39; Matches any single character.
&#39;*&#39; Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&quot;aa&quot;,&quot;a&quot;) → false
isMatch(&quot;aa&quot;,&quot;aa&quot;) → true
isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false
isMatch(&quot;aa&quot;, &quot;*&quot;) → true
isMatch(&quot;aa&quot;, &quot;a*&quot;) → true
isMatch(&quot;ab&quot;, &quot;?*&quot;) → true
isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false
</code></pre><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>典型的dp问题， 比较tricky的一个点是如果碰到’*’怎么办， 这个时候， 我们采取回退的思想， 如果碰到的时候:</p>
<pre><code>// when p.charAt(j)==&#39;*&#39;, we check if dp[i-1][j]; 
// 这里把疑问推给上一个问题， 比较巧妙。
dp[i][j]= dp[i-1][j] || dp[i][j-1];
</code></pre><p>code:</p>
<pre><code>public boolean isMatch(String s, String p){
    boolean[][] dp= new boolean[s.length()+1][p.length()+1];
  dp[0][0]= true;
  for(int i=1; i&lt;= p.length(); i++){
      if(p.charAt(i-1)==&#39;*&#39;) dp[0][i]= dp[0][j-1];
  }
  for(int i=1; i&lt;=s.length(); i++){
      for(int j=1; j&lt;=p.length(); j++){
          char ch= p.charAt(j-1);
        if(ch==&#39;?&#39; || s.charAt(i-1)==ch) dp[i][j]= dp[i-1][j-1];
        else if(ch==&#39;*&#39;){
            dp[i][j]= dp[i][j-1] || dp[i-1][j];
        }else{
            dp[i][j]= false;
        }
      }
  }
  return dp[s.length()][p.length()];
}
</code></pre><h3 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10. Regular Expression Matching"></a>Leetcode 10. Regular Expression Matching</h3><p>Implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<pre><code>&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&quot;aa&quot;,&quot;a&quot;) → false
isMatch(&quot;aa&quot;,&quot;aa&quot;) → true
isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false
isMatch(&quot;aa&quot;, &quot;a*&quot;) → true
isMatch(&quot;aa&quot;, &quot;.*&quot;) → true
isMatch(&quot;ab&quot;, &quot;.*&quot;) → true
isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true
</code></pre><p>这道题和上面那道题目基本上是一样的， 所不同的是， 这次我们要把 a* 作为一个整体去考虑， 对于这样一个元素，我们可以匹配:</p>
<ol>
<li><p>空字符串。</p>
</li>
<li><p>a， 这个时候基本上就消除了*的影响。</p>
</li>
<li><p>多个a， 这个时候 * 还在起作用 我们像上一道题目一样惊醒回退。</p>
<p>​</p>
</li>
</ol>
<p>这里题目应该是假设字符串一定是合法的， 即不会出现*前面没有合法字符的情况。</p>
<pre><code>public class Solution {
    public boolean isMatch(String s, String p) {
        if(s == null || p == null) {
            return false;
        }
        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];
        state[0][0] = true;
        // no need to initialize state[i][0] as false
        // initialize state[0][j]
        for (int j = 1; j &lt; state[0].length; j++) {
            if (p.charAt(j - 1) == &#39;*&#39;) {
                if (state[0][j - 1] || (j &gt; 1 &amp;&amp; state[0][j - 2])) {
                    state[0][j] = true;
                }
            } 
        }
        for (int i = 1; i &lt; state.length; i++) {
            for (int j = 1; j &lt; state[0].length; j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &#39;.&#39;) {
                    state[i][j] = state[i - 1][j - 1];
                }
                if (p.charAt(j - 1) == &#39;*&#39;) {
                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != &#39;.&#39;) {
                        state[i][j] = state[i][j - 2];
                    } else {
                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];
                    }
                }
            }
        }
        return state[s.length()][p.length()];
    }
}
</code></pre><h3 id="leetcode-222-Count-Complete-Tree-Nodes"><a href="#leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="leetcode 222. Count Complete Tree Nodes."></a>leetcode 222. Count Complete Tree Nodes.</h3><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h4 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题需要注意的是题目中给我们的是complete tree，which means， root.left 和 root.right中必定有一株树是满的， 而哪一个数是满的则需要看最后一个node是终止在哪里， 也就是说， height， 这里我们计算每棵树的height便可以解决这个问题：</p>
<pre><code>class Solution {
    public int height(TreeNode root){
        int h=-1;
        TreeNode node =root;
        while(node!= null){
            node= node.left;
            h++;
        }
        return h;
    }
    public int countNodes(TreeNode root) {
        if(root== null) return 0;
        int h= height(root);
        int left= height(root.right);
        if(left== h-1){
            // the left tree is full tree;
            return countNodes(root.right)+ (1&lt;&lt;h);
        }else{
            return countNodes(root.left)+ (1&lt;&lt;(h-1));
        }
    }
}
</code></pre><h3 id="Leetcode-322-Coin-Change"><a href="#Leetcode-322-Coin-Change" class="headerlink" title="Leetcode 322. Coin Change"></a>Leetcode 322. Coin Change</h3><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p>
<p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p>
<p><strong>Note</strong>:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p>经典dp：</p>
<pre><code>class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp= new int[amount+1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0]= 0;
        for(int coin: coins){
            for(int i=coin; i&lt;=amount; i++){
                if(dp[i-coin]==Integer.MAX_VALUE) continue;
                dp[i]=Math.min(dp[i- coin]+1, dp[i]);
            }
        }
        return dp[amount]==Integer.MAX_VALUE? -1: dp[amount];
    }
}
</code></pre><h3 id="Leetcode-518-Coin-Change2"><a href="#Leetcode-518-Coin-Change2" class="headerlink" title="Leetcode 518 Coin Change2"></a>Leetcode 518 Coin Change2</h3><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p><strong>Note:</strong> You can assume that</p>
<ul>
<li>0 &lt;= amount &lt;= 5000</li>
<li>1 &lt;= coin &lt;= 5000</li>
<li>the number of coins is less than 500</li>
<li>the answer is guaranteed to fit into signed 32-bit integer</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: amount = 10, coins = [10] 
Output: 1
</code></pre><h3 id="Leetcode-312-Burst-Ballons"><a href="#Leetcode-312-Burst-Ballons" class="headerlink" title="Leetcode 312. Burst Ballons"></a>Leetcode 312. Burst Ballons</h3><p>运用dp的做法， 逆向思维， 很骚。</p>
<h3 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143. Reorder List"></a>Leetcode 143. Reorder List</h3><hr>
<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p>
<p>典型的链表题， 快慢指针+ node的插入+list reverse.</p>
<h4 id="Solution-19"><a href="#Solution-19" class="headerlink" title="Solution"></a>Solution</h4><pre><code>class Solution {
    public void reorderList(ListNode head) {
        // first reverse the listnode from middle;
        if(head== null || head.next==null) return;
        ListNode fast= head;
        ListNode slow= head;
        ListNode prev= head;
        while(fast!= null &amp;&amp; fast.next!=null){
            prev= slow;
            slow= slow.next;
            fast= fast.next.next;
        }
        ListNode tail= slow;
        while(tail.next!= null){
            ListNode next= tail.next;
            tail.next= next.next;
            next.next= prev.next;
            prev.next= next;
        }
        ListNode mid= prev.next;
        ListNode node= head;
        while(node!=prev){
            prev.next= mid.next;
            mid.next= node.next;
            node.next= mid;
            node= node.next.next;
            mid= prev.next;
        }
    }
}
</code></pre><h3 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92. Reverse Linked List II"></a>Leetcode 92. Reverse Linked List II</h3><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<h3 id="Solution-20"><a href="#Solution-20" class="headerlink" title="Solution"></a>Solution</h3><p>综合性的链表题目。</p>
<pre><code>class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy= new ListNode(0);
        dummy.next=head;
        ListNode prev= dummy;
        for(int i=1; i&lt;m; i++){
            prev= prev.next;
        }
        ListNode tail= prev.next;
        for(int i=0; i&lt;n-m; i++){
            ListNode next= tail.next;
            tail.next= next.next;
            next.next= prev.next;
            prev.next= next;
        }
        return dummy.next;
    }
}
</code></pre><h3 id="Leetcode-274-H-Index"><a href="#Leetcode-274-H-Index" class="headerlink" title="Leetcode 274 H- Index"></a>Leetcode 274 H- Index</h3><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least*</strong>h<em>citations each, and the other </em>N − h<em> papers have <strong>no more than</strong> </em>h* citations each.”</p>
<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong><code>3</code>citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>
<p><strong>Note</strong>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>
<h4 id="Solution-21"><a href="#Solution-21" class="headerlink" title="Solution"></a>Solution</h4><p>感觉主要还是对于题意的理解， 对于这道题来说，对于一个长度为N的Array， 因为我们要求这么一个常数h， 使得大于等于h的个数要不小于h， 也就是说我们其实是可以先排序， 然后统计个数， 得到count以及该数字， 如果满足上述条件， 我们可以返回，得到当前数字。</p>
<p>需要注意的地方是count++， 以及if statement的顺序： 应该是if statement放在前面， 要不然可能会多算： ex: [1, 2];</p>
<p>Simple Version:</p>
<pre><code>class Solution {
  // we simple count the two number, and when it meets the requirement, we output it and that is the answer, what need to notice is the order of if statement and increacement; 
    public int hIndex(int[] citations) {
        // A scientist has index h if h of his/her papers have at least h citations each, and other N-h papers has no more than h citations each;
        if(citations.length==0) return 0;
        Arrays.sort(citations);
        int count=0;
        for(int i=citations.length-1; i&gt;=0; i--){
            if(citations[i]==0) continue;
            if(count&gt;=citations[i]) return count;
            count++;
        }
        return count;
    }
}
</code></pre><p>观察到h最大只能是N， 我们可以用bucket sort 进行改善：</p>
<pre><code>public int hIndex(int[] citations){
    int[] buckets= new int[citations.length+1];
    for(int num: citations){
        if(num&gt;= citations.length){
            buckets[citations.length]++;
        }else{
            buckets[num]++;
        }
    }
    int count=0;
    for(int i= buckets.length-1; i&gt;=0; i--){
        count+=buckets[i];
        if(count&gt;=i) return i;
    }
    return 0;
}
</code></pre><h4 id="FollowUp"><a href="#FollowUp" class="headerlink" title="FollowUp"></a>FollowUp</h4><p>What if the citations array is sorted in ascending order? Could you optimize algorithm？</p>
<p>在这种情况下， 题目演变成一个binary search的题目： 我们需要找到的是 citations[mid]刚好小于len- mid的那一个点。(这个mid西需要尽量往左边移， 也就是标准的binary search)。实现代码如下：</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        int left=0, len = citations.size(), right= len-1,  mid;
        while(left&lt;=right)
        {
            mid=(left+right)&gt;&gt;1;
            if(citations[mid]== (len-mid)) return citations[mid];
            else if(citations[mid] &gt; (len-mid)) right = mid - 1;
            else left = mid + 1;
        }
        return len - (right+1);
    }
};
</code></pre><h3 id="Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Leetcode 378. Kth Smallest Element in a Sorted Matrix"></a>Leetcode 378. Kth Smallest Element in a Sorted Matrix</h3><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong></p>
<pre><code>matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
</code></pre><p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h4 id="Solution-22"><a href="#Solution-22" class="headerlink" title="Solution"></a>Solution</h4><p>比较简单/ straightforward的方法是使用priorityqueue， 相当于进行了一次mergesort进行寻找， 这里我们直接贴出代码：</p>
<pre><code>class Solution {
    private class Entry{
        int val;
        int index_x;
        int index_y;
        public Entry(int val, int index_x, int index_y){
            this.val= val;
            this.index_x= index_x;
            this.index_y= index_y;
        }
    }
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue&lt;Entry&gt; pq= new PriorityQueue&lt;&gt;((e1, e2)-&gt;{return e1.val- e2.val;});
        for(int i=0; i&lt;matrix.length; i++){
            pq.offer(new Entry(matrix[i][0], i, 0));
        }
        while(k&gt;0){
            Entry e= pq.poll();
            k--;
            if(k==0) return e.val;
            if(e.index_y+1&lt;matrix[0].length){
                pq.offer(new Entry(matrix[e.index_x][e.index_y+1], e.index_x, e.index_y+1));
            }
        }
        return -1;
    }
}
</code></pre><p>这里我们讲解一个更加快的方法： BinarySearch， 通常的二分搜索， 其搜索空间是在index上面对的，0~Arr.length;这里我们改变搜索空间， 变成min~ max.然后计算其排名。 代码实现如下：</p>
<pre><code>class Solution {
    public int kthSmallest(int[][] a, int k) {
      int n = a.length;
      int s = a[0][0]; // the smallest number
      int b = a[n - 1][n - 1]; // the biggest number

      while(s &lt; b) {
          int mid = s + (b - s) / 2;
          int temp = 0;
          for(int i = 0; i &lt; n; i++) {
              temp += bs(a[i], n, mid);
          }
          if(temp &lt; k) {
              s = mid + 1;
          } else {
              b = mid;
          }
      }

      return s;
    }


    private int bs(int row[], int right, int target) {
        int left = 0;
        //int pos = right + 1;
        while(left &lt; right) {
            int mid = left + (right - left) / 2;
            if(row[mid] &lt;= target) {
                //pos = mid;
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
</code></pre><p>想法：</p>
<p>Let’s binary search for the answer A.</p>
<p>Say enough(x) is true iff there are k or more values in the multiplication table that are less than or equal to x, Colloquially, enough describes whether x is large enough to be the k-th value in the multiplication table.</p>
<p>Then(for our answer A), whenever x&gt;= A, enough(X) is True, and whenever x&lt;A, enough(x) is false.</p>
<p>In our binary search, our loop invariant is that enough(x) is True. More specifically, if we were to apply enough onto each argument in the interval [lo. hi], we would see 0 or more False, followed by 1 or more True. Once lo==hi, we know that enough(lo)=True, and it must have been the smallest such one, because lo must have been hi-1 or hi-2 at some point, and mi= hi-1 would have been checked.</p>
<pre><code>class Solution{
    public int findKthNumber(int m, int n, int k){
        int low=1, high= m*n+1;
      while(lo&lt;high){
          int mid= low+(high-low)/2;
        int c= count(mid, m, n);
        if(c&gt;= k) high= mid;
        else low= mid+1;
      }
      return high;
    }
  private int count(int v, int m, int n){
      int count=0;
    for(int i=1; i&lt;= m; i++){
        int temp= Math.min(v/i, n);
          count+=temp;
    }
    return count;
  }
}
</code></pre><p>或者：</p>
<pre><code>class Solution {
    public int findKthNumber(int m, int n, int k) {
        int low=1, high= m*n;
        while(low&lt;=high){
            int mid= low+(high-low)/2;
            int c= count(mid, m, n);// calculate the rank 
            if(c&gt;=k) high= mid-1; // if rank&gt;= k, means we can still push to left;
            else low= mid+1;// else 
        }
        return low;
    }
    private int count(int v, int m, int n){
        int count=0;
        for(int i=1; i&lt;=m; i++){
            int temp= Math.min(v/i, n);
            count+=temp;
        }
        return count;
    }
}
</code></pre><h3 id="Where-和-having-区别"><a href="#Where-和-having-区别" class="headerlink" title="Where 和 having 区别"></a>Where 和 having 区别</h3><p>在select语句中可以使用group by子句将行划分成较小的组， 然后， 使用聚组函数返回每一个组的汇总信息， 另外， 可以使用having子句限制返回的结果集。</p>
<p>在带有group by子句的查询语句中， 在select列表中指定的列要么是group by子句中指定的列， 要么包含聚组函数。</p>
<p>select max(sal), job emp group by job;</p>
<p>当在group by子句中使用having子句时， 查询结果只返回满足having条件的组。</p>
<p>where子句的作用时在查询结果进行分组前， 将不符合where条件的行去掉， 即在分组之前过滤数据， 条件中不能包含聚组函数， 使用where条件显示特定的行。</p>
<p>having子句的作用时筛选满足条件的组， 即在分组之前过滤数据， 条件中经常包含聚组函数， 使用having条件显示特定的组， 也可以使用多个分组标准进行分组。</p>
<p>如果你对何时应该使用WHERE，何时使用HAVING仍旧很迷惑，请遵照下面的说明：</p>
<p>　　WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。</p>
<p>　　HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。</p>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>对于一个长度为n的已排序数列a, 如果n为奇数， 中位数为a[n/2+1]， 若n为偶数， 则中位数(a[n / 2] + a[n / 2 + 1]) / 2; 如果我们可以在两个数列中求取第K小的元素， 便可以解决该问题； 不妨设数列A元素个数为n， 数列B元素个数为m， 各自升序排列，求第k小元素； 取A[k/2] B[k/2]比较； 如果 A[k/2]&gt; B[k/2] 那么， 所求的元素必然不在B的前k/2个元素中；反之， 必然不在A的前k/2个元素中， 于是我们可以将A或B数列的前k/2元素删去， 于是我们得到了数据规模变小的同类问题， 递归解决；</p>
<h3 id="Leetcode-136-Single-Number"><a href="#Leetcode-136-Single-Number" class="headerlink" title="Leetcode 136. Single Number"></a>Leetcode 136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>极度高频题， 记住就是了。</p>
<pre><code>int singleNumber(int[] A, int n){
  int res=0;
  for(int i=0; i&lt;n; i++){
    result^=A[i];
  }
  return result;
}
</code></pre><h3 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a>Roman to Integer</h3><h3 id="Leetcode-204-Count-Primes"><a href="#Leetcode-204-Count-Primes" class="headerlink" title="Leetcode 204. Count Primes"></a>Leetcode 204. Count Primes</h3><pre><code>class Solution {
    public int countPrimes(int n) {
        if(n&lt;2) return 0;
        if(n==2) return 1;
        boolean[] dp= new boolean[n];
        int count=0;
        for(int i=2; i&lt;n; i++){
            if(!dp[i]){
                count++;
                for(int j=1; j*i&lt;n; j++){
                    dp[j*i]= true;
                }
            }
        }
        return count;
    }
}
</code></pre><h3 id="用-Array实现一个Queue"><a href="#用-Array实现一个Queue" class="headerlink" title="用 Array实现一个Queue"></a>用 Array实现一个Queue</h3><h3 id="背包问题Review"><a href="#背包问题Review" class="headerlink" title="背包问题Review"></a>背包问题Review</h3><h3 id="Java中对JSON文件的读取"><a href="#Java中对JSON文件的读取" class="headerlink" title="Java中对JSON文件的读取"></a>Java中对JSON文件的读取</h3><p>JSON语法是JavaScript对象表示法语法的子集：</p>
<ul>
<li>数据在名称/值 对中</li>
<li>数据由括号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h3 id="Leetcode-68-Text-Justification"><a href="#Leetcode-68-Text-Justification" class="headerlink" title="Leetcode 68. Text Justification"></a>Leetcode 68. Text Justification</h3><p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line, Pad extra spaces ‘’ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<h4 id="Solution-23"><a href="#Solution-23" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目其实满傻逼的….硬算，保持一个index， 每次长度超过L的时候停止， 处理这一行的情况。</p>
<p>注意两种情况：</p>
<ol>
<li>if last line(last==words.length) or the number of words in the line is 1(diff==0) 在这种情况下， 我们需要left-Justify： 添加单词， 添加单词之间的空格， 增加单词之后的空格使得长度为L；</li>
<li>通常情况： middle justify， 在这种情况下， 我们要使得单词之间的空格尽可能均匀， 如果还有空格多的话， 尽量放在左边， 也就是说前面的多放一个空格： 我们把多余的空格数量标记为r， if r&gt;0 我们在需要增加的空格数字加一， 否则直接就是当前空格数。当然， 这种情况下不允许出现最后一个单词之后还有空格。</li>
</ol>
<pre><code>public List&lt;String&gt; fullJustify(String[] words, int L){
    List&lt;String&gt; lines= new ArrayList&lt;String&gt;();
    int index=0;
    while(index&lt;words.length){
        int count= words[index].length();
        int last= index+1;
        while(last&lt;words.length){
            if(words[last].length()+ count+1&gt; L) break;
            count+=words[last].length()+1;
            last++;
        }
        StringBuilder builder= new StringBuilder();
        int diff= last- index-1;
        // if last line or number of words in the line is 1, left-justified
        if(last==words.length || diff==0){
            for(int i= index; i&lt;last; i++){
                builder.append(words[i] +&quot; &quot;);
            }
            builder.deleteCharAt(builder.length()-1);
            for(int i= builder.length(); i&lt;L; i++){
                builder.append(&quot; &quot;);
            }
        }else{
            // middle justified
            int spaces= (L- count)/diff;
            int r=(L- count)% diff;
            for(int i= index; i&lt;last; i++){
                builder.append(words[i]);
                if(i&lt;last-1){
                    for(int j=0; j&lt;=(spaces+((i-index)&lt;r?1: 0)); j++){
                        builder.append(&quot; &quot;);
                    }
                }
            }
        }
        lines.add(builder.toString());
        index= last;
    }
    return lines;
}
</code></pre><h3 id="MapReduce-入门"><a href="#MapReduce-入门" class="headerlink" title="MapReduce 入门"></a>MapReduce 入门</h3><p>给你很多String IDS， 然后用hadoop， mapreduce给这些String IDs assign long int numerical IDs</p>
<h3 id="Find-the-row-with-maximum-number-of-1s"><a href="#Find-the-row-with-maximum-number-of-1s" class="headerlink" title="Find the row with maximum number of 1s"></a>Find the row with maximum number of 1s</h3><p>Given a boolean 2D array, where each row is sorted. Find the row with the maximum number of 1s;</p>
<p>Actually, this is a problem like find the max number in a Array;</p>
<pre><code>int rowWithMax1s(bool mat[R][C])
{
    // Initialize first row as row with max 1s
    int max_row_index = 0;

    // The function first() returns index of first 1 in row 0.
    // Use this index to initialize the index of leftmost 1 seen so far
    int j = first(mat[0], 0, C-1);
    if (j == -1) // if 1 is not present in first row
      j = C - 1;

    for (int i = 1; i &lt; R; i++)
    {
        // Move left until a 0 is found
        while (j &gt;= 0 &amp;&amp; mat[i][j] == 1)
        {
           j = j-1;  // Update the index of leftmost 1 seen so far
           max_row_index = i;  // Update max_row_index
        }
    }
    return max_row_index;
}
</code></pre><h3 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h3><p>There is a maze of size n*n. Tom is sitting at (0,0). Jerry is sitting in another cell(the position of Jerry is input). Then there are k pieces of cheese placed in k different cells(k&lt;=10). Sine cells are blocked while some are not. Tom can move to 4 cells at any point of time(left, right, top, down one position). Tom has to collect all the pieces of cheese and then reach to Jerry’s cell. You need to print the minimum no of steps to required to do so.</p>
<p><a href="https://ide.geeksforgeeks.org/TtAvXJ" target="_blank" rel="noopener">link</a></p>
<h3 id="Diamond"><a href="#Diamond" class="headerlink" title="Diamond"></a>Diamond</h3><p>Diamond Mine is your new favorite game. It;s map is represented as n*n matrix, and the value of each cell corresponds to some property of the map:</p>
<ul>
<li>A value&gt;=0 represent a path.</li>
<li>A value of 1 represents a diamond in a path that can be picked up by the player.</li>
<li>A value of -1 represents a wall;</li>
</ul>
<p>The basic rules for playing Diamond Mine are as follows:</p>
<ul>
<li>The player starts at (0,0) and reaches(n-1, n-1), by moving right or down through valid path cells;</li>
<li>After reaching (n-1, n-1), the player must travel to (0, 0) by moving left or up through valid path cells.</li>
<li>When passing through a path cell containing a diamond, the diamond is picked up. Once picked up, the cell becomes an empty path cell(meaning you cannot pick up the same diamond twice).</li>
<li>If there is no valid path between (0,0) and(n-1, n-1), then no diamonds can be collected.</li>
<li>A player wins the game by collecting the maximum number of diamonds possible when following the above rules.</li>
</ul>
<p>Output the largest number.</p>
<h4 id="格子取数问题"><a href="#格子取数问题" class="headerlink" title="格子取数问题"></a>格子取数问题</h4><p>有n*n个格子， 每个格子里有正数或者0， 从最左上角往最右下角走， 只能向下和向右， 一共走两次， 把所有经过的格子的数加起来， 求最大值SUM， 且两次如果经过同一个格子， 则最后总和SUM中该格子的计数只加一次。</p>
<p>初看到此题目， 因为要让每次走下来的路径和最大， 读者可能最初想到的思路是让每一次的路径都是最优的， 即不顾全局， 只看局部， 让第一次和第二次的路径都是最优。 但问题马上来了， 虽然局部最优， 但是全局却不一定是最优。</p>
<p>上面的题目其实就是我们说的格子取数问题；</p>
<p>DP解法：</p>
<ol>
<li><p>设计态： f(i, j, h, k);// 表示两条路同时走， 第一条路径走到（i, j）时， 第二条路走到(h, k)时的最大数字和；</p>
</li>
<li><p>初始状态： f(0, 0, 0, 0)=0; 最终状态： f(n, n, n, n);</p>
</li>
<li><p>状态转移方程： 当i==h &amp;&amp; j==k 时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j);</p>
<p>当两者不相同时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j)+ Arr(h, k);</p>
</li>
</ol>
<p>但是其实这里我们可以直接化解成三维的问题， 因为上面我们肯定满足 i+j==h+k, 所以我们可以直接步数+ 第一个人目前行数+ 第二个人目前行数进行解决。</p>
<h3 id="OfferUp-Sumologic-Quantcast-公司投递"><a href="#OfferUp-Sumologic-Quantcast-公司投递" class="headerlink" title="OfferUp. Sumologic, Quantcast 公司投递"></a>OfferUp. Sumologic, Quantcast 公司投递</h3><h3 id="K-Sorted-Array"><a href="#K-Sorted-Array" class="headerlink" title="K Sorted Array"></a>K Sorted Array</h3><p><a href="https://practice.geeksforgeeks.org/problems/k-sorted-array/0" target="_blank" rel="noopener">Link</a></p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>we can use Insertion Sort to sort the elements efficiently. Following is the code for standard Insertion Sort.</p>
<pre><code>void insertionSort(int A[], int size){
  int i, key, j;
  for(i=1; i&lt;size; i++){
    key= A[i];
    j= i-1;
    /**Move elements of A[0...i-1], that are greater than position ahead of their current position. This loop will run at most k times**/
    while(j&gt;=0 &amp;&amp; A[j]&gt; key){
      A[j+1]= A[j];
      j= j-1;
    }
    A[j+1]= key;
  }
}
</code></pre><p>The inner loop will run at most k times. To move every element to its correct place, at most k elements need to be moved, so over all complexity will be O(nk).</p>
<h4 id="Solution2-maintain-a-k-1-size-priorityQueue"><a href="#Solution2-maintain-a-k-1-size-priorityQueue" class="headerlink" title="Solution2: maintain a (k+1) size priorityQueue"></a>Solution2: maintain a (k+1) size priorityQueue</h4><h3 id="Is-this-a-tree"><a href="#Is-this-a-tree" class="headerlink" title="Is this a tree?"></a>Is this a tree?</h3><p>You are given a binary tree as a sequence of parent-child pairs. For example, the tree represented by the node pairs below:</p>
<p>(A, B) (A, C) (B, G) (C, H) (E, F) (B, D) (C, E)</p>
<p>…</p>
<p>This tree can be represented in a S-expression in multiple ways. The lexicographically smallest way of expressing this as follows:</p>
<p>(A(B(D)(G))(C(E(F))(H)))</p>
<p>We need to translate the node-pair representation into an S-expression(lexicographically smallest one), and report any errors that do not conform to the definition of a binary tree.</p>
<p>The list of errors with their codes is as follows:</p>
<ul>
<li>E1: More than 2 children</li>
<li>E2： Duplicate Edges</li>
<li>E3: Cycle present</li>
<li>E4: Multiple roots</li>
<li>E5: Any other error</li>
</ul>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuanRVVDd1aWhLZzQ/view" target="_blank" rel="noopener">link_1</a></p>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuOHVSMF9qMW5IZkk/view" target="_blank" rel="noopener">link_2</a></p>
<p>见下面的validTree我们已经对普通tree的方法进行了解决。</p>
<h3 id="Leetcode-261-Valid-Tree"><a href="#Leetcode-261-Valid-Tree" class="headerlink" title="Leetcode 261. Valid Tree"></a>Leetcode 261. Valid Tree</h3><p>三种做法各做一遍。</p>
<p>见 外部博文， 在graph中如何检测是否有圈存在。</p>
<h3 id="Binary-Search-找距离最近的数字。"><a href="#Binary-Search-找距离最近的数字。" class="headerlink" title="Binary Search 找距离最近的数字。"></a>Binary Search 找距离最近的数字。</h3><p>经典的题目；</p>
<pre><code>public class BinarySearch {
    static int[] nums= new int[]{1,2,3,4,5,8,12};
    public static int getMinDiff(int target){
        int lo= 0;
        int hi= nums.length-1;
        while(lo&lt;= hi){
            int mid= lo+(hi-lo)/2;
            if(target&lt;=nums[mid]){
                hi= mid-1;
            }else {
                lo = mid + 1;
            }
        }
        return lo;// the number before lo is smaller than target;
    }
    public static void main(String[] args){
        int target=10;
        int idx= getMinDiff(target);
        if(idx==0){
            System.out.println(Math.abs(nums[idx]-target));
        }
        System.out.println(Math.min(Math.abs(nums[idx]-target), Math.abs(nums[idx-1]-target)));
    }
}
</code></pre><h3 id="flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；"><a href="#flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；" class="headerlink" title="flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；"></a>flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；</h3><p>所以如果shallow的话，我们在碰到第一层的时候直接将该层里面的元素输出就好了， 这个时候就能够不用递归或者stack进行解决， 如果是要将所有的都进行flatten的话：</p>
<ol>
<li>递归</li>
<li>Stack， 从后往前进行存储</li>
</ol>
<p>可以借助instance of 来判断遇到的Object 是 Integer or List。</p>
<p>相关问题：</p>
<h4 id="leetcode-341-Flatten-Nested-List-Iterator"><a href="#leetcode-341-Flatten-Nested-List-Iterator" class="headerlink" title="leetcode 341. Flatten Nested List Iterator"></a>leetcode 341. Flatten Nested List Iterator</h4><p>这道题直接利用一个辅助的结构去进行存储就好了， 这里我们选用stack， 每次查看stack最上面的一个元素去进行取next；</p>
<h4 id="leetcode-251-Flatten-2D-vector"><a href="#leetcode-251-Flatten-2D-vector" class="headerlink" title="leetcode 251 Flatten 2D vector"></a>leetcode 251 Flatten 2D vector</h4><p>对于251 这里我们来一个比较具有启发性的答案：</p>
<p>Q:</p>
<p>Implement an iterator to flatten a 2d vector.</p>
<p>For example, Given 2d vector=[[1,2], [3], [4,5,6]];</p>
<p>By calling next repeatedly until hasNext returns false. the order of elements returned by next should be [1,2,3,4,5,6];</p>
<p>Follow up:</p>
<p>As an added challenge, try to code it using only iterators in Java</p>
<p>Code:</p>
<pre><code>public class Vector2D implements Iterator&lt;Integer&gt;{
  Iterator&lt;List&lt;Integer&gt;&gt; itrs;
  Iterator&lt;Integer&gt; row;
  public Vector 2D(List&lt;List&lt;Integer&gt;&gt; vec2d){
    if(vec2d==null || vec2d.size()==0) return;
    itrs= vec2d.iterator();
    row= itrs.next().iterator();
    getNextRow();
  }
  private void getNextRow(){
    while(!row.hasNext() &amp;&amp; itrs.hasNext()) row= itrs.next().iterator();
  }
  @ Override
  public Integer next(){
    int next= row.next();
    getNextRow();
    return next;
  }
  @ Override
  public boolean hasNext(){
    return row!=null&amp;&amp; row.hasNext();
  }
}
</code></pre><pre><code>public class NestedIterator implements Iterator&lt;Integer&gt; {
    Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();
    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {
        System.out.println(flatten_recurrsive(nestedList));
        for(int i = nestedList.size() - 1; i &gt;= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }
    public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList){
        Stack&lt;NestedInteger&gt; newStack= new Stack&lt;&gt;();
        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
        for(int i= nestedList.size()-1; i&gt;=0; i--){
            newStack.push(nestedList.get(i));
        }
        while(!newStack.isEmpty()){
            if(newStack.peek().isInteger()){
                res.add(newStack.pop().getInteger());
                continue;
            }
            List&lt;NestedInteger&gt; curr=newStack.pop().getList();
            for(int i=curr.size()-1; i&gt;=0; i--){
                newStack.push(curr.get(i));
            }
        }
        return res;
    }
    public List&lt;Integer&gt; flatten_recurrsive(List&lt;NestedInteger&gt; nestedList){
        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
        for(NestedInteger e: nestedList){
            if(e.isInteger()){
                res.add(e.getInteger());
            }else{
                res.addAll(flatten_recurrsive(e.getList()));
            }
        }
        return res;
    }
    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while(!stack.isEmpty()) {
            NestedInteger curr = stack.peek();
            if(curr.isInteger()) {
                return true;
            }
            stack.pop();
            for(int i = curr.getList().size() - 1; i &gt;= 0; i--) {
                stack.push(curr.getList().get(i));
            }
        }
        return false;
    }
}
</code></pre><h4 id="Leetcode-385-Mini-Parser"><a href="#Leetcode-385-Mini-Parser" class="headerlink" title="Leetcode 385. Mini Parser"></a>Leetcode 385. Mini Parser</h4><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list– whose elements may also be integers or other lists.</p>
<p>很愚蠢并且很容易错的一道题目：</p>
<p>自己写的代码：</p>
<pre><code>class Solution {
    public NestedInteger deserialize(String s) {
        // categorized with [  and without [
        if(s.charAt(0)!=&#39;[&#39;){
            return new NestedInteger(Integer.valueOf(s));
        }
        //s= s.substring(1, s.length()-1);
        NestedInteger res= new NestedInteger();
        int index=1;
        while(index&lt;s.length()-1){
            char ch= s.charAt(index);
            if(ch==&#39;[&#39;){
                int count=0;
                int start= index;
                while(index&lt;s.length()-1){
                    if(s.charAt(index)==&#39;[&#39;) count++;
                    if(s.charAt(index)==&#39;]&#39;) count--;
                    index++;
                    if(count==0){
                        res.add(deserialize(s.substring(start, index)));
                        break;
                    }
                }
            }else if(Character.isDigit(ch) || ch==&#39;-&#39;){
                int sign=1;
                if(ch==&#39;-&#39;){
                    sign=-1;
                    index++;
                }
                StringBuilder sb= new StringBuilder();
                while(index&lt;s.length()-1 &amp;&amp; Character.isDigit(s.charAt(index))){
                    sb.append(s.charAt(index));
                    index++;
                }
                res.add(new NestedInteger(Integer.valueOf(sb.toString())*(sign)));
            }else if(ch==&#39;,&#39;){
                index++;
            }
        }
        return res;
    }
}
</code></pre><p>别人的想法：</p>
<ol>
<li>If encounters ‘[‘, push current NestedInteger to stack and start a new one.</li>
<li>If encounters ‘]’, end current NestedInteger and pop a NestedInteger from stack to continue;</li>
<li>If encounters ‘,’, append a new number to curr NestedInteger, if this comma is not right after a brackets.</li>
<li>Update index l and r, where I shall point to the start of a integer substring, while r shall points to the end+1 of substring;</li>
</ol>
<pre><code>class Solution {
    public NestedInteger deserialize(String s) {
        if(s.isEmpty()) return null;
        if(s.charAt(0)!=&#39;[&#39;) return new NestedInteger(Integer.valueOf(s));
        Stack&lt;NestedInteger&gt; stack= new Stack&lt;&gt;();
        NestedInteger curr= null;
        int l=0;
        for(int r=0; r&lt;s.length(); r++){
            char ch= s.charAt(r);
            if(ch==&#39;[&#39;){
                if(curr!= null){
                    stack.push(curr);
                }
                curr= new NestedInteger();
                l= r+1;
            }else if(ch==&#39;]&#39;){
                String num= s.substring(l, r);
                if(!num.isEmpty()) curr.add(new NestedInteger(Integer.valueOf(num)));
                if(!stack.isEmpty()){
                    NestedInteger pop= stack.pop();
                    pop.add(curr);
                    curr= pop;
                }
                l= r+1;
            }else if(ch==&#39;,&#39;){
                if(s.charAt(r-1)!= &#39;]&#39;){
                    String num= s.substring(l, r);
                    curr.add(new NestedInteger(Integer.valueOf(num)));
                }
                l= r+1;
            }
        }
        return curr;
    }
}
</code></pre><h3 id="Find-the-intersection-of-two-lists"><a href="#Find-the-intersection-of-two-lists" class="headerlink" title="Find the intersection of two lists"></a>Find the intersection of two lists</h3><p>这道题目有两种做法， 第一种找到各条链的长度， 然后使用快慢指针。这里主要是第二种做法：</p>
<pre><code>public ListNode getIntersectionNode(ListNode headA, ListNode headB){
    ListNode nodeA= headA;
    ListNode nodeB= headB;
    while(nodeA!= nodeB){
        nodeA= (nodeA==null)?headB: nodeA.next;
        nodeB= (nodeB==null)?headA: nodeB.next;
    }
    return nodeA;
}
</code></pre><p>这里主要要注意的一点就是对于null的处理， 如果两者不相交的话，会出现什么情况， 所以这里我们让nodeA和nodeB再取一次null来消除这种情况， 也就是说nodeA==null 的时候， 我们再进行第二次遍历。</p>
<h3 id="Abstract-class-interface-and-threading-issues"><a href="#Abstract-class-interface-and-threading-issues" class="headerlink" title="Abstract class, interface and threading issues."></a>Abstract class, interface and threading issues.</h3><p>concurrent issues.</p>
<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><h3 id="More-about-drawbridge"><a href="#More-about-drawbridge" class="headerlink" title="More about drawbridge"></a>More about drawbridge</h3><p>1st round phone interview: write a function that finds substrings that contains only consecutive repeating characters and return a list of characters that form the substrings. For example, input “thiisiissaa”, returns i i s a, input “thiiissisa” returns i, input “abcde” returns a b c d e.<br>There were three rounds of interview in the 2-hour skype interview that followed the initial phone interview. 1st round, given an unsorted array of integers, sort the array such that the numbers in it form the largest possible number, for example, given [3, 30, 9, 14, 1], the array should be sorted into [9, 3, 30, 14, 1] because 9330141 is the largest number you can form from the numbers in the array. 2nd round, implement a queue using an array. 3rd round, given a list of cities, each city has a population value, write a function that returns a city in the input list. The probability of returning a specific city should be proportional to the population of the city. For example, if the list contains city1 with 15 pop value and city2 with 5 pop value, then if you call the function 4 times, on average it should return city1 for 3 times and city2 once.</p>
<h3 id="Knight’s-travel"><a href="#Knight’s-travel" class="headerlink" title="Knight’s travel"></a>Knight’s travel</h3><h3 id="Leetcode-Frog-Jump"><a href="#Leetcode-Frog-Jump" class="headerlink" title="Leetcode Frog Jump"></a>Leetcode Frog Jump</h3><p>比较straightforward的做法：</p>
<p>利用map记录每个stone上面能跳的jump；</p>
<p>DFS-Version</p>
<pre><code>class Solution {
    public boolean canCross(int[] stones) {
        if (stones.length == 0) return false;
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 1; i &lt; stones.length; i++) {
            if (stones[i] - stones[i - 1] &gt; i) {
                return false;
            }
            set.add(stones[i]);
        }
        return helper(set, 0, 0, stones[stones.length - 1]);
    }

    private boolean helper(Set&lt;Integer&gt; set, int step, int currStone, int lastStone) {
        if (currStone == lastStone) return true;
        for (int i = step + 1; i &gt;= Math.max(1, step - 1); i--) {
            if (set.contains(currStone + i) &amp;&amp; helper(set, i, currStone + i, lastStone))
                return true;
        }
        return false;
    }
}
</code></pre><p>Map-Version</p>
<pre><code>class Solution {
    public boolean canCross(int[] stones) {
        Map&lt;Integer, Set&lt;Integer&gt;&gt; map= new HashMap&lt;&gt;();
        map.put(0, new HashSet&lt;Integer&gt;());
        map.get(0).add(1);
        for(int i=0; i&lt;stones.length; i++){
            if(map.containsKey(stones[i])){
                for(int step: map.get(stones[i])){
                    int next= step+ stones[i];
                    if(next== stones[stones.length-1]) return true;
                    if(!map.containsKey(next)){
                        map.put(next, new HashSet&lt;Integer&gt;());
                    }
                    map.get(next).add(step+1);
                    if(step-1&gt;0) map.get(next).add(step-1);
                    map.get(next).add(step);
                }
            }
        }
        return false;
    }
}
</code></pre><h3 id="Jump-Game-I-amp-amp-II"><a href="#Jump-Game-I-amp-amp-II" class="headerlink" title="Jump Game I &amp;&amp; II"></a>Jump Game I &amp;&amp; II</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>Solution:</p>
<p>这道题我们可以用bfs去解决， 每一次跳相当于从上一层跳到下一层， 每次我们遍历完上一层， 下一层的currentMax也就确定了， 直到遍历到尽头， 得到层数， 就是我们要的答案。</p>
<pre><code>public int jump(int[] nums) {
    if(nums.length==0 || nums.length==1) return 0;
    int currentMax=0;
    int nextMax=0;
    int index=0;
    int level=0;
    while(index&lt;=currentMax){//  traversal the current 
        level++;
        while(index&lt;= currentMax){
            nextMax= Math.max(nextMax, index+ nums[index]);
            index++;
        }
        currentMax=nextMax;
        if(currentMax&gt;=nums.length-1) break;
    }
    return level;
}
</code></pre><p>或者：</p>
<pre><code>public int jump(int[] A){
    // 每次到上一层的尽头， 下一层的尽头也就确定了： e: previous Max, max: current Max;
    int sc=0;
    int e=0;
    int max=0;
    for(int i=0; i&lt;A.length-1; i++){
        max= Math.max(max, i+ A[i]);
        if(i==e){
            sc++;
            e= max;
        }
    }
    return sc;
}
</code></pre><p>follow-up: how to find the path</p>
<p>解决路径问题的话， 大概就是找到每一层能跳到max的就好了， 找到这样的元素， 我们也就找到了一条路径， 实际上这样的路径应该有很多条（每一层的元素数量相乘）。</p>
<h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a>Verify Preorder Serialization of a Binary Tree</h3><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree.</p>
<pre><code>class Solution {
    public boolean isValidSerialization(String preorder) {
        String[] nodes= preorder.split(&quot;,&quot;);
        Stack&lt;String&gt; stack= new Stack&lt;&gt;();
        for(String node: nodes){
            while(!stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;) &amp;&amp; node.equals(&quot;#&quot;)){
                stack.pop();
                if(stack.isEmpty()) return false;
                stack.pop();
            }
            stack.push(node);
        }
        return stack.size()==1 &amp;&amp; stack.peek().equals(&quot;#&quot;);
    }
}
</code></pre><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h3 id="Check-whether-a-given-array-is-a-k-sorted-array-or-not"><a href="#Check-whether-a-given-array-is-a-k-sorted-array-or-not" class="headerlink" title="Check whether a given array is a k sorted array or not."></a>Check whether a given array is a k sorted array or not.</h3><p>Given an array of n distinct elements, Check whether the given array is a k sorted array or not. A k sorted array is an array where each element is at most k distance away from its target position in the sorted array;</p>
<p>For example, let us consider k is 2, an element at index 7 in the sorted array, can be indexes 5, 6, 7, 8,9 in the given array;</p>
<p>这道题目的做法很straight forward， 我们可以直接排序， 然后寻找原来的顺序就好了， 我们着重要讲的是是下面这个问题：</p>
<p>如何在O(n logk)时间内将k sorted array进行排序。</p>
<p>We can sort such arrays more efficiently with the help of Heap data structure.</p>
<ol>
<li>Create a Min Heap of size k+1 with first k+1 elements. This will take O(k) time;</li>
<li>One by one remove min element from heap, put it in the result array, and add a new element to heap from remaining elements.</li>
</ol>
<p>Basically we keep a window of k+1 elements in a minHeap as any element is at most k distance away from the target position. So if an element is the smallest of the group then we extract the element for the window.</p>
<p>The fact： smallest element(first element of sorted out o/p) will always be in first K+1 elements as it can only move k places away from its original position and of course it will be the root element of minheap.</p>
<h3 id="如何计算数据的方差"><a href="#如何计算数据的方差" class="headerlink" title="如何计算数据的方差"></a>如何计算数据的方差</h3><p>有variable A, B, 问A和B的方差是否等于Var(A)+Var(B)<br>如果A, B是独立的就相等，要不不相等</p>
<h3 id="很多数，-找到k个最大的数，-stream操作。"><a href="#很多数，-找到k个最大的数，-stream操作。" class="headerlink" title="很多数， 找到k个最大的数， stream操作。"></a>很多数， 找到k个最大的数， stream操作。</h3><h3 id="很大个文本如何应用mapreduce，-找到anagram"><a href="#很大个文本如何应用mapreduce，-找到anagram" class="headerlink" title="很大个文本如何应用mapreduce， 找到anagram"></a>很大个文本如何应用mapreduce， 找到anagram</h3><h3 id="mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。"><a href="#mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。" class="headerlink" title="mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。"></a>mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。</h3><p>Maybe the data is skew.</p>
<p>reduce执行很慢的一个原因是数据分桶不均导致个别reduce节点的数据量远大于其他节点。 解决方案是检查分桶是否混匀， 如果不均匀考虑使用自定义的Partitioner(使用IntHashPartitioner/MapintPartitioner) 可以根据int前缀/后缀决定分到哪个桶， 如果均匀考虑单个reduce的数据里是否过大， 如果单个reduce的数据量过大则应该考虑增加reduce的量。</p>
<p>哪个key到哪个Reducer的分配过程， 是由Partitioner规定的， 它只有一个办法， 输入的是Map的结果对和reducer的数目， 输出则是分配的Reducer。 就是指定Mapper输出的键值对到哪一个reducer上去， 这样保证如果由相同的key值， 肯定被分配到同一个reducer上。 如果有N个reducer， 编号就是0，1，2，3…(N-1)</p>
<h3 id="public-static-void-main-String-args-为啥要用static。"><a href="#public-static-void-main-String-args-为啥要用static。" class="headerlink" title="public static void main (String[] args) 为啥要用static。"></a>public static void main (String[] args) 为啥要用static。</h3><p>正因为main 方法是静态的， JVM调用这个方法就不需要创建任何包含这个main方法的实例。如果JVM就没法确定调用哪个main方法。</p>
<p>静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的， 那么它就会被加载到JVM上下文成为可执行的方法。</p>
<p>如果JVM找不到main方法就会抛出 NoSuchMethodError：main异常。</p>
<p>main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</p>
<h3 id="如果不用static-是否能够通过？"><a href="#如果不用static-是否能够通过？" class="headerlink" title="如果不用static 是否能够通过？"></a>如果不用static 是否能够通过？</h3><p>编译能过， 但是不能运行。</p>
<h3 id="最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。"><a href="#最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。" class="headerlink" title="最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。"></a>最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。</h3><pre><code>class Solution {
    public int lengthOfLIS(int[] nums) {
        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();
        for(int i=0; i&lt;nums.length; i++){
            int idx= binarySearch(list, nums[i]);
            if(idx&lt;list.size()){
                list.set(idx, nums[i]);
            }else{
                list.add(nums[i]);
            }
        }
        return list.size();
    }
    public int binarySearch(List&lt;Integer&gt; nums, int target){
        int lo= 0;
        int hi= nums.size()-1;
        while(lo&lt;=hi){
            int mid=(lo+hi)/2;
            if(nums.get(mid)&lt;target){
                lo= mid+1;
            }else{
                hi= mid-1;
            }
        }
        return lo;
    }
}
</code></pre><h3 id="Java-heap和stack都分别存什么"><a href="#Java-heap和stack都分别存什么" class="headerlink" title="Java heap和stack都分别存什么"></a>Java heap和stack都分别存什么</h3><p><a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java Heap Space vs Stack- Memory Allocation in Java</a></p>
<h4 id="Java-Heap-Space"><a href="#Java-Heap-Space" class="headerlink" title="Java Heap Space"></a>Java Heap Space</h4><ol>
<li>Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.</li>
<li>Garbage Collection runs on the heap memory to free the memory used by objects that doesn’t have any reference. Any object created in the heap has global access and can be referenced from anywhere of the application.</li>
</ol>
<h4 id="Java-Stack-Memory"><a href="#Java-Stack-Memory" class="headerlink" title="Java Stack Memory"></a>Java Stack Memory</h4><ol>
<li>Java Stack memory is used for execution of a thread. They contain method specific values that are short lived and references to other objects in the heap that are getting referred from the method.</li>
<li>Stack memory is always referenced in LIFO order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.</li>
<li>As soon as method ends, the block becomes unused and become available for next method.</li>
<li>Stack memory size is very less compared to Heap memory.</li>
</ol>
<pre><code>package com.journaldev.test;

public class Memory {

    public static void main(String[] args) { // Line 1
        int i=1; // Line 2
        Object obj = new Object(); // Line 3
        Memory mem = new Memory(); // Line 4
        mem.foo(obj); // Line 5
    } // Line 9

    private void foo(Object param) { // Line 6
        String str = param.toString(); //// Line 7
        System.out.println(str);
    } // Line 8

}
</code></pre><p>Below image shows the stack and heap memory with reference to above program and how they are being used to store primitive, Objects and reference variables.</p>
<p><a href="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png"><img src="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png" alt="img"></a></p>
<p>Let’s go through the steps of execution of the program.</p>
<ul>
<li>As soon as we run the program, it loads all the Runtime classes into the Heap space. When main() method is found at line 1, Java Runtime creates stack memory to be used by main() method thread.</li>
<li>We are creating primitive local variable at line 2, so it’s created and stored in the stack memory of main() method.</li>
<li>Since we are creating an Object in line 3, it’s created in Heap memory and stack memory contains the reference for it. Similar process occurs when we create Memory object in line 4.</li>
<li>Now when we call foo() method in line 5, a block in the top of the stack is created to be used by foo() method. Since Java is pass by value, a new reference to Object is created in the foo() stack block in line 6.</li>
<li>A string is created in line 7, it goes in the <a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">String Pool</a> in the heap space and a reference is created in the foo() stack space for it.</li>
<li>foo() method is terminated in line 8, at this time memory block allocated for foo() in stack becomes free.</li>
<li>In line 9, main() method terminates and the stack memory created for main() method is destroyed. Also the program ends at this line, hence Java Runtime frees all the memory and end the execution of the program.</li>
</ul>
<h3 id="Difference-between-Java-Heap-Space-and-Stack-Memory"><a href="#Difference-between-Java-Heap-Space-and-Stack-Memory" class="headerlink" title="Difference between Java Heap Space and Stack Memory"></a>Difference between Java Heap Space and Stack Memory</h3><p>Based on the above explanations, we can easily conclude following differences between Heap and Stack memory.</p>
<ol>
<li>Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.</li>
<li>Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.</li>
<li>Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.</li>
<li>Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at <a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">Java Garbage Collection</a>.</li>
<li>Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.</li>
<li>We can use <strong>-Xms</strong> and <strong>-Xmx</strong> JVM option to define the startup size and maximum size of heap memory. We can use <strong>-Xss</strong> to define the stack memory size.</li>
<li>When stack memory is full, Java runtime throws <code>java.lang.StackOverFlowError</code> whereas if heap memory is full, it throws <code>java.lang.OutOfMemoryError: Java Heap Space</code> error.</li>
<li>Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.</li>
</ol>
<p>That’s all for <strong>Java Heap Space vs Stack Memory</strong> in terms of java application, I hope it will clear your doubts regarding memory allocation when any java program is executed.</p>
<p>Static methods(in fact all methods) as well as static variables are stored in the PermGen section of the heap, since they are part of the reflection data(class related data, not instance related).</p>
<p>Note that only the variables and their technical values(primitives and references) are stored in PermGen space.</p>
<p>If your static variable is a reference to an object that object itself is stored in the normal sections of the heap. Those objects(unless they are internal objects like classes etc.) are not stored in PermGen space.</p>
<h3 id="SQL有几种join，-join的内部实现，-sql-index内部实现。"><a href="#SQL有几种join，-join的内部实现，-sql-index内部实现。" class="headerlink" title="SQL有几种join， join的内部实现， sql index内部实现。"></a>SQL有几种join， join的内部实现， sql index内部实现。</h3><p>SQL有inner join， left join， right join, full outer join 各种join</p>
<p>Or natural join and theta join;</p>
<p>总的来说， 四种JOIN的使用/区别可以描述为：</p>
<ol>
<li>left join 会从左表那里返回所有的记录， 即使在右表中没有匹配的行。</li>
<li>right outer join右连接， 返回右表中的所有记录， 即使在做表中没有记录与它匹配。</li>
<li>full outer join 全连接， 返回左右表中的所有记录。</li>
<li>在表中存在至少一个匹配时， inner join返回行。 关键字inner 可省略。</li>
</ol>
<p>join 的内部实现(重要的技巧: external sort)：</p>
<ol>
<li><p>Three primary techniques:</p>
<p>Sorting， Hashing， Indexing；</p>
</li>
<li><p>Three degrees of difficulty:</p>
<p>data small enough to fit in memory</p>
<p>too large to fit in main memory but small enough to be handled by a two-pass algorithm</p>
</li>
</ol>
<p>Iteration Join: conceptually- without taking into account disk block issues.</p>
<p>Merge join: Sort the two table and using merge sort;</p>
<p>Join with index: Using index;</p>
<p>Hash join: hash R1 tuples into G buckets, hash R2 tuples into H buckets and match every bucket;</p>
<h3 id="What’s-the-difference-between-B-Tree-and-B-Tree"><a href="#What’s-the-difference-between-B-Tree-and-B-Tree" class="headerlink" title="What’s the difference between B Tree and B+ Tree."></a>What’s the difference between B Tree and B+ Tree.</h3><p>In a b- tree you can store both keys and data in the internal and leaf nodes, but in a b+ tree you have to store the data in the leaf nodes only;</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys(not pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<p>Advantages of B+ trees:</p>
<ul>
<li>Because B+ tree don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.</li>
<li>The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.</li>
</ul>
<p>Advantage of B trees:</p>
<ul>
<li>Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.</li>
</ul>
<p><a href="https://i.stack.imgur.com/l6UyF.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/l6UyF.png" alt="B and B+ tree"></a></p>
<p>The principal advantage of B+ trees over B trees is they allow you to pack in more pointers to other nodes by removing pointers to data, thus increasing the fanout and potentially decreasing the depth of the tree.The disadvantage is that there are no early outs when you might have found a match in an internal node. But since both data structures have huge fanouts, the vast majority of your matches will be on leaf nodes anyway, making on average the B+ tree more efficient.</p>
<h3 id="Overfitting-如何处理"><a href="#Overfitting-如何处理" class="headerlink" title="Overfitting 如何处理"></a>Overfitting 如何处理</h3><p>Overfitting is that your model get good result on your training data, but can not generalize to the usual data set.</p>
<p>过度拟合的模型往往不能进行一般化推广。</p>
<ol>
<li>Cross Validation</li>
<li>Train with more data</li>
<li>Remove features.</li>
<li>Early Stopping</li>
<li>Regularization</li>
</ol>
<h3 id="count-min-sketch-数据结构"><a href="#count-min-sketch-数据结构" class="headerlink" title="count-min-sketch 数据结构"></a>count-min-sketch 数据结构</h3><p>Ref: 系统设计</p>
<p>主要的意思就是使用 bloom fliter来记录每个元素出现的频率， 然后以频率来代替次数。</p>
<h3 id="A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。"><a href="#A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。" class="headerlink" title="A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。"></a>A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。</h3><p>一个auction无限轮，A，B，C参加bid，一个operator宣布结果，赢者付其他竞价中的最高值（即第二高bid），但是operator可以作假报高价，BC want to get high profit, 给出A可以用什么策略发现A作假</p>
<h3 id="cc-150上-4-8-subtree那道题"><a href="#cc-150上-4-8-subtree那道题" class="headerlink" title="cc 150上 4.8 subtree那道题"></a>cc 150上 4.8 subtree那道题</h3><p>You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to that value. note that it can be any path in the tree– it does not have to start at the root.</p>
<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>Lets’s approach this problem by simplifying it. What if the path had to start at the root?</p>
<p>对于这道题， 其实我们可以采用 leetcode 437的做法。</p>
<pre><code>class Solution {
    int res=0;
    public int pathSum(TreeNode root, int sum) {
        if(root==null) return 0;
        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();
        map.put(0, 1);
        backTrack(root, sum, map, 0);
        return res;
    }
    public void backTrack(TreeNode root, int target, Map&lt;Integer, Integer&gt; map, int sum){
        if(root==null) return;
        sum+=root.val;
        if(map.containsKey(sum-target)){
            res+=map.get(sum-target);
        }
        map.put(sum, map.getOrDefault(sum, 0)+1);
        backTrack(root.left, target, map, sum);
        backTrack(root.right, target, map, sum);
        map.put(sum, map.get(sum)-1);
    }
}
</code></pre><pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
        findSum(root, sum, new ArrayList&lt;&gt;(), 0);
        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();
        pathSum(root, sum, res);
        return res;
    }
    public void pathSum(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res){
        if(root==null) return;
        findPath(root, sum,0, new ArrayList&lt;&gt;(), res);
        pathSum(root.left, sum, res);
        pathSum(root.right, sum, res);
    }
    // if the path was not restricted to the from root to leaf;
    public void findPath(TreeNode root, int target, int sum,  List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res){
        if(root==null) return;
        sum+=root.val;
        path.add(root.val);
        if(sum== target){
            res.add(new ArrayList&lt;&gt;(path));
        }
        findPath(root.left, target, sum, path, res);
        findPath(root.right, target, sum, path, res);
        path.remove(path.size()-1);
    }
    // what if we just want to print the path;
    public void findSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; unit, int level){
        if(root==null) return;
        int tmp= sum;
        unit.add(root.val);
        for(int i=level; i&gt;-1; i--){
            tmp-= unit.get(i);
            if(tmp==0) print(unit, i, level);
        }
        findSum(root.left, sum, unit, level+1);
        findSum(root.right, sum, unit, level+1);
        unit.remove(unit.size()-1);
    }
    void print(ArrayList&lt;Integer&gt; buffer, int level, int i2){
        for(int i= level; i&lt;= i2; i++){
            System.out.print(buffer.get(i)+&quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><h3 id="Leetcode：-Largest-Number"><a href="#Leetcode：-Largest-Number" class="headerlink" title="Leetcode： Largest Number"></a>Leetcode： Largest Number</h3><p>这道题目只需要实现一个Comparator就可以了。</p>
<h3 id="SQL刷题。"><a href="#SQL刷题。" class="headerlink" title="SQL刷题。"></a>SQL刷题。</h3><h3 id="Move-zeros"><a href="#Move-zeros" class="headerlink" title="Move zeros"></a>Move zeros</h3><p>input: [0,2,0,-3,5,7,9,0,7,0]<br>output: [2,-3,5,7,9,7,0,0,0,0]</p>
<pre><code>class Solution {
    public void moveZeroes(int[] nums) {
        int start=0;
        int index=0;
        while(index&lt; nums.length){
            if(nums[index]!=0){
                swap(nums, index, start);
                start++;
            }
            index++;
        }
    }
    public void swap(int[] nums, int i, int j){
        int temp= nums[i];
        nums[i]= nums[j];
        nums[j]= temp;
    }

}
</code></pre><h3 id="From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones"><a href="#From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones" class="headerlink" title="From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones."></a>From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones.</h3><p>Test Input: [4, 8], [3, 5], [-1 2], [10, 12]</p>
<p>Test output: [-1, 8], [10,12]</p>
<p>Merge Intervals;</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>三个table, salesman， customer，orders</p>
<p>a. The names of all sales people that have an order with Panasung(one customer’s name).</p>
<p>b. The names of salespeople that have 2 or more orders.</p>
<p>Select salespeople.name from orders group by name having count(*)&gt;=2</p>
<h3 id="strstr变形"><a href="#strstr变形" class="headerlink" title="strstr变形"></a>strstr变形</h3><pre><code>public int strStr(String haystack, String needle){
  if(needle.length()==0) return 0;
  if(haystack.length()==0) reuturn -1;
  int index=0;
  while(index+needle.length()&lt;= haystack.length()){
    int i= index;
    int j=0;
    while(haystack.charAt(i)== needle.charAt(j)){
      i++;
      j++;
      if(j== needle.length()) return index;
    }
    index++;
  }
  return -1;
}
</code></pre><h3 id="merge-two-BST"><a href="#merge-two-BST" class="headerlink" title="merge two BST"></a>merge two BST</h3><h3 id="group-anagram"><a href="#group-anagram" class="headerlink" title="group anagram"></a>group anagram</h3><pre><code>class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();
        Map&lt;String, List&lt;String&gt;&gt; map= new HashMap&lt;&gt;();
        for(String str: strs){
            String s= hashStr(str);
            if(!map.containsKey(s)){
                map.put(s, new ArrayList&lt;&gt;());
            }
            map.get(s).add(str);
        }
        for(List&lt;String&gt; list: map.values()){
            res.add(list);
        }
        return res;
    }
    public String hashStr(String str){
        char[] ch=str.toCharArray();
        Arrays.sort(ch);
        StringBuilder sb= new StringBuilder();
        for(char c: ch){
            sb.append(c);
        }
        return sb.toString();
    }
}
</code></pre><h3 id="给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级"><a href="#给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级" class="headerlink" title="给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级"></a>给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级</h3><p>感觉可能要使用和之前质数一样的方式去进行计算。</p>
<p>Maybe we should use the inclusion-exclusion principle to calculate;</p>
<h3 id="two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？"><a href="#two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？" class="headerlink" title="two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？"></a>two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？</h3><ol>
<li>maybe we ignore some feature, since there may be some feature in A, and no such feature in B, and the model is based on the existence of feature.</li>
<li>Shuffle the dataset A and B. and check if it is still the case.</li>
</ol>
<h3 id="use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego"><a href="#use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego" class="headerlink" title="use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]"></a>use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]</h3><pre><code>public class subsetCheck {
    public static List&lt;String&gt; getList(Set&lt;String&gt; dict, String s){
        Map&lt;Character, Integer&gt; map= new HashMap&lt;&gt;();
        List&lt;String&gt; res= new ArrayList&lt;&gt;();
        for(int i=0; i&lt;s.length(); i++){
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)+1);
        }
        for(String word: dict){
            if(check(word, map)){
                res.add(word);
            }
        }
        return res;
    }
    public static boolean check(String s, Map&lt;Character, Integer&gt; map){
        boolean flag= true;
        for(int i=0; i&lt;s.length(); i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)-1);
            if(map.get(s.charAt(i))&lt;0) flag= false;
        }
        for(int i=0; i&lt;s.length(); i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)+1);
        }
        return flag;
    }
    public static void main(String[] args){
        HashSet&lt;String&gt; dict= new HashSet&lt;&gt;();
        dict.add(&quot;go&quot;);
        dict.add(&quot;ego&quot;);
        dict.add(&quot;gap&quot;);
        dict.add(&quot;dog&quot;);
        String word=&quot;ogeg&quot;;
        System.out.println(getList(dict, word));
    }
}
</code></pre><h3 id="hash-IP-address"><a href="#hash-IP-address" class="headerlink" title="hash IP address"></a>hash IP address</h3><p>input String=&gt; long int</p>
<p>String: 123.39.255.0</p>
<h3 id="Partition-Array"><a href="#Partition-Array" class="headerlink" title="Partition Array"></a>Partition Array</h3><pre><code>public class kthLargest {
    public static int findKthLargest(int[] nums, int k) {
        k= nums.length-k;
        int hi= nums.length-1;
        int lo= 0;
        while(lo&lt;=hi){
            int mid= partition(nums, lo, hi);
            if(mid&lt;k){
                lo= mid+1;
            }else if(mid==k) return nums[mid];
            else{
                hi= mid-1;
            }
        }
        return -1;
    }
    public static int partition(int[] nums, int lo, int hi){
        int i=lo;
        int j=hi+1;
        int key= nums[lo];
        while(true){
            while(i&lt;hi &amp;&amp; nums[++i]&lt;=key);
            while(j&gt;lo &amp;&amp; nums[--j] &gt;=key);
            if(i&gt;=j) break;
            swap(nums, i, j);
        }
        swap(nums, lo, j);
        return j;
    }
    public static void swap(int[] nums, int i, int j){
        int temp= nums[i];
        nums[i]= nums[j];
        nums[j]= temp;
    }
    public static void main(String[] args){
        int[] nums=new int[]{3,2,1,5,6,4};
        for(int i=1; i&lt;=nums.length; i++){
            System.out.println(findKthLargest(nums,i));
        }
    }
}
</code></pre><h3 id="Leetcode-721-Accounts-Merge"><a href="#Leetcode-721-Accounts-Merge" class="headerlink" title="Leetcode 721. Accounts Merge"></a>Leetcode 721. Accounts Merge</h3><p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code>is a <em>name</em>, and the rest of the elements are <em>emails</em> representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in any order.</p>
<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>这道题目比较骚， 我们可以把他转换成一道graph的题目。具体来说，题目相当于给定了一个group，然后我们需要把这些小的group来merge成一个比较大的group。</p>
<p>可以用union find 或者dfs来做。</p>
<pre><code>public List&lt;List&lt;String&gt;&gt; accountMerge(List&lt;List&lt;String&gt;&gt; acts){
  Map&lt;String, String&gt; root= new HashMap&lt;&gt;();
  Map&lt;String, String&gt; owner= new HashMap&lt;&gt;();
  Map&lt;String, TreeSet&lt;String&gt;&gt; components= new HashMap&lt;&gt;();
  // here is just initialization
  for(List&lt;String&gt; a: acts){
    for(int i=1; i&lt;a.size(); i++){
      root.put(a.get(i), a.get(i));
      owner.put(a.get(i), a.get(0));
    }
  }
  // here we just union all the node connected;
  for(List&lt;String&gt; a: acts){
    String root_p= find(a.get(1), root);
    for(int i=2; i&lt;a.size(); i++){
      root.put(find(a.get(i), root), root_p);
    }
  }
  // here we get the group of node;
  for(List&lt;String&gt; a: acts){
    String root_p= find(a.get(1), root);
    if(!components.containsKey(root_p)) components.put(root_p, new TreeSet&lt;&gt;());
    for(int i=1; i&lt;a.size(); i++){
        components.get(root_p).add(a.get(i));
    }
  }

  // find Res and return
  List&lt;List&lt;String&gt;&gt; res= new Arrayist&lt;&gt;();
  for(String key: components.keySet()){
    List&lt;String&gt; e= new ArrayList&lt;&gt;(components.get(key));
    e.add(0, owner.get(key));
    res.add(e);
  }
  return res;
}
private String find(String key, Map&lt;String, String&gt; root){
  while(key!= root.get(key)){
    root.put(key, root.get(key));
    key= root.get(key);
  }
  return key;
}
</code></pre><h3 id="海量数据如何去重"><a href="#海量数据如何去重" class="headerlink" title="海量数据如何去重"></a>海量数据如何去重</h3><p>Just using mapreduce to sort.</p>
<p>现在有2T的数据， 其中有重复， 我们需要去除这些重复的值， 内存只有1G， 我们应该怎么做？</p>
<ol>
<li>文件分块， 每次读入1G的文件， 将这些文件进行hash， 进行排序（Treeset）， 并进行初步的去重(Set的特殊性);</li>
<li>在完成第一步之后， 我们得到若干份有序的文件堆。在每个堆之中取第一个文件， 进行merge。</li>
</ol>
<p>剩下的就很好理解了。</p>
<p>有两种方式， 第一种就是上面说的：</p>
<ol>
<li>split and sort, then merge;</li>
<li>如果只需要去重， 不需要排序， 还有另外一种思路，对文件的每一行计算hash值， 按照hash值把该行内容放在某个小文件中， 假设需要分词100个文件， 则可以按照(hash%100)来分发文件内容， 然后再小文件中进行去重就可以了。</li>
</ol>
<h3 id="Find-K-th-Smallest-Pair-Distance"><a href="#Find-K-th-Smallest-Pair-Distance" class="headerlink" title="Find K-th Smallest Pair Distance"></a>Find K-th Smallest Pair Distance</h3><p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<p>Naive Method is to find all the n*(n-1)/2 possible absolute differences in O(n^2) and store them in an array. Then sort this array and print the kth minimum value from this array.</p>
<p>An Efficient Solution is based on Binary Search.</p>
<ul>
<li><p>Sort the given array a[].</p>
</li>
<li><p>We can easily find the least possible absolute difference in O(n) after sorting. The largest possible difference will be a[n-1]-a[0] after sorting the array. Let low= minimum_difference and high= maximum_difference.</p>
<pre><code>while low&lt; high:
    mid=(low+ high)/2;
    if((number of pairs with absolute difference&lt;=mid)&lt; k):
        low= mid+1
    else:
        high= mid
return low
</code></pre></li>
</ul>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/02/03/Node.js 学习笔记/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/02/03/Java面试问题/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Liyan Chen's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        liyanchen128@outlook.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="liyanchen128@outlook.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                Home
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    Archives
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/02/">February 2018<span class="sidebar_archives-count">13</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            Theme - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Lic128" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    
        <a href="https://www.linkedin.com/in/liyan-chen-015063127/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-linkedin">
                <span class="visuallyhidden">LinkedIn</span>
            </button><!--
     --></a>
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Sisyphus
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
