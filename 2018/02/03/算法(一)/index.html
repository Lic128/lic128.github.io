<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>算法(一) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LeetCode 146. LRU CacheDesign and implement a data structure for Lease Recently Used cache. It should support the following operations:get and put. get(key) - Get the value (will always be positive) o">
<meta name="keywords" content="Java, Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="算法(一)">
<meta property="og:url" content="http://yoursite.com/2018/02/03/算法(一)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="LeetCode 146. LRU CacheDesign and implement a data structure for Lease Recently Used cache. It should support the following operations:get and put. get(key) - Get the value (will always be positive) o">
<meta property="og:image" content="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png">
<meta property="og:image" content="https://i.stack.imgur.com/l6UyF.png">
<meta property="og:updated_time" content="2018-02-04T06:05:13.351Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法(一)">
<meta name="twitter:description" content="LeetCode 146. LRU CacheDesign and implement a data structure for Lease Recently Used cache. It should support the following operations:get and put. get(key) - Get the value (will always be positive) o">
<meta name="twitter:image" content="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-算法(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/算法(一)/" class="article-date">
  <time datetime="2018-02-04T05:54:11.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法(一)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="LeetCode-146-LRU-Cache"><a href="#LeetCode-146-LRU-Cache" class="headerlink" title="LeetCode 146. LRU Cache"></a>LeetCode 146. LRU Cache</h3><p>Design and implement a data structure for Lease Recently Used cache. It should support the following operations:<code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        int key;</span><br><span class="line">        int val;</span><br><span class="line">        public Node(int key, int val)&#123;</span><br><span class="line">            this.key= key;</span><br><span class="line">            this.val= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head=null;</span><br><span class="line">    Node tail=null;</span><br><span class="line">    public void removeTail()&#123;</span><br><span class="line">        Node node= tail.pre.pre;</span><br><span class="line">        node.next=tail;</span><br><span class="line">        tail.pre= node;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addToHead(Node node)&#123;</span><br><span class="line">        Node next= head.next;</span><br><span class="line">        next.pre= node;</span><br><span class="line">        node.next= next;</span><br><span class="line">        node.pre= head;</span><br><span class="line">        head.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    public void moveToHead(Node node)&#123;</span><br><span class="line">        Node next= node.next;</span><br><span class="line">        Node pre= node.pre;</span><br><span class="line">        pre.next= next;</span><br><span class="line">        next.pre=pre;</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    private Map&lt;Integer, Node&gt; map= new HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    private int capacity;</span><br><span class="line">    private int count;</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.capacity= capacity;</span><br><span class="line">        head=new Node(0, 0);</span><br><span class="line">        tail=new Node(0, 0);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre= head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if(!map.containsKey(key))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node node= map.get(key);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            return node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if(map.containsKey(key))&#123;</span><br><span class="line">            Node node= map.get(key);</span><br><span class="line">            node.val= value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node node= new Node(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            count++;</span><br><span class="line">            if(count&gt;capacity)&#123;</span><br><span class="line">                map.remove(tail.pre.key);</span><br><span class="line">                removeTail();</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-199-Evaluate-Division"><a href="#leetcode-199-Evaluate-Division" class="headerlink" title="leetcode 199. Evaluate Division"></a>leetcode 199. Evaluate Division</h3><p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p><strong>Example:</strong><br>Given <code>a / b = 2.0, b / c = 3.0.</code><br>queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code><br>return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector&lt;double&gt;</code>.</p>
<p>According to the example above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values = [2.0, 3.0],</span><br><span class="line">queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<h4 id="Solution-1-dumb-dfs"><a href="#Solution-1-dumb-dfs" class="headerlink" title="Solution 1: dumb dfs"></a>Solution 1: dumb dfs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; map= new HashMap&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, Double&gt; dict= new HashMap&lt;String, Double&gt;();</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p= equations[i][0];</span><br><span class="line">            String q= equations[i][1];</span><br><span class="line">            double val= values[i];</span><br><span class="line">            if(!map.containsKey(p)) map.put(p, new HashSet&lt;String&gt;());</span><br><span class="line">            if(!map.containsKey(q)) map.put(q, new HashSet&lt;String&gt;());</span><br><span class="line">            map.get(p).add(q);</span><br><span class="line">            map.get(q).add(p);</span><br><span class="line">            dict.put(p+&quot;/&quot;+q, val);</span><br><span class="line">            dict.put(q+&quot;/&quot;+p, 1/val);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        Set&lt;String&gt; visited;</span><br><span class="line">        for(int i=0; i&lt;queries.length; i++)&#123;</span><br><span class="line">            String p= queries[i][0];</span><br><span class="line">            String q= queries[i][1];</span><br><span class="line">            if(!map.containsKey(p) || !map.containsKey(q))&#123;</span><br><span class="line">                res[i]=-1.0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            visited= new HashSet&lt;String&gt;();</span><br><span class="line">            visited.add(p);</span><br><span class="line">            res[i]= isConnected(p, q, map, dict, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public double isConnected(String p, String q, Map&lt;String, Set&lt;String&gt;&gt; map, Map&lt;String, Double&gt; dict, Set&lt;String&gt; visited)&#123;</span><br><span class="line">        String equ= p+ &quot;/&quot;+q;</span><br><span class="line">        String rev_equ=q+&quot;/&quot;+p;</span><br><span class="line">        if(dict.containsKey(equ)) return dict.get(equ);</span><br><span class="line">        for(String next: map.get(p))&#123;</span><br><span class="line">            if(visited.contains(next)) continue;</span><br><span class="line">            visited.add(next);</span><br><span class="line">            double res= dict.get(p+&quot;/&quot;+ next);</span><br><span class="line">            double residual= isConnected(next, q, map, dict, visited);</span><br><span class="line">            if(residual==-1.0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dict.put(equ, res*residual);</span><br><span class="line">            dict.put(rev_equ, 1/(res*residual));</span><br><span class="line">            return res*residual;</span><br><span class="line">        &#125;</span><br><span class="line">        dict.put(equ, -1.0);</span><br><span class="line">        dict.put(rev_equ, -1.0);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-2-union-find-algorithm"><a href="#Solution-2-union-find-algorithm" class="headerlink" title="Solution 2: union-find algorithm"></a>Solution 2: union-find algorithm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">    Map&lt;String, String&gt; parent= new HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Double&gt; weight= new HashMap&lt;&gt;();// parent/son</span><br><span class="line">    // here we use weight to record the quotient between the root  and the child;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries)&#123;</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String[] eq= equations[i];</span><br><span class="line">            initialize(eq[0]);</span><br><span class="line">            initialize(eq[1]);</span><br><span class="line">            union(eq[0], eq[1], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        for(int i=0; i&lt;queries.length; i++)&#123;</span><br><span class="line">            res[i]= getProduct(queries[i][0], queries[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private void initialize(String a)&#123;</span><br><span class="line">        if(!parent.containsKey(a))&#123;</span><br><span class="line">            parent.put(a, a);</span><br><span class="line">            weight.put(a, 1d);// sufix d after number means double, sufix f means float;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void union(String a, String b, double quotient)&#123;</span><br><span class="line">        String aRoot= find(a);</span><br><span class="line">        String bRoot= find(b);</span><br><span class="line">        if(!aRoot.equals(bRoot))&#123;</span><br><span class="line">            parent.put(bRoot, aRoot);</span><br><span class="line">            weight.put(bRoot, quotient*weight.get(a)/weight.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private String find(String a)&#123;</span><br><span class="line">        if(parent.get(a).equals(a))&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        String oldRoot= parent.get(a);</span><br><span class="line">        String root= find(oldRoot);</span><br><span class="line">        if(!oldRoot.equals(root))&#123;</span><br><span class="line">            parent.put(a, root);</span><br><span class="line">            weight.put(a, weight.get(oldRoot)*weight.get(a));// here is important, we use the recursive thought to override the previous value of the record;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    private double getProduct(String a, String b)&#123;</span><br><span class="line">        if(!parent.containsKey(a) || !parent.containsKey(b))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        String aRoot= find(a);</span><br><span class="line">        String bRoot= find(b);</span><br><span class="line">        if(!aRoot.equals(bRoot))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return weight.get(b)/weight.get(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种方式的Union-find:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // Using union-find to solve the problem;</span><br><span class="line">    // or we can use bfs/dfs, which will take a lot time;</span><br><span class="line">    Map&lt;String, String&gt; id= new HashMap&lt;String, String&gt;();</span><br><span class="line">    Map&lt;String, Double&gt; dict=new HashMap&lt;String, Double&gt;();</span><br><span class="line">    public String find(String p)&#123;</span><br><span class="line">        while(!p.equals(id.get(p)))&#123;</span><br><span class="line">            p=id.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getValue(String p)&#123;</span><br><span class="line">        double res= 1.0;</span><br><span class="line">        while(!p.equals(id.get(p)))&#123;</span><br><span class="line">            double mult=dict.get(p+&quot;/&quot;+id.get(p));</span><br><span class="line">            res*=mult;</span><br><span class="line">            p=id.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public double cal(String p, String q)&#123;</span><br><span class="line">        if(!id.containsKey(p) || !id.containsKey(q)) return -1;</span><br><span class="line">        String p_root= find(p);</span><br><span class="line">        String q_root= find(q);</span><br><span class="line">        if(!p_root.equals(q_root)) return -1;</span><br><span class="line">        double p_res= getValue(p);</span><br><span class="line">        double q_res= getValue(q);</span><br><span class="line">        return p_res/q_res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(String p, String q, double value)&#123;</span><br><span class="line">        String p_root= find(p);</span><br><span class="line">        String q_root= find(q);</span><br><span class="line">        double p_val= getValue(p);</span><br><span class="line">        double q_val= getValue(q);</span><br><span class="line">        id.put(p_root, q_root);</span><br><span class="line">        dict.put(p_root+&quot;/&quot;+ q_root, value*q_val/p_val);</span><br><span class="line">        // when we union here, we also need to update the edges;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public double[] calcEquation(String[][] equations, double[] values, String[][] queries)&#123;</span><br><span class="line">        for(int i= 0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p= equations[i][0];</span><br><span class="line">            String q=equations[i][1];</span><br><span class="line">            double val= values[i];</span><br><span class="line">            id.put(p, p);</span><br><span class="line">            id.put(q, q);</span><br><span class="line">            dict.put(p+&quot;/&quot;+ q, val);</span><br><span class="line">            dict.put(q+&quot;/&quot;+ p, 1/val);</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(&quot;done!&quot;);</span><br><span class="line">        for(int i=0; i&lt;equations.length; i++)&#123;</span><br><span class="line">            String p=equations[i][0];</span><br><span class="line">            String q=equations[i][1];</span><br><span class="line">            union(p, q, values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(&quot;done!&quot;);</span><br><span class="line">        double[] res= new double[queries.length];</span><br><span class="line">        for(int i=0; i&lt;res.length; i++)&#123;</span><br><span class="line">            //System.out.println(queries[i][0]);</span><br><span class="line">            //System.out.println(queries[i][1]);</span><br><span class="line">            res[i]=cal(queries[i][0], queries[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-628-Maximum-Product-of-Three-Numbers"><a href="#Leetcode-628-Maximum-Product-of-Three-Numbers" class="headerlink" title="Leetcode 628. Maximum Product of Three Numbers"></a>Leetcode 628. Maximum Product of Three Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximumProduct(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res=0;</span><br><span class="line">        int first= nums[0]*nums[1]*nums[nums.length-1];</span><br><span class="line">        int last= nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3];</span><br><span class="line">        return Math.max(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or we can just find the corresponding 5 value using one-pass scan:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int maximumProduct(int[] nums) &#123;</span><br><span class="line">       int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">       for (int n : nums) &#123;</span><br><span class="line">           if (n &gt; max1) &#123;</span><br><span class="line">               max3 = max2;</span><br><span class="line">               max2 = max1;</span><br><span class="line">               max1 = n;</span><br><span class="line">           &#125; else if (n &gt; max2) &#123;</span><br><span class="line">               max3 = max2;</span><br><span class="line">               max2 = n;</span><br><span class="line">           &#125; else if (n &gt; max3) &#123;</span><br><span class="line">               max3 = n;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (n &lt; min1) &#123;</span><br><span class="line">               min2 = min1;</span><br><span class="line">               min1 = n;</span><br><span class="line">           &#125; else if (n &lt; min2) &#123;</span><br><span class="line">               min2 = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return Math.max(max1*max2*max3, max1*min1*min2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#leetcode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="leetcode 159. Longest Substring with At Most Two Distinct Characters"></a>leetcode 159. Longest Substring with At Most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>
<p>For example, Given s = <code>“eceba”</code>,</p>
<p>T is “ece” which its length is 3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map= new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        int left=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int right=0; right&lt;s.length(); right++)&#123;</span><br><span class="line">            char ch= s.charAt(right);</span><br><span class="line">            map.put(ch, map.getOrDefault(ch, 0)+1);</span><br><span class="line">            while(map.size()&gt;2)&#123;</span><br><span class="line">                char delete=s.charAt(left);</span><br><span class="line">                map.put(delete, map.get(delete)-1);</span><br><span class="line">                if(map.get(delete)==0) map.remove(delete);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res, right-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This Solution can be extended to the general k-different solutions;</p>
<h3 id="leetcode-465-Optimal-Account-Balancing"><a href="#leetcode-465-Optimal-Account-Balancing" class="headerlink" title="leetcode 465. Optimal Account Balancing"></a>leetcode 465. Optimal Account Balancing</h3><p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill’s lunch for 10. Then later Chris gave Alice 5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person’s ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>
<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>
<p><strong>Note:</strong></p>
<ol>
<li>A transaction will be given as a tuple (x, y, z). Note that <code>x ≠ y</code> and <code>z &gt; 0</code>.</li>
<li>Person’s IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,10], [2,0,5]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Person #0 gave person #1 $10.</span><br><span class="line">Person #2 gave person #0 $5.</span><br><span class="line"></span><br><span class="line">Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Person #0 gave person #1 $10.</span><br><span class="line">Person #1 gave person #0 $1.</span><br><span class="line">Person #1 gave person #2 $5.</span><br><span class="line">Person #2 gave person #0 $5.</span><br><span class="line"></span><br><span class="line">Therefore, person #1 only need to give person #0 $4, and all debt is settled.</span><br></pre></td></tr></table></figure>
<p>题目属于NPC问题， 在这种情况下， 进行暴力解就好， 解法： 借西墙补东墙，将位于第一位的数字放入可以放入的其他位中， 然后将第一位清零， 进行下一次更替。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minTransfers(int[][] transactions) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(int i=0; i&lt;transactions.length; i++)&#123;</span><br><span class="line">            int give=transactions[i][0];</span><br><span class="line">            int take=transactions[i][1];</span><br><span class="line">            int val= transactions[i][2];</span><br><span class="line">            map.put(give, map.getOrDefault(give, 0)-val);</span><br><span class="line">            map.put(take, map.getOrDefault(take, 0)+val);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; debts= new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int debt: map.values())&#123;</span><br><span class="line">            if(debt!=0)&#123;</span><br><span class="line">                debts.add(debt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(debts);</span><br><span class="line">        return helper(0, 0, debts);</span><br><span class="line">    &#125;</span><br><span class="line">    private int helper(int pos, int count, List&lt;Integer&gt; debts)&#123;</span><br><span class="line">        while(pos&lt;debts.size() &amp;&amp; debts.get(pos)==0) pos++;</span><br><span class="line">        if(pos==debts.size()) return count;</span><br><span class="line">        int val= debts.get(pos);</span><br><span class="line">        int res=Integer.MAX_VALUE;</span><br><span class="line">        for(int i= pos+1; i&lt;debts.size(); i++)&#123;</span><br><span class="line">            if(debts.get(i)*val&lt;0)&#123;</span><br><span class="line">                while(i+1&lt;debts.size() &amp;&amp; debts.get(i)==debts.get(i+1)) i++;</span><br><span class="line">                debts.set(i, debts.get(i)+ val);</span><br><span class="line">                res=Math.min(res, helper(pos+1, count+1, debts));</span><br><span class="line">                debts.set(i, debts.get(i)-val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-464-Can-I-Win"><a href="#Leetcode-464-Can-I-Win" class="headerlink" title="Leetcode 464. Can I Win"></a>Leetcode 464. Can I Win</h3><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p><strong>Example</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">No matter which integer the first player choose, the first player will lose.</span><br><span class="line">The first player can choose an integer from 1 up to 10.</span><br><span class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</span><br><span class="line">The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</span><br><span class="line">Same with other integers chosen by the first player, the second player will always win.</span><br></pre></td></tr></table></figure>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h4><p>很经典的Backtracking+ Game Theory+ Hash的题目， 我们要做的就是考虑下一步的反面就好了， 如果下一步的对手不能赢， 说明我们这一步就可以赢。</p>
<p>需要注意的是优化， 这里采用的是hash+memorization， 但是效果可能不是特别好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; map= new HashMap&lt;String, Boolean&gt;();</span><br><span class="line">    public boolean canIWin(int maxChoosableInteger, int desiredTotal) &#123;</span><br><span class="line">        int sum=(maxChoosableInteger+1)*maxChoosableInteger/2;</span><br><span class="line">        if(sum&lt;desiredTotal) return false;</span><br><span class="line">        if(desiredTotal&lt;=0) return true;</span><br><span class="line">        boolean[] visited= new boolean[maxChoosableInteger+1];</span><br><span class="line">        return canIWin(visited, desiredTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean canIWin(boolean[] visited, int desiredTotal)&#123;</span><br><span class="line">        if(desiredTotal&lt;=0) return false;</span><br><span class="line">        String key= encode(visited);</span><br><span class="line">        if(map.containsKey(key)) return map.get(key);</span><br><span class="line">        for(int i=1; i&lt;visited.length; i++)&#123;</span><br><span class="line">            if(visited[i]) continue;</span><br><span class="line">            visited[i]= true;</span><br><span class="line">            if(!canIWin(visited, desiredTotal-i))&#123;// if the remaining one cannot win, then we say we can win.</span><br><span class="line">                map.put(key, true);</span><br><span class="line">                visited[i]=false;//here we need to refresh the visited;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public String encode(boolean[] visited)&#123;</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        for(int i=0; i&lt;visited.length; i++)&#123;</span><br><span class="line">            if(visited[i])&#123;</span><br><span class="line">                sb.append(1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sb.append(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#leetcode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="leetcode 297. Serialize and Deserialize Binary Tree"></a>leetcode 297. Serialize and Deserialize Binary Tree</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>
<p>as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<p>, just the same as</p>
<p>how LeetCode OJ serializes a binary tree</p>
<p>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目也很经典啊， 利用preorder对tree进行遍历， 然后利用相同的过程进行重建。 具体看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line"></span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    public String serialize(TreeNode root) &#123;</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    // preorder traverse the tree</span><br><span class="line">    public void serialize(TreeNode root, StringBuilder sb)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            sb.append(&quot;,null&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;,&quot;).append(root.val);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        String[] tokens= data.split(&quot;,&quot;);</span><br><span class="line">        Queue&lt;String&gt; queue= new LinkedList&lt;String&gt;();</span><br><span class="line">        for(int i=0; i&lt;tokens.length; i++)&#123;</span><br><span class="line">            if(tokens[i].length()==0 || tokens[i].equals(&quot;,&quot;))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(tokens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return buildTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode buildTree(Queue&lt;String&gt; queue)&#123;</span><br><span class="line">        if(queue.size()==0) return null;</span><br><span class="line">        String val= queue.poll();</span><br><span class="line">        if(val.equals(&quot;null&quot;)) return null;</span><br><span class="line">        TreeNode root= new TreeNode(Integer.valueOf(val));</span><br><span class="line">        root.left = buildTree(queue);</span><br><span class="line">        root.right= buildTree(queue);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-339-Nested-List-Weight-Sum"><a href="#leetcode-339-Nested-List-Weight-Sum" class="headerlink" title="leetcode 339. Nested List Weight Sum"></a>leetcode 339. Nested List Weight Sum</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>10</strong>. (four 1’s at depth 2, one 2 at depth 1)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>27</strong>. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>典型的DFS题目， 记录每一层的深度， 然后乘其数值即可得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *     // Constructor initializes an empty nested list.</span><br><span class="line"> *     public NestedInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Constructor initializes a single integer.</span><br><span class="line"> *     public NestedInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a single integer.</span><br><span class="line"> *     public void setInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span><br><span class="line"> *     public void add(NestedInteger ni);</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(NestedInteger i: nestedList)&#123;</span><br><span class="line">            sum+=dfs(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfs(NestedInteger num, int depth)&#123;</span><br><span class="line">        if(num.isInteger())&#123;</span><br><span class="line">            return num.getInteger()*depth;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int sum=0;</span><br><span class="line">            List&lt;NestedInteger&gt; list= num.getList();</span><br><span class="line">            for(NestedInteger i: list)&#123;</span><br><span class="line">                sum+=dfs(i, depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-364-Nested-List-Weight-Sum-II"><a href="#Leetcode-364-Nested-List-Weight-Sum-II" class="headerlink" title="Leetcode 364. Nested List Weight Sum II"></a>Leetcode 364. Nested List Weight Sum II</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the <a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">previous question</a> where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>, return <strong>8</strong>. (four 1’s at depth 1, one 2 at depth 2)</p>
<p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>, return <strong>17</strong>. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *     // Constructor initializes an empty nested list.</span><br><span class="line"> *     public NestedInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Constructor initializes a single integer.</span><br><span class="line"> *     public NestedInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a single integer.</span><br><span class="line"> *     public void setInteger(int value);</span><br><span class="line"> *</span><br><span class="line"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span><br><span class="line"> *     public void add(NestedInteger ni);</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; level= new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(NestedInteger i: nestedList)&#123;</span><br><span class="line">            getRank(level, i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int maxLevel=0;</span><br><span class="line">        for(int i: level.keySet())&#123;</span><br><span class="line">            maxLevel= Math.max(maxLevel, i);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i: level.keySet())&#123;</span><br><span class="line">            sum+=(maxLevel-i+1)*level.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getRank(Map&lt;Integer, Integer&gt; level, NestedInteger num, int depth)&#123;</span><br><span class="line">        if(num.isInteger())&#123;</span><br><span class="line">            level.put(depth, level.getOrDefault(depth, 0)+ num.getInteger());</span><br><span class="line">            return;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list= num.getList();</span><br><span class="line">            for(NestedInteger i: list)&#123;</span><br><span class="line">                getRank(level, i, depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-405-Convert-a-Number-to-Hexadecimal"><a href="#leetcode-405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="leetcode 405. Convert a Number to Hexadecimal"></a>leetcode 405. Convert a Number to Hexadecimal</h3><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">two’s complement</a> method is used.</p>
<p><strong>Note:</strong></p>
<ol>
<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>
<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>&#39;0&#39;</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>进制转换， 也算比较不错的一道题目了， 需要注意的是16进制向 2进制的转换， 以及map的这个操作。</p>
<p>Basic idea: each time we take a look at the last four digits of binary version of input, and maps that to a hex char, shift the input to the right by 4 bits, do it again until input becomes 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    //</span><br><span class="line">    public String toHex(int num) &#123;</span><br><span class="line">        char[] map = new char[]&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line">        if(num==0) return &quot;0&quot;;</span><br><span class="line">        String result= &quot;&quot;;</span><br><span class="line">        while(num!=0)&#123;</span><br><span class="line">            result= map[(num&amp;15)] + result;</span><br><span class="line">            num= (num&gt;&gt;&gt;4);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-Find-Leaves-of-Binary-Tree"><a href="#leetcode-Find-Leaves-of-Binary-Tree" class="headerlink" title="leetcode: Find Leaves of Binary Tree"></a>leetcode: Find Leaves of Binary Tree</h3><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<p>Example:<br>Given binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>Returns [4, 5, 3], [2], [1].</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>这道题给了我们一个二叉树， 让我们返回其每层的叶节点， 就像剥洋葱一样， 将这个二叉树一层层剥掉， 最后一个剥掉根节点。 思路是这样的， 每一个节点从左子节点和右子节点分开走可以得到两个深度， 由于成为叶节点的条件是左右子结点都为空， 所以我们取左右子节点中较大值加1 为当前节点的深度值， 知道了深度值就可以将节点值加入到结果res中的正确位置了。</p>
<p>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">	public static List&lt;List&lt;Integer&gt;&gt; findLeaves&#123;</span><br><span class="line">     	List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      	getDepth(root, res);</span><br><span class="line">      	return res;</span><br><span class="line">    &#125;</span><br><span class="line">  public static int getDepth(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root)&#123;</span><br><span class="line">      	if(root==null) return 0;</span><br><span class="line">    	int left= getDepth(res, root.left);</span><br><span class="line">    	int right= getDepth(res, root.right);</span><br><span class="line">    	int depth= Math.max(left, right)+1;</span><br><span class="line">    	while(res.size()&lt;depth)&#123;</span><br><span class="line">        	res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    	&#125;</span><br><span class="line">    	res.get(depth-1).add(root.val);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解法， 使用naive的一层层剥离的方法， 思路是遍历二叉树， 找到叶节点， 将其值赋值为null， 然后加入leaves中， 这样一层层剥离就可以得到最终结果了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class solution&#123;</span><br><span class="line">	public static List&lt;List&lt;Integer&gt;&gt; findLeaves&#123;</span><br><span class="line">     	List&lt;List&lt;Integer&gt;&gt; res= new Arraylist&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">      	while(root!=null)&#123;</span><br><span class="line">          	List&lt;Integer&gt; leaves= new ArrayList&lt;Integer&gt;()</span><br><span class="line">            removeLeave(root, leaves);</span><br><span class="line">          res.add(leaves);</span><br><span class="line">        &#125;</span><br><span class="line">      	return res;</span><br><span class="line">    &#125;</span><br><span class="line">  public static TreeNode removeLeave(TreeNode root, List&lt;Integer&gt; leaves)&#123;</span><br><span class="line">      	if(root==null) return null;</span><br><span class="line">    	if(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            leaves.add(root.val);</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">    	root.left= removeLeave(root.left, leaves);</span><br><span class="line">    	root.right= removeLeave(root.right, leaves);</span><br><span class="line">    	return root;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15: 3Sum"></a>Leetcode 15: 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>总的来说， 两个知识点的考察： 1. two pointers; 2. 如何去重。</p>
<p>这里我们主要的难点就是对于去重： 如何高效地去重。</p>
<p>这里我们直接看代码进行理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0; i&lt;nums.length-2; i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            //if(res.size()&gt;0 &amp;&amp; res.get(res.size()-1).get(0)==nums[i]) continue;</span><br><span class="line">            int target= -nums[i];</span><br><span class="line">            int left= i+1;</span><br><span class="line">            int right=nums.length-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                if(nums[left]+nums[right]==target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp= new ArrayList&lt;Integer&gt;();</span><br><span class="line">                    temp.add(-target);</span><br><span class="line">                    temp.add(nums[left]);</span><br><span class="line">                    temp.add(nums[right]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    while(++left&lt;right &amp;&amp; nums[left]==nums[left-1]);</span><br><span class="line">                    while(--right&gt;left &amp;&amp; nums[right]==nums[right+1]);</span><br><span class="line">                &#125;else if(nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i+1&lt;nums.length-2 &amp;&amp; nums[i]==nums[i+1]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-33-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode 33. Search in Rotated Sorted Array"></a>Leetcode 33. Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>无比经典的题目， 主要考察的是对binary search的理解。 这里search的array被分为两个部分， 而两个部分都是递增的， 比较直观的解释便是先判断mid处于哪一个部分， 然后再判断target处于哪一个part。具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">  public int search(int[] nums, int target)&#123;</span><br><span class="line">    if(nums.length==0) return -1;</span><br><span class="line">    int left=0;</span><br><span class="line">    int right=nums.length-1;</span><br><span class="line">    while(left&lt;=right)&#123;</span><br><span class="line">      int mid= left+(right-left)/2;</span><br><span class="line">      if(nums[mid]==target)&#123;</span><br><span class="line">        return mid;</span><br><span class="line">      &#125;</span><br><span class="line">      if(nums[mid]&gt;=nums[left])&#123;//  judge which part does mid fall into</span><br><span class="line">        if(target&lt;nums[mid] &amp;&amp; target&gt;= nums[left]) right= mid-1;</span><br><span class="line">        else left= mid+1;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if(target&gt;nums[mid] &amp;&amp; target&lt;= nums[right]) left= mid+1;</span><br><span class="line">        else right=mid-1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-Up-1-what-if-there-are-duplicate-exists"><a href="#Follow-Up-1-what-if-there-are-duplicate-exists" class="headerlink" title="Follow-Up 1, what if there are duplicate exists?"></a>Follow-Up 1, what if there are duplicate exists?</h4><p>The only difference is that due to the existence of duplicates, we can have nums[left]==nums[mid] and in that case, the first half could be out of order(i.e. NOT in the ascending order, e.g.[3,1,2,3,3,3,3]) and we have to deal with this case separately. In that case, it’s guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]==nums[left]==nums[right] before the original logic, if so, we can move left and right both towards the middle by 1. and repeat</p>
<h4 id="follow-up-solution-1"><a href="#follow-up-solution-1" class="headerlink" title="follow-up solution 1"></a>follow-up solution 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right =  nums.size()-1, mid;</span><br><span class="line">        </span><br><span class="line">        while(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; 1;</span><br><span class="line">            if(nums[mid] == target) return true;</span><br><span class="line"></span><br><span class="line">            // the only difference from the first one, trickly case, just updat left and right</span><br><span class="line">            if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125;</span><br><span class="line"></span><br><span class="line">            else if(nums[left] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1;</span><br><span class="line">                else left = mid + 1; </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+1;</span><br><span class="line">                else right = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="follow-up-solution-2"><a href="#follow-up-solution-2" class="headerlink" title="follow-up solution 2"></a>follow-up solution 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">     public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums.length==0) return false;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=nums.length-1;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]==target) return true;</span><br><span class="line">            if(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">               if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">                   right=mid-1;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   left=mid+1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;else if(nums[mid]&lt;nums[left])&#123;</span><br><span class="line">               if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right])&#123;</span><br><span class="line">                   left=mid+1;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   right=mid-1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Follow-up-2-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Follow-up 2 Find Minimum in Rotated Sorted Array"></a>Follow-up 2 Find Minimum in Rotated Sorted Array</h4><p>In such condition, we try to maintain the structure of the array, and delete part of it when we find mid, the most important case is that when the left pointer is already in the right part, which means we can stop the finding process.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMin(int[] nums) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right= nums.length-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(nums[left]&lt;nums[right]) return nums[left];</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]&gt;=nums[left])&#123;// mid fall into the left part</span><br><span class="line">                left=mid+1;// then we can just move to the right</span><br><span class="line">            &#125;else&#123;// else if mid fall into the right part</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follow-up-3-What-if-there-are-duplicates-in-follow-up-2"><a href="#Follow-up-3-What-if-there-are-duplicates-in-follow-up-2" class="headerlink" title="Follow-up 3 What if there are duplicates in follow-up 2"></a>Follow-up 3 What if there are duplicates in follow-up 2</h4><p>Things become easy since we have solved problem 2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMin(int[] nums) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right= nums.length-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(nums[left]&lt;nums[right]) return nums[left];</span><br><span class="line">            int mid=(left+right)/2;</span><br><span class="line">            if(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">                left=mid+1;</span><br><span class="line">            &#125;else if(nums[mid]&lt;nums[left])&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when completed the three follow-up, things become easy when we want to find the median/max:</p>
<p>we just find the minimum, and then find it’s index, then we know the turn point, by which we can know the original structure of the array.</p>
<h3 id="Leetcode-72"><a href="#Leetcode-72" class="headerlink" title="Leetcode 72"></a>Leetcode 72</h3><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>典型的DP问题， 解决一道题解决所有题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][] dp= new int[word1.length()+1][word2.length()+1];</span><br><span class="line">        for(int i=0; i&lt;=word1.length(); i++)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0; j&lt;=word2.length(); j++)&#123;</span><br><span class="line">            dp[0][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=word1.length(); i++)&#123;</span><br><span class="line">            for(int j=1; j&lt;=word2.length(); j++)&#123;</span><br><span class="line">                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    int delete=Math.min(dp[i][j-1], dp[i-1][j])+1;</span><br><span class="line">                    int replace=dp[i-1][j-1]+1;</span><br><span class="line">                    dp[i][j]=Math.min(delete, replace);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如： leetcode 712. Minimum ASCII Delete Sum for Two Strings</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minimumDeleteSum(String s1, String s2) &#123;</span><br><span class="line">        int[][] dp= new int[s1.length()+1][s2.length()+1];</span><br><span class="line">        int min=Integer.MAX_VALUE;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0; i&lt;=s1.length(); i++)&#123;</span><br><span class="line">            dp[i][0]=(i&gt;0? dp[i-1][0]+s1.charAt(i-1):0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0; j&lt;=s2.length(); j++)&#123;</span><br><span class="line">            dp[0][j]=(j&gt;0? dp[0][j-1]+s2.charAt(j-1):0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=s1.length(); i++)&#123;</span><br><span class="line">            for(int j=1; j&lt;=s2.length(); j++)&#123;</span><br><span class="line">                if(s1.charAt(i-1)==s2.charAt(j-1)) dp[i][j]= dp[i-1][j-1];</span><br><span class="line">                else dp[i][j]=Math.min(dp[i][j-1]+ s2.charAt(j-1), dp[i-1][j]+s1.charAt(i-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-324-Wiggle-Sort-II"><a href="#Leetcode-324-Wiggle-Sort-II" class="headerlink" title="Leetcode 324. Wiggle Sort II"></a>Leetcode 324. Wiggle Sort II</h3><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>这道题被categorized as medium， 但是实际上到达了hard的难度， 我们如何在O(n)的事件复杂度里面解决该题呢，基本的思想是， 我们要先找到array中的中位数， 然后依据该中位数进行排列， 使得排列后的数列满足我们的条件。</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void wiggleSort(int[] nums) &#123;</span><br><span class="line">        int median=findKthLargest(nums, (nums.length+1)/2);</span><br><span class="line">        // here we just try to solve it in O(n);</span><br><span class="line">        int[] temp= new int[nums.length];</span><br><span class="line">        int s=0, t= nums.length-1, mid_index=(nums.length+1)&gt;&gt;1;</span><br><span class="line">      //when we find the median,we try to rearrange the array to satisified the requirement.</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(nums[i]&lt;median) temp[s++]= nums[i];</span><br><span class="line">            else if(nums[i]&gt;median) temp[t--]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        while(s&lt;mid_index) temp[s++]= median;</span><br><span class="line">        while(t&gt;=mid_index) temp[t--]= median;</span><br><span class="line">      // after three-way partition</span><br><span class="line">        t= nums.length;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            nums[i]=(i&amp;1)==0? temp[--s]: temp[--t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int idx= partition(nums, lo, hi);</span><br><span class="line">            if(idx&gt;k)&#123;</span><br><span class="line">                hi= idx-1;</span><br><span class="line">            &#125;else if(idx&lt;k)&#123;</span><br><span class="line">                lo= idx+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    private int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        if(lo&gt;=hi) return lo;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key=nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int tmp= nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-215-Kth-Largest-Element-in-An-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-An-Array" class="headerlink" title="Leetcode 215 . Kth Largest Element in An Array"></a>Leetcode 215 . Kth Largest Element in An Array</h3><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>The smart approach for this problem is to use the selection algorithm, based on the partition method - the same one as used in quicksort</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int idx= partition(nums, lo, hi);</span><br><span class="line">            if(idx&gt;k)&#123;</span><br><span class="line">                hi= idx-1;</span><br><span class="line">            &#125;else if(idx&lt;k)&#123;</span><br><span class="line">                lo= idx+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    private int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        if(lo&gt;=hi) return lo;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key=nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j]&gt;key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int tmp= nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-376-Wiggle-Subsequence"><a href="#Leetcode-376-Wiggle-Subsequence" class="headerlink" title="Leetcode. 376 Wiggle Subsequence"></a>Leetcode. 376 Wiggle Subsequence</h3><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题一开始用的是很蠢的dp； 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public int wiggleMaxLength(int[] nums)&#123;</span><br><span class="line">        if(nums.length==0) return 0;</span><br><span class="line">        if(nums.length==1) return 1;</span><br><span class="line">        int[] decrease= new int[nums.length];// the previous is decrease</span><br><span class="line">        int[] increase= new int[nums.length];// the previous is increase</span><br><span class="line">        int res=0;</span><br><span class="line">        increase[0]=1;</span><br><span class="line">        decrease[0]=1;</span><br><span class="line">        for(int i=1; i&lt;nums.length; i++)&#123;</span><br><span class="line">            increase[i]=1;</span><br><span class="line">            decrease[i]=1;</span><br><span class="line">            for(int j=0; j&lt;i; j++)&#123;</span><br><span class="line">                if(nums[i]&gt;nums[j])</span><br><span class="line">                    increase[i]=Math.max(decrease[j]+1, increase[i]);</span><br><span class="line">                if(nums[i]&lt;nums[j])</span><br><span class="line">                    decrease[i]=Math.max(increase[j]+1, decrease[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(increase[i], res);</span><br><span class="line">            res=Math.max(decrease[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(n^2)，属于能解出来但是没能对问题有深入理解的：</p>
<p>我们没有必要去追溯之前的每一个值， 只要最近的一个， 也就是i-1就可以了。画个图我们就能理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums)&#123;</span><br><span class="line">        if(nums.length&lt;2) return nums.length;</span><br><span class="line">      int down=1, up=1;</span><br><span class="line">      for(int i=1; i&lt;nums.length; i++)&#123;</span><br><span class="line">          if(nums[i]&gt;nums[i-1]) up=down+1;</span><br><span class="line">        else if(nums[i]&lt;nums[i-1])</span><br><span class="line">          down=up+1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.max(down, up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-227-Basic-Calculator"><a href="#Leetcode-227-Basic-Calculator" class="headerlink" title="Leetcode 227. Basic Calculator"></a>Leetcode 227. Basic Calculator</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>如何将中缀表达式转换为后缀表达式：</p>
<ol>
<li>当遇到数字直接送至输出队列中；</li>
<li>当读到运算符t时：<ol>
<li>将栈中所有优先级高于或等于t的运算符弹出， 送到输出队列中（aka, 从栈顶开始， 依次弹出比当前处理的运算符优先级高的运算符， 直到一个比他优先级低的或者遇到了一个左括号就停止）。</li>
<li>t进栈</li>
</ol>
</li>
</ol>
<ol>
<li>读到左括号时总是将它压入栈中；</li>
<li>读到右括号时， 将靠近栈顶的第一个左括号上面的运算符全部依次弹出， 送至输出队列后， 再丢弃左括号。</li>
<li>中缀表达式全部读完后， 若栈中仍有运算符， 将其送到输出队列中。</li>
</ol>
<p>运用后缀表达式进行运算：</p>
<ol>
<li><p>建立一个栈S;</p>
</li>
<li><p>从左到右读后缀表达式， 读到数字就让它转换成数值压入栈S中， 读到运算符则从栈中依次弹出两个树分别到Y和X， 然后以“X运算符Y”的形式计算机出结果， 再压入栈S中；</p>
</li>
<li><p>如果后缀表达式未读完， 就重复上面过程， 最后输出栈顶的数值则为结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">while there are tokens to be read:</span><br><span class="line"></span><br><span class="line">read a token.</span><br><span class="line"></span><br><span class="line">if the token is a number, then push it to the output queue.</span><br><span class="line"></span><br><span class="line">if the token is an operator, then:</span><br><span class="line"></span><br><span class="line">    while there is an operator at the top of the operator stack with</span><br><span class="line">    	greater than or equal to precedence and the operator is left associative:</span><br><span class="line">    		pop operators from the operator stack, onto the output queue.</span><br><span class="line">    push the read operator onto the operator stack.</span><br><span class="line"></span><br><span class="line">if the token is a left bracket (i.e. &quot;(&quot;), then:</span><br><span class="line"></span><br><span class="line">    push it onto the operator stack.</span><br><span class="line"></span><br><span class="line">if the token is a right bracket (i.e. &quot;)&quot;), then:</span><br><span class="line"></span><br><span class="line">    while the operator at the top of the operator stack is not a left bracket:</span><br><span class="line">    	pop operators from the operator stack onto the output queue.</span><br><span class="line">    pop the left bracket from the stack.</span><br><span class="line">    /* if the stack runs out without finding a left bracket, then there are</span><br><span class="line">    mismatched parentheses. */</span><br><span class="line"></span><br><span class="line">if there are no more tokens to read:</span><br><span class="line"></span><br><span class="line">    while there are still operator tokens on the stack:</span><br><span class="line">    /* if the operator token on the top of the stack is a bracket, then</span><br><span class="line">    there are mismatched parentheses. */</span><br><span class="line">    pop the operator onto the output queue.</span><br><span class="line"></span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public  int calculate(String s)&#123;</span><br><span class="line">        s=s.replace(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        Stack&lt;String&gt; operators= new Stack&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; tokens= new ArrayList&lt;String&gt;();</span><br><span class="line">        // transfer to suffix expression</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            char ch= s.charAt(i);</span><br><span class="line">            if(ch==&apos;+&apos; || ch==&apos;-&apos;)&#123;</span><br><span class="line">                while(!operators.isEmpty())&#123;</span><br><span class="line">                    tokens.add(operators.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operators.push(String.valueOf(ch));</span><br><span class="line">            &#125;else if(ch==&apos;*&apos; || ch==&apos;/&apos;)&#123;</span><br><span class="line">                while(!operators.isEmpty() &amp;&amp; (operators.peek().equals(&quot;*&quot;)||operators.peek().equals(&quot;/&quot;)))&#123;</span><br><span class="line">                    tokens.add(operators.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operators.push(String.valueOf(ch));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                StringBuilder sb= new StringBuilder();</span><br><span class="line">                while(i&lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                    sb.append(s.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                tokens.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!operators.isEmpty())&#123;</span><br><span class="line">            tokens.add(operators.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        // calculate the suffix expression</span><br><span class="line">        Stack&lt;Integer&gt; nums= new Stack&lt;Integer&gt;();</span><br><span class="line">        for(String token: tokens)&#123;</span><br><span class="line">            if(Character.isDigit(token.charAt(0)))&#123;</span><br><span class="line">                nums.push(Integer.valueOf(token));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int num_2=nums.pop();</span><br><span class="line">                int num_1=nums.pop();</span><br><span class="line">                nums.push(cal(num_1,num_2, token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    private int cal(int num1, int num2, String token)&#123;</span><br><span class="line">        if(token.equals(&quot;+&quot;)) return num1+num2;</span><br><span class="line">        if(token.equals(&quot;*&quot;)) return num1*num2;</span><br><span class="line">        if(token.equals(&quot;-&quot;)) return num1-num2;</span><br><span class="line">        if(token.equals(&quot;/&quot;)) return num1/num2;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee"></a>Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</h3><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The maximum profit can be achieved by:</span><br><span class="line">Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure>
<h4 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h4><p>经典的状态机，Stock系列的新题， 但是基本上跟之前的题目差不多， 我们用两个状态 one and zero 来记录手上握有的股票数量， 利用更新dp公式进行两个状态的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int maxProfit(int[] prices, int fee)&#123;</span><br><span class="line">        // two state: one and zero;</span><br><span class="line">        if(prices.length&lt;=1) return 0;</span><br><span class="line">        long zero=0;</span><br><span class="line">        long one=Integer.MIN_VALUE;</span><br><span class="line">        for(int i=0; i&lt;prices.length; i++)&#123;</span><br><span class="line">            long zero_prev=zero;</span><br><span class="line">            long one_prev=one;</span><br><span class="line">            zero=Math.max(zero_prev, one_prev+prices[i]-fee);</span><br><span class="line">            one= Math.max(one_prev, zero_prev-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)Math.max(one, zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-609-Find-Duplicate-File-in-System"><a href="#Leetcode-609-Find-Duplicate-File-in-System" class="headerlink" title="Leetcode 609. Find Duplicate File in System"></a>Leetcode 609. Find Duplicate File in System</h3><h3 id="Leetcode-450-Delete-Node-in-a-BST"><a href="#Leetcode-450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode 450. Delete Node in a BST"></a>Leetcode 450. Delete Node in a BST</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root = [5,3,6,2,4,null,7]</span><br><span class="line">key = 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line"></span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   6</span><br><span class="line"> /     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">Another valid answer is [5,2,6,null,4,null,7].</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>
<h4 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h4><p>骚的要死的递归， 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key)&#123;</span><br><span class="line">        if(root==null) return null;</span><br><span class="line">        if(root.val&gt;key)&#123;</span><br><span class="line">            root.left=deleteNode(root.left, key);</span><br><span class="line">        &#125;else if(root.val&lt;key)&#123;</span><br><span class="line">            root.right= deleteNode(root.right, key);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root=deleteRoot(root);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode deleteRoot(TreeNode root)&#123;</span><br><span class="line">        if(root.left==null) return root.right;</span><br><span class="line">        if(root.right==null) return root.left;</span><br><span class="line">        TreeNode node= root.right;</span><br><span class="line">        while(node.left!=null)&#123;</span><br><span class="line">            node= node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.val=node.val;</span><br><span class="line">        root.right=deleteNode(root.right, root.val);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">      private TreeNode deleteRoot(TreeNode root) &#123;</span><br><span class="line">        ifs (root==null) return null;</span><br><span class="line">        if (root.right==null) return root.left;</span><br><span class="line">        TreeNode x=root.right; // root.right should be the new root</span><br><span class="line">        while (x.left!=null) x=x.left; // find the left-most node</span><br><span class="line">        x.left=root.left;</span><br><span class="line">        return root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-32-Longest-Valid-Parentheses"><a href="#Leetcode-32-Longest-Valid-Parentheses" class="headerlink" title="Leetcode 32. Longest Valid Parentheses"></a>Leetcode 32. Longest Valid Parentheses</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p>
<p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p>
<h4 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h4><p>对于这一类问题， 基本都是two-pass， 从左到右扫描一遍， 再从右到做扫描一遍。</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s)&#123;</span><br><span class="line">        int prev=-1;</span><br><span class="line">        int count=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.charAt(i)==&apos;(&apos;) count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&lt;0)&#123;</span><br><span class="line">                count=0;</span><br><span class="line">                prev=i;</span><br><span class="line">            &#125;else if(count==0)&#123;</span><br><span class="line">                res=Math.max(res, i-prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev=s.length();</span><br><span class="line">        count=0;</span><br><span class="line">        for(int i=s.length()-1; i&gt;=0; i--)&#123;</span><br><span class="line">            if(s.charAt(i)==&apos;)&apos;) count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&lt;0)&#123;</span><br><span class="line">                count=0;</span><br><span class="line">                prev=i;</span><br><span class="line">            &#125;else if(count==0)&#123;</span><br><span class="line">                res= Math.max(res, prev-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-34-Search-for-a-Range"><a href="#Leetcode-34-Search-for-a-Range" class="headerlink" title="Leetcode 34. Search for a Range"></a>Leetcode 34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>非常经典的一道binary search， 考察对二分搜索的理解程度， 这里我们先看一个链接<a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">二分搜索有几种方式</a>。</p>
<p>首先有几个数字要注意</p>
<p>中位数有两个，</p>
<ol>
<li>下位中位数， lowerMedian=(length-2)/2</li>
<li>上位中位数， upperMedian=length/2</li>
</ol>
<p>常用的是下位中位数， 通用的写法如下， 语言int经常自动向下取整，</p>
<blockquote>
<p>median=(length-1)/2</p>
</blockquote>
<p>指针的区间当然可以开区间，也可以闭区间， 也可以半开半闭。 但老老实实两头取闭区间总是不会错。 上面的中位数， 转换成两头闭区间就会变成这样：</p>
<blockquote>
<p>median=low+(hight-low)/2；</p>
</blockquote>
<p>另一个关键点是<strong>终止条件</strong>。</p>
<p>不要以low=high做终止条件，会被跳过的。</p>
<p>不相信在[1,5]里面找0试试？</p>
<p>正确的终止条件是：</p>
<blockquote>
<p>low&gt;high</p>
</blockquote>
<p>也就是搜索空间为空。</p>
<p>满足终止条件之后， 返回值完全不需要纠结， 直接返回地位low。</p>
<p>因为回过头去放慢镜头， 二分查找到的过程就是一个维护low的过程：</p>
<blockquote>
<p>low从0 开始， 只在中位数遇到确定小于目的数时才前进， 并且永不后退。 low一直在朝着第一个目标数的位置在逼近。 直到最后到达。</p>
</blockquote>
<p>至于高位high， 就放心大胆地缩小目标数组的空间吧。</p>
<p>所以最后的代码非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] nums, int target)&#123;</span><br><span class="line">    int low=0, high= nums.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">      int mid= low+(high-low)/2;</span><br><span class="line">    if(nums[mid]&lt;target)&#123;</span><br><span class="line">        low= mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(nums[mid]&gt;target)&#123;</span><br><span class="line">        high= mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(nums[mid]==target) return mid;</span><br><span class="line">  &#125;</span><br><span class="line">  return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上面的代码能正常工作，有一个前提条件：</p>
<p>元素空间没有重复值。</p>
<p>推广到有重复值的空间， 二分查找问题就变成：</p>
<p>寻找元素第一次出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int firstOccurrence(int[] nums, int target)&#123;</span><br><span class="line">    int low=0, high= nums.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">      int mid= low+(high-low)/2;</span><br><span class="line">    if(nums[mid]&lt;target) low=mid+1;</span><br><span class="line">    else high= mid-1;</span><br><span class="line">  &#125;</span><br><span class="line">  return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述讲解， 我们有下面两种代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        if(nums.length==0) return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        int left=searchInsertLo(nums, target);</span><br><span class="line">        if(left==nums.length || nums[left]!=target)&#123;</span><br><span class="line">            return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int right=searchInsertHi(nums, target);</span><br><span class="line">        return new int[]&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchInsertLo(int[] nums, int target) &#123;</span><br><span class="line">        if(target&gt;nums[nums.length-1]) return nums.length;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi)/2;</span><br><span class="line">            if(nums[mid]&gt;=target)&#123;</span><br><span class="line">                hi=mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                lo=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchInsertHi(int[] nums, int target)&#123;</span><br><span class="line">        if(target&gt;nums[nums.length-1]) return nums.length;</span><br><span class="line">        if(target&lt;nums[0]) return 0;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi+1)/2;</span><br><span class="line">            if(nums[mid]&gt;target)&#123;</span><br><span class="line">                hi=mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                lo=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target)&#123;</span><br><span class="line">        if(nums.length==0) return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        int left= searchLeft(nums, target);</span><br><span class="line">        if(left==nums.length || nums[left]!=target)&#123;</span><br><span class="line">            return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int right= searchLeft(nums, target+1)-1;</span><br><span class="line">        return new int[]&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public int searchLeft(int[] nums, int key)&#123;</span><br><span class="line">        int lo=0;</span><br><span class="line">        int hi=nums.length-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+(hi-lo)/2;</span><br><span class="line">            if(nums[mid]&lt;key)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(nums[mid]&gt;=key)&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Leetcode 114. Flatten Binary Tree to Linked List"></a>Leetcode 114. Flatten Binary Tree to Linked List</h3><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,</p>
<p>Given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<h4 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h4><p>这道题是很经典的关于Tree的遍历以及对tree结构的修改的题目， 这里我们先观察输出的结构， 发现它是遵循preorder的顺序的， 于是这里我们先利用preorder得出整个tree的结构， 然后在这个过程里面进行修改。</p>
<p>先看下面一种解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void flatten_stack(TreeNode root)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack= new Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node= root;</span><br><span class="line">        TreeNode prev= root;</span><br><span class="line">        while(!stack.isEmpty() || node!=null)&#123;</span><br><span class="line">            if(node!=null)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                prev= node;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                TreeNode pop= stack.pop();</span><br><span class="line">                node= node.right;</span><br><span class="line">                pop.right= null;</span><br><span class="line">                prev.left= node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node= root;</span><br><span class="line">        while(node!=null)&#123;</span><br><span class="line">            TreeNode left= node.left;</span><br><span class="line">            node.left= null;</span><br><span class="line">            node.right= left;</span><br><span class="line">            node= node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先把树输出为向左的linkedlist， 而后再reverse就好了。</p>
<p>这个也可以使用recursive完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        if(root.left==null)&#123;</span><br><span class="line">            flatten(root.right);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode left= root.left;</span><br><span class="line">        root.left= null;</span><br><span class="line">        TreeNode right= root.right;</span><br><span class="line">        TreeNode node= left;</span><br><span class="line">        while(node.right!=null)&#123;</span><br><span class="line">            node= node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root.right=left;</span><br><span class="line">        node.right= right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最神奇的做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode prev = null;</span><br><span class="line"></span><br><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = prev;</span><br><span class="line">    root.left = null;</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点讲解一下最后一个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode prev = null;</span><br><span class="line"></span><br><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构是典型的post-order遍历， 我们得到的序列是什么呢？</p>
<p>以上面的tree为例子： root的输出结果是： null, 6， 5，4，3，2,1,我们就是依靠root， prev的结果进行对树的机构进行重构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.right= prev;</span><br><span class="line">root.left = null;</span><br></pre></td></tr></table></figure>
<p>进行了上述结构之后， 我们就完成了重构。</p>
<h3 id="Leetcode-44-Wildcard-Matching"><a href="#Leetcode-44-Wildcard-Matching" class="headerlink" title="Leetcode 44. Wildcard Matching"></a>Leetcode 44. Wildcard Matching</h3><p>Implement wild card pattern matching with support for “?” and “*”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br><span class="line"></span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">The function prototype should be:</span><br><span class="line">bool isMatch(const char *s, const char *p)</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class="line">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;*&quot;) → true</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class="line">isMatch(&quot;ab&quot;, &quot;?*&quot;) → true</span><br><span class="line">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</span><br></pre></td></tr></table></figure>
<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>典型的dp问题， 比较tricky的一个点是如果碰到’*’怎么办， 这个时候， 我们采取回退的思想， 如果碰到的时候:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// when p.charAt(j)==&apos;*&apos;, we check if dp[i-1][j]; </span><br><span class="line">// 这里把疑问推给上一个问题， 比较巧妙。</span><br><span class="line">dp[i][j]= dp[i-1][j] || dp[i][j-1];</span><br></pre></td></tr></table></figure>
<p>code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s, String p)&#123;</span><br><span class="line">    boolean[][] dp= new boolean[s.length()+1][p.length()+1];</span><br><span class="line">  dp[0][0]= true;</span><br><span class="line">  for(int i=1; i&lt;= p.length(); i++)&#123;</span><br><span class="line">      if(p.charAt(i-1)==&apos;*&apos;) dp[0][i]= dp[0][j-1];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=s.length(); i++)&#123;</span><br><span class="line">      for(int j=1; j&lt;=p.length(); j++)&#123;</span><br><span class="line">          char ch= p.charAt(j-1);</span><br><span class="line">        if(ch==&apos;?&apos; || s.charAt(i-1)==ch) dp[i][j]= dp[i-1][j-1];</span><br><span class="line">        else if(ch==&apos;*&apos;)&#123;</span><br><span class="line">            dp[i][j]= dp[i][j-1] || dp[i-1][j];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dp[i][j]= false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10. Regular Expression Matching"></a>Leetcode 10. Regular Expression Matching</h3><p>Implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br><span class="line"></span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">The function prototype should be:</span><br><span class="line">bool isMatch(const char *s, const char *p)</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class="line">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;ab&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</span><br></pre></td></tr></table></figure>
<p>这道题和上面那道题目基本上是一样的， 所不同的是， 这次我们要把 a* 作为一个整体去考虑， 对于这样一个元素，我们可以匹配:</p>
<ol>
<li><p>空字符串。</p>
</li>
<li><p>a， 这个时候基本上就消除了*的影响。</p>
</li>
<li><p>多个a， 这个时候 * 还在起作用 我们像上一道题目一样惊醒回退。</p>
<p>​</p>
</li>
</ol>
<p>这里题目应该是假设字符串一定是合法的， 即不会出现*前面没有合法字符的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        if(s == null || p == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        state[0][0] = true;</span><br><span class="line">        // no need to initialize state[i][0] as false</span><br><span class="line">        // initialize state[0][j]</span><br><span class="line">        for (int j = 1; j &lt; state[0].length; j++) &#123;</span><br><span class="line">            if (p.charAt(j - 1) == &apos;*&apos;) &#123;</span><br><span class="line">                if (state[0][j - 1] || (j &gt; 1 &amp;&amp; state[0][j - 2])) &#123;</span><br><span class="line">                    state[0][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; state.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; state[0].length; j++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &apos;.&apos;) &#123;</span><br><span class="line">                    state[i][j] = state[i - 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (p.charAt(j - 1) == &apos;*&apos;) &#123;</span><br><span class="line">                    if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != &apos;.&apos;) &#123;</span><br><span class="line">                        state[i][j] = state[i][j - 2];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return state[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-222-Count-Complete-Tree-Nodes"><a href="#leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="leetcode 222. Count Complete Tree Nodes."></a>leetcode 222. Count Complete Tree Nodes.</h3><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h4 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution:"></a>Solution:</h4><p>这道题需要注意的是题目中给我们的是complete tree，which means， root.left 和 root.right中必定有一株树是满的， 而哪一个数是满的则需要看最后一个node是终止在哪里， 也就是说， height， 这里我们计算每棵树的height便可以解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int height(TreeNode root)&#123;</span><br><span class="line">        int h=-1;</span><br><span class="line">        TreeNode node =root;</span><br><span class="line">        while(node!= null)&#123;</span><br><span class="line">            node= node.left;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root== null) return 0;</span><br><span class="line">        int h= height(root);</span><br><span class="line">        int left= height(root.right);</span><br><span class="line">        if(left== h-1)&#123;</span><br><span class="line">            // the left tree is full tree;</span><br><span class="line">            return countNodes(root.right)+ (1&lt;&lt;h);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return countNodes(root.left)+ (1&lt;&lt;(h-1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-322-Coin-Change"><a href="#Leetcode-322-Coin-Change" class="headerlink" title="Leetcode 322. Coin Change"></a>Leetcode 322. Coin Change</h3><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p>
<p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p>
<p><strong>Note</strong>:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p>经典dp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        int[] dp= new int[amount+1];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[0]= 0;</span><br><span class="line">        for(int coin: coins)&#123;</span><br><span class="line">            for(int i=coin; i&lt;=amount; i++)&#123;</span><br><span class="line">                if(dp[i-coin]==Integer.MAX_VALUE) continue;</span><br><span class="line">                dp[i]=Math.min(dp[i- coin]+1, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount]==Integer.MAX_VALUE? -1: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-518-Coin-Change2"><a href="#Leetcode-518-Coin-Change2" class="headerlink" title="Leetcode 518 Coin Change2"></a>Leetcode 518 Coin Change2</h3><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p><strong>Note:</strong> You can assume that</p>
<ul>
<li>0 &lt;= amount &lt;= 5000</li>
<li>1 &lt;= coin &lt;= 5000</li>
<li>the number of coins is less than 500</li>
<li>the answer is guaranteed to fit into signed 32-bit integer</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 3, coins = [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 10, coins = [10] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-312-Burst-Ballons"><a href="#Leetcode-312-Burst-Ballons" class="headerlink" title="Leetcode 312. Burst Ballons"></a>Leetcode 312. Burst Ballons</h3><p>运用dp的做法， 逆向思维， 很骚。</p>
<h3 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143. Reorder List"></a>Leetcode 143. Reorder List</h3><hr>
<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p>
<p>典型的链表题， 快慢指针+ node的插入+list reverse.</p>
<h4 id="Solution-19"><a href="#Solution-19" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        // first reverse the listnode from middle;</span><br><span class="line">        if(head== null || head.next==null) return;</span><br><span class="line">        ListNode fast= head;</span><br><span class="line">        ListNode slow= head;</span><br><span class="line">        ListNode prev= head;</span><br><span class="line">        while(fast!= null &amp;&amp; fast.next!=null)&#123;</span><br><span class="line">            prev= slow;</span><br><span class="line">            slow= slow.next;</span><br><span class="line">            fast= fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail= slow;</span><br><span class="line">        while(tail.next!= null)&#123;</span><br><span class="line">            ListNode next= tail.next;</span><br><span class="line">            tail.next= next.next;</span><br><span class="line">            next.next= prev.next;</span><br><span class="line">            prev.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid= prev.next;</span><br><span class="line">        ListNode node= head;</span><br><span class="line">        while(node!=prev)&#123;</span><br><span class="line">            prev.next= mid.next;</span><br><span class="line">            mid.next= node.next;</span><br><span class="line">            node.next= mid;</span><br><span class="line">            node= node.next.next;</span><br><span class="line">            mid= prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92. Reverse Linked List II"></a>Leetcode 92. Reverse Linked List II</h3><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<h3 id="Solution-20"><a href="#Solution-20" class="headerlink" title="Solution"></a>Solution</h3><p>综合性的链表题目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">        ListNode dummy= new ListNode(0);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode prev= dummy;</span><br><span class="line">        for(int i=1; i&lt;m; i++)&#123;</span><br><span class="line">            prev= prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail= prev.next;</span><br><span class="line">        for(int i=0; i&lt;n-m; i++)&#123;</span><br><span class="line">            ListNode next= tail.next;</span><br><span class="line">            tail.next= next.next;</span><br><span class="line">            next.next= prev.next;</span><br><span class="line">            prev.next= next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-274-H-Index"><a href="#Leetcode-274-H-Index" class="headerlink" title="Leetcode 274 H- Index"></a>Leetcode 274 H- Index</h3><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least*</strong>h<em>citations each, and the other </em>N − h<em> papers have <strong>no more than</strong> </em>h* citations each.”</p>
<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong><code>3</code>citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>
<p><strong>Note</strong>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>
<h4 id="Solution-21"><a href="#Solution-21" class="headerlink" title="Solution"></a>Solution</h4><p>感觉主要还是对于题意的理解， 对于这道题来说，对于一个长度为N的Array， 因为我们要求这么一个常数h， 使得大于等于h的个数要不小于h， 也就是说我们其实是可以先排序， 然后统计个数， 得到count以及该数字， 如果满足上述条件， 我们可以返回，得到当前数字。</p>
<p>需要注意的地方是count++， 以及if statement的顺序： 应该是if statement放在前面， 要不然可能会多算： ex: [1, 2];</p>
<p>Simple Version:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  // we simple count the two number, and when it meets the requirement, we output it and that is the answer, what need to notice is the order of if statement and increacement; </span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        // A scientist has index h if h of his/her papers have at least h citations each, and other N-h papers has no more than h citations each;</span><br><span class="line">        if(citations.length==0) return 0;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=citations.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">            if(citations[i]==0) continue;</span><br><span class="line">            if(count&gt;=citations[i]) return count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察到h最大只能是N， 我们可以用bucket sort 进行改善：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations)&#123;</span><br><span class="line">    int[] buckets= new int[citations.length+1];</span><br><span class="line">    for(int num: citations)&#123;</span><br><span class="line">        if(num&gt;= citations.length)&#123;</span><br><span class="line">            buckets[citations.length]++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            buckets[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i= buckets.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        count+=buckets[i];</span><br><span class="line">        if(count&gt;=i) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FollowUp"><a href="#FollowUp" class="headerlink" title="FollowUp"></a>FollowUp</h4><p>What if the citations array is sorted in ascending order? Could you optimize algorithm？</p>
<p>在这种情况下， 题目演变成一个binary search的题目： 我们需要找到的是 citations[mid]刚好小于len- mid的那一个点。(这个mid西需要尽量往左边移， 也就是标准的binary search)。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        int left=0, len = citations.size(), right= len-1,  mid;</span><br><span class="line">        while(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)&gt;&gt;1;</span><br><span class="line">            if(citations[mid]== (len-mid)) return citations[mid];</span><br><span class="line">            else if(citations[mid] &gt; (len-mid)) right = mid - 1;</span><br><span class="line">            else left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len - (right+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Leetcode 378. Kth Smallest Element in a Sorted Matrix"></a>Leetcode 378. Kth Smallest Element in a Sorted Matrix</h3><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h4 id="Solution-22"><a href="#Solution-22" class="headerlink" title="Solution"></a>Solution</h4><p>比较简单/ straightforward的方法是使用priorityqueue， 相当于进行了一次mergesort进行寻找， 这里我们直接贴出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private class Entry&#123;</span><br><span class="line">        int val;</span><br><span class="line">        int index_x;</span><br><span class="line">        int index_y;</span><br><span class="line">        public Entry(int val, int index_x, int index_y)&#123;</span><br><span class="line">            this.val= val;</span><br><span class="line">            this.index_x= index_x;</span><br><span class="line">            this.index_y= index_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int kthSmallest(int[][] matrix, int k) &#123;</span><br><span class="line">        PriorityQueue&lt;Entry&gt; pq= new PriorityQueue&lt;&gt;((e1, e2)-&gt;&#123;return e1.val- e2.val;&#125;);</span><br><span class="line">        for(int i=0; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            pq.offer(new Entry(matrix[i][0], i, 0));</span><br><span class="line">        &#125;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">            Entry e= pq.poll();</span><br><span class="line">            k--;</span><br><span class="line">            if(k==0) return e.val;</span><br><span class="line">            if(e.index_y+1&lt;matrix[0].length)&#123;</span><br><span class="line">                pq.offer(new Entry(matrix[e.index_x][e.index_y+1], e.index_x, e.index_y+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们讲解一个更加快的方法： BinarySearch， 通常的二分搜索， 其搜索空间是在index上面对的，0~Arr.length;这里我们改变搜索空间， 变成min~ max.然后计算其排名。 代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int kthSmallest(int[][] a, int k) &#123;</span><br><span class="line">      int n = a.length;</span><br><span class="line">      int s = a[0][0]; // the smallest number</span><br><span class="line">      int b = a[n - 1][n - 1]; // the biggest number</span><br><span class="line">        </span><br><span class="line">      while(s &lt; b) &#123;</span><br><span class="line">          int mid = s + (b - s) / 2;</span><br><span class="line">          int temp = 0;</span><br><span class="line">          for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">              temp += bs(a[i], n, mid);</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt; k) &#123;</span><br><span class="line">              s = mid + 1;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              b = mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      return s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private int bs(int row[], int right, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        //int pos = right + 1;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if(row[mid] &lt;= target) &#123;</span><br><span class="line">                //pos = mid;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想法：</p>
<p>Let’s binary search for the answer A.</p>
<p>Say enough(x) is true iff there are k or more values in the multiplication table that are less than or equal to x, Colloquially, enough describes whether x is large enough to be the k-th value in the multiplication table.</p>
<p>Then(for our answer A), whenever x&gt;= A, enough(X) is True, and whenever x&lt;A, enough(x) is false.</p>
<p>In our binary search, our loop invariant is that enough(x) is True. More specifically, if we were to apply enough onto each argument in the interval [lo. hi], we would see 0 or more False, followed by 1 or more True. Once lo==hi, we know that enough(lo)=True, and it must have been the smallest such one, because lo must have been hi-1 or hi-2 at some point, and mi= hi-1 would have been checked.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public int findKthNumber(int m, int n, int k)&#123;</span><br><span class="line">        int low=1, high= m*n+1;</span><br><span class="line">      while(lo&lt;high)&#123;</span><br><span class="line">          int mid= low+(high-low)/2;</span><br><span class="line">        int c= count(mid, m, n);</span><br><span class="line">        if(c&gt;= k) high= mid;</span><br><span class="line">        else low= mid+1;</span><br><span class="line">      &#125;</span><br><span class="line">      return high;</span><br><span class="line">    &#125;</span><br><span class="line">  private int count(int v, int m, int n)&#123;</span><br><span class="line">      int count=0;</span><br><span class="line">    for(int i=1; i&lt;= m; i++)&#123;</span><br><span class="line">        int temp= Math.min(v/i, n);</span><br><span class="line">      	count+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthNumber(int m, int n, int k) &#123;</span><br><span class="line">        int low=1, high= m*n;</span><br><span class="line">        while(low&lt;=high)&#123;</span><br><span class="line">            int mid= low+(high-low)/2;</span><br><span class="line">            int c= count(mid, m, n);// calculate the rank </span><br><span class="line">            if(c&gt;=k) high= mid-1; // if rank&gt;= k, means we can still push to left;</span><br><span class="line">            else low= mid+1;// else </span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">    private int count(int v, int m, int n)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)&#123;</span><br><span class="line">            int temp= Math.min(v/i, n);</span><br><span class="line">            count+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Where-和-having-区别"><a href="#Where-和-having-区别" class="headerlink" title="Where 和 having 区别"></a>Where 和 having 区别</h3><p>在select语句中可以使用group by子句将行划分成较小的组， 然后， 使用聚组函数返回每一个组的汇总信息， 另外， 可以使用having子句限制返回的结果集。</p>
<p>在带有group by子句的查询语句中， 在select列表中指定的列要么是group by子句中指定的列， 要么包含聚组函数。</p>
<p>select max(sal), job emp group by job;</p>
<p>当在group by子句中使用having子句时， 查询结果只返回满足having条件的组。</p>
<p>where子句的作用时在查询结果进行分组前， 将不符合where条件的行去掉， 即在分组之前过滤数据， 条件中不能包含聚组函数， 使用where条件显示特定的行。</p>
<p>having子句的作用时筛选满足条件的组， 即在分组之前过滤数据， 条件中经常包含聚组函数， 使用having条件显示特定的组， 也可以使用多个分组标准进行分组。</p>
<p>如果你对何时应该使用WHERE，何时使用HAVING仍旧很迷惑，请遵照下面的说明：</p>
<p>　　WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。</p>
<p>　　HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。</p>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>对于一个长度为n的已排序数列a, 如果n为奇数， 中位数为a[n/2+1]， 若n为偶数， 则中位数(a[n / 2] + a[n / 2 + 1]) / 2; 如果我们可以在两个数列中求取第K小的元素， 便可以解决该问题； 不妨设数列A元素个数为n， 数列B元素个数为m， 各自升序排列，求第k小元素； 取A[k/2] B[k/2]比较； 如果 A[k/2]&gt; B[k/2] 那么， 所求的元素必然不在B的前k/2个元素中；反之， 必然不在A的前k/2个元素中， 于是我们可以将A或B数列的前k/2元素删去， 于是我们得到了数据规模变小的同类问题， 递归解决；</p>
<h3 id="Leetcode-136-Single-Number"><a href="#Leetcode-136-Single-Number" class="headerlink" title="Leetcode 136. Single Number"></a>Leetcode 136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>极度高频题， 记住就是了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(int[] A, int n)&#123;</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    result^=A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a>Roman to Integer</h3><h3 id="Leetcode-204-Count-Primes"><a href="#Leetcode-204-Count-Primes" class="headerlink" title="Leetcode 204. Count Primes"></a>Leetcode 204. Count Primes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countPrimes(int n) &#123;</span><br><span class="line">        if(n&lt;2) return 0;</span><br><span class="line">        if(n==2) return 1;</span><br><span class="line">        boolean[] dp= new boolean[n];</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=2; i&lt;n; i++)&#123;</span><br><span class="line">            if(!dp[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                for(int j=1; j*i&lt;n; j++)&#123;</span><br><span class="line">                    dp[j*i]= true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用-Array实现一个Queue"><a href="#用-Array实现一个Queue" class="headerlink" title="用 Array实现一个Queue"></a>用 Array实现一个Queue</h3><h3 id="背包问题Review"><a href="#背包问题Review" class="headerlink" title="背包问题Review"></a>背包问题Review</h3><h3 id="Java中对JSON文件的读取"><a href="#Java中对JSON文件的读取" class="headerlink" title="Java中对JSON文件的读取"></a>Java中对JSON文件的读取</h3><p>JSON语法是JavaScript对象表示法语法的子集：</p>
<ul>
<li>数据在名称/值 对中</li>
<li>数据由括号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h3 id="Leetcode-68-Text-Justification"><a href="#Leetcode-68-Text-Justification" class="headerlink" title="Leetcode 68. Text Justification"></a>Leetcode 68. Text Justification</h3><p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line, Pad extra spaces ‘’ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<h4 id="Solution-23"><a href="#Solution-23" class="headerlink" title="Solution"></a>Solution</h4><p>这道题目其实满傻逼的….硬算，保持一个index， 每次长度超过L的时候停止， 处理这一行的情况。</p>
<p>注意两种情况：</p>
<ol>
<li>if last line(last==words.length) or the number of words in the line is 1(diff==0) 在这种情况下， 我们需要left-Justify： 添加单词， 添加单词之间的空格， 增加单词之后的空格使得长度为L；</li>
<li>通常情况： middle justify， 在这种情况下， 我们要使得单词之间的空格尽可能均匀， 如果还有空格多的话， 尽量放在左边， 也就是说前面的多放一个空格： 我们把多余的空格数量标记为r， if r&gt;0 我们在需要增加的空格数字加一， 否则直接就是当前空格数。当然， 这种情况下不允许出现最后一个单词之后还有空格。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; fullJustify(String[] words, int L)&#123;</span><br><span class="line">    List&lt;String&gt; lines= new ArrayList&lt;String&gt;();</span><br><span class="line">    int index=0;</span><br><span class="line">    while(index&lt;words.length)&#123;</span><br><span class="line">        int count= words[index].length();</span><br><span class="line">        int last= index+1;</span><br><span class="line">        while(last&lt;words.length)&#123;</span><br><span class="line">            if(words[last].length()+ count+1&gt; L) break;</span><br><span class="line">            count+=words[last].length()+1;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder builder= new StringBuilder();</span><br><span class="line">        int diff= last- index-1;</span><br><span class="line">        // if last line or number of words in the line is 1, left-justified</span><br><span class="line">        if(last==words.length || diff==0)&#123;</span><br><span class="line">            for(int i= index; i&lt;last; i++)&#123;</span><br><span class="line">                builder.append(words[i] +&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.deleteCharAt(builder.length()-1);</span><br><span class="line">            for(int i= builder.length(); i&lt;L; i++)&#123;</span><br><span class="line">                builder.append(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // middle justified</span><br><span class="line">            int spaces= (L- count)/diff;</span><br><span class="line">            int r=(L- count)% diff;</span><br><span class="line">            for(int i= index; i&lt;last; i++)&#123;</span><br><span class="line">                builder.append(words[i]);</span><br><span class="line">                if(i&lt;last-1)&#123;</span><br><span class="line">                    for(int j=0; j&lt;=(spaces+((i-index)&lt;r?1: 0)); j++)&#123;</span><br><span class="line">                        builder.append(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lines.add(builder.toString());</span><br><span class="line">        index= last;</span><br><span class="line">    &#125;</span><br><span class="line">    return lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MapReduce-入门"><a href="#MapReduce-入门" class="headerlink" title="MapReduce 入门"></a>MapReduce 入门</h3><p>给你很多String IDS， 然后用hadoop， mapreduce给这些String IDs assign long int numerical IDs</p>
<h3 id="Find-the-row-with-maximum-number-of-1s"><a href="#Find-the-row-with-maximum-number-of-1s" class="headerlink" title="Find the row with maximum number of 1s"></a>Find the row with maximum number of 1s</h3><p>Given a boolean 2D array, where each row is sorted. Find the row with the maximum number of 1s;</p>
<p>Actually, this is a problem like find the max number in a Array;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int rowWithMax1s(bool mat[R][C])</span><br><span class="line">&#123;</span><br><span class="line">    // Initialize first row as row with max 1s</span><br><span class="line">    int max_row_index = 0;</span><br><span class="line"> </span><br><span class="line">    // The function first() returns index of first 1 in row 0.</span><br><span class="line">    // Use this index to initialize the index of leftmost 1 seen so far</span><br><span class="line">    int j = first(mat[0], 0, C-1);</span><br><span class="line">    if (j == -1) // if 1 is not present in first row</span><br><span class="line">      j = C - 1;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // Move left until a 0 is found</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; mat[i][j] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">           j = j-1;  // Update the index of leftmost 1 seen so far</span><br><span class="line">           max_row_index = i;  // Update max_row_index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_row_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h3><p>There is a maze of size n*n. Tom is sitting at (0,0). Jerry is sitting in another cell(the position of Jerry is input). Then there are k pieces of cheese placed in k different cells(k&lt;=10). Sine cells are blocked while some are not. Tom can move to 4 cells at any point of time(left, right, top, down one position). Tom has to collect all the pieces of cheese and then reach to Jerry’s cell. You need to print the minimum no of steps to required to do so.</p>
<p><a href="https://ide.geeksforgeeks.org/TtAvXJ" target="_blank" rel="noopener">link</a></p>
<h3 id="Diamond"><a href="#Diamond" class="headerlink" title="Diamond"></a>Diamond</h3><p>Diamond Mine is your new favorite game. It;s map is represented as n*n matrix, and the value of each cell corresponds to some property of the map:</p>
<ul>
<li>A value&gt;=0 represent a path.</li>
<li>A value of 1 represents a diamond in a path that can be picked up by the player.</li>
<li>A value of -1 represents a wall;</li>
</ul>
<p>The basic rules for playing Diamond Mine are as follows:</p>
<ul>
<li>The player starts at (0,0) and reaches(n-1, n-1), by moving right or down through valid path cells;</li>
<li>After reaching (n-1, n-1), the player must travel to (0, 0) by moving left or up through valid path cells.</li>
<li>When passing through a path cell containing a diamond, the diamond is picked up. Once picked up, the cell becomes an empty path cell(meaning you cannot pick up the same diamond twice).</li>
<li>If there is no valid path between (0,0) and(n-1, n-1), then no diamonds can be collected.</li>
<li>A player wins the game by collecting the maximum number of diamonds possible when following the above rules.</li>
</ul>
<p>Output the largest number.</p>
<h4 id="格子取数问题"><a href="#格子取数问题" class="headerlink" title="格子取数问题"></a>格子取数问题</h4><p>有n*n个格子， 每个格子里有正数或者0， 从最左上角往最右下角走， 只能向下和向右， 一共走两次， 把所有经过的格子的数加起来， 求最大值SUM， 且两次如果经过同一个格子， 则最后总和SUM中该格子的计数只加一次。</p>
<p>初看到此题目， 因为要让每次走下来的路径和最大， 读者可能最初想到的思路是让每一次的路径都是最优的， 即不顾全局， 只看局部， 让第一次和第二次的路径都是最优。 但问题马上来了， 虽然局部最优， 但是全局却不一定是最优。</p>
<p>上面的题目其实就是我们说的格子取数问题；</p>
<p>DP解法：</p>
<ol>
<li><p>设计态： f(i, j, h, k);// 表示两条路同时走， 第一条路径走到（i, j）时， 第二条路走到(h, k)时的最大数字和；</p>
</li>
<li><p>初始状态： f(0, 0, 0, 0)=0; 最终状态： f(n, n, n, n);</p>
</li>
<li><p>状态转移方程： 当i==h &amp;&amp; j==k 时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j);</p>
<p>当两者不相同时， f(i, j, h, k)= max{f(i-1, j, h-1, k), f(i, j-1, h, k-1), f(i-1, j, h, k-1), f(i, j-1, h-1, k)}+ Arr(i, j)+ Arr(h, k);</p>
</li>
</ol>
<p>但是其实这里我们可以直接化解成三维的问题， 因为上面我们肯定满足 i+j==h+k, 所以我们可以直接步数+ 第一个人目前行数+ 第二个人目前行数进行解决。</p>
<h3 id="OfferUp-Sumologic-Quantcast-公司投递"><a href="#OfferUp-Sumologic-Quantcast-公司投递" class="headerlink" title="OfferUp. Sumologic, Quantcast 公司投递"></a>OfferUp. Sumologic, Quantcast 公司投递</h3><h3 id="K-Sorted-Array"><a href="#K-Sorted-Array" class="headerlink" title="K Sorted Array"></a>K Sorted Array</h3><p><a href="https://practice.geeksforgeeks.org/problems/k-sorted-array/0" target="_blank" rel="noopener">Link</a></p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>we can use Insertion Sort to sort the elements efficiently. Following is the code for standard Insertion Sort.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(int A[], int size)&#123;</span><br><span class="line">  int i, key, j;</span><br><span class="line">  for(i=1; i&lt;size; i++)&#123;</span><br><span class="line">    key= A[i];</span><br><span class="line">    j= i-1;</span><br><span class="line">    /**Move elements of A[0...i-1], that are greater than position ahead of their current position. This loop will run at most k times**/</span><br><span class="line">    while(j&gt;=0 &amp;&amp; A[j]&gt; key)&#123;</span><br><span class="line">      A[j+1]= A[j];</span><br><span class="line">      j= j-1;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+1]= key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The inner loop will run at most k times. To move every element to its correct place, at most k elements need to be moved, so over all complexity will be O(nk).</p>
<h4 id="Solution2-maintain-a-k-1-size-priorityQueue"><a href="#Solution2-maintain-a-k-1-size-priorityQueue" class="headerlink" title="Solution2: maintain a (k+1) size priorityQueue"></a>Solution2: maintain a (k+1) size priorityQueue</h4><h3 id="Is-this-a-tree"><a href="#Is-this-a-tree" class="headerlink" title="Is this a tree?"></a>Is this a tree?</h3><p>You are given a binary tree as a sequence of parent-child pairs. For example, the tree represented by the node pairs below:</p>
<p>(A, B) (A, C) (B, G) (C, H) (E, F) (B, D) (C, E)</p>
<p>…</p>
<p>This tree can be represented in a S-expression in multiple ways. The lexicographically smallest way of expressing this as follows:</p>
<p>(A(B(D)(G))(C(E(F))(H)))</p>
<p>We need to translate the node-pair representation into an S-expression(lexicographically smallest one), and report any errors that do not conform to the definition of a binary tree.</p>
<p>The list of errors with their codes is as follows:</p>
<ul>
<li>E1: More than 2 children</li>
<li>E2： Duplicate Edges</li>
<li>E3: Cycle present</li>
<li>E4: Multiple roots</li>
<li>E5: Any other error</li>
</ul>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuanRVVDd1aWhLZzQ/view" target="_blank" rel="noopener">link_1</a></p>
<p><a href="https://drive.google.com/file/d/0B-nAdA4wvauuOHVSMF9qMW5IZkk/view" target="_blank" rel="noopener">link_2</a></p>
<p>见下面的validTree我们已经对普通tree的方法进行了解决。</p>
<h3 id="Leetcode-261-Valid-Tree"><a href="#Leetcode-261-Valid-Tree" class="headerlink" title="Leetcode 261. Valid Tree"></a>Leetcode 261. Valid Tree</h3><p>三种做法各做一遍。</p>
<p>见 外部博文， 在graph中如何检测是否有圈存在。</p>
<h3 id="Binary-Search-找距离最近的数字。"><a href="#Binary-Search-找距离最近的数字。" class="headerlink" title="Binary Search 找距离最近的数字。"></a>Binary Search 找距离最近的数字。</h3><p>经典的题目；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    static int[] nums= new int[]&#123;1,2,3,4,5,8,12&#125;;</span><br><span class="line">    public static int getMinDiff(int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        while(lo&lt;= hi)&#123;</span><br><span class="line">            int mid= lo+(hi-lo)/2;</span><br><span class="line">            if(target&lt;=nums[mid])&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                lo = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;// the number before lo is smaller than target;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int target=10;</span><br><span class="line">        int idx= getMinDiff(target);</span><br><span class="line">        if(idx==0)&#123;</span><br><span class="line">            System.out.println(Math.abs(nums[idx]-target));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Math.min(Math.abs(nums[idx]-target), Math.abs(nums[idx-1]-target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；"><a href="#flatten-list-但是还有一个变量-shallow来控制flat多少层，比如shallow时false就全都flat，-是true就只flat第一层-1-2-3-4-–-gt-1-2-3-4-follow-up-是不让用递归，-用stack-；" class="headerlink" title="flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；"></a>flatten list(但是还有一个变量 shallow来控制flat多少层，比如shallow时false就全都flat， 是true就只flat第一层[1,[2, 3, 4]]–&gt;[1,2,[3,4]], follow up 是不让用递归， 用stack)；</h3><p>所以如果shallow的话，我们在碰到第一层的时候直接将该层里面的元素输出就好了， 这个时候就能够不用递归或者stack进行解决， 如果是要将所有的都进行flatten的话：</p>
<ol>
<li>递归</li>
<li>Stack， 从后往前进行存储</li>
</ol>
<p>可以借助instance of 来判断遇到的Object 是 Integer or List。</p>
<p>相关问题：</p>
<h4 id="leetcode-341-Flatten-Nested-List-Iterator"><a href="#leetcode-341-Flatten-Nested-List-Iterator" class="headerlink" title="leetcode 341. Flatten Nested List Iterator"></a>leetcode 341. Flatten Nested List Iterator</h4><p>这道题直接利用一个辅助的结构去进行存储就好了， 这里我们选用stack， 每次查看stack最上面的一个元素去进行取next；</p>
<h4 id="leetcode-251-Flatten-2D-vector"><a href="#leetcode-251-Flatten-2D-vector" class="headerlink" title="leetcode 251 Flatten 2D vector"></a>leetcode 251 Flatten 2D vector</h4><p>对于251 这里我们来一个比较具有启发性的答案：</p>
<p>Q:</p>
<p>Implement an iterator to flatten a 2d vector.</p>
<p>For example, Given 2d vector=[[1,2], [3], [4,5,6]];</p>
<p>By calling next repeatedly until hasNext returns false. the order of elements returned by next should be [1,2,3,4,5,6];</p>
<p>Follow up:</p>
<p>As an added challenge, try to code it using only iterators in Java</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Vector2D implements Iterator&lt;Integer&gt;&#123;</span><br><span class="line">  Iterator&lt;List&lt;Integer&gt;&gt; itrs;</span><br><span class="line">  Iterator&lt;Integer&gt; row;</span><br><span class="line">  public Vector 2D(List&lt;List&lt;Integer&gt;&gt; vec2d)&#123;</span><br><span class="line">    if(vec2d==null || vec2d.size()==0) return;</span><br><span class="line">    itrs= vec2d.iterator();</span><br><span class="line">    row= itrs.next().iterator();</span><br><span class="line">    getNextRow();</span><br><span class="line">  &#125;</span><br><span class="line">  private void getNextRow()&#123;</span><br><span class="line">    while(!row.hasNext() &amp;&amp; itrs.hasNext()) row= itrs.next().iterator();</span><br><span class="line">  &#125;</span><br><span class="line">  @ Override</span><br><span class="line">  public Integer next()&#123;</span><br><span class="line">    int next= row.next();</span><br><span class="line">    getNextRow();</span><br><span class="line">    return next;</span><br><span class="line">  &#125;</span><br><span class="line">  @ Override</span><br><span class="line">  public boolean hasNext()&#123;</span><br><span class="line">    return row!=null&amp;&amp; row.hasNext();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class NestedIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        System.out.println(flatten_recurrsive(nestedList));</span><br><span class="line">        for(int i = nestedList.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            stack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">        Stack&lt;NestedInteger&gt; newStack= new Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= nestedList.size()-1; i&gt;=0; i--)&#123;</span><br><span class="line">            newStack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        while(!newStack.isEmpty())&#123;</span><br><span class="line">            if(newStack.peek().isInteger())&#123;</span><br><span class="line">                res.add(newStack.pop().getInteger());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;NestedInteger&gt; curr=newStack.pop().getList();</span><br><span class="line">            for(int i=curr.size()-1; i&gt;=0; i--)&#123;</span><br><span class="line">                newStack.push(curr.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; flatten_recurrsive(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(NestedInteger e: nestedList)&#123;</span><br><span class="line">            if(e.isInteger())&#123;</span><br><span class="line">                res.add(e.getInteger());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.addAll(flatten_recurrsive(e.getList()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer next() &#123;</span><br><span class="line">        return stack.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        while(!stack.isEmpty()) &#123;</span><br><span class="line">            NestedInteger curr = stack.peek();</span><br><span class="line">            if(curr.isInteger()) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">            for(int i = curr.getList().size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                stack.push(curr.getList().get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Leetcode-385-Mini-Parser"><a href="#Leetcode-385-Mini-Parser" class="headerlink" title="Leetcode 385. Mini Parser"></a>Leetcode 385. Mini Parser</h4><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list– whose elements may also be integers or other lists.</p>
<p>很愚蠢并且很容易错的一道题目：</p>
<p>自己写的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public NestedInteger deserialize(String s) &#123;</span><br><span class="line">        // categorized with [  and without [</span><br><span class="line">        if(s.charAt(0)!=&apos;[&apos;)&#123;</span><br><span class="line">            return new NestedInteger(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">        //s= s.substring(1, s.length()-1);</span><br><span class="line">        NestedInteger res= new NestedInteger();</span><br><span class="line">        int index=1;</span><br><span class="line">        while(index&lt;s.length()-1)&#123;</span><br><span class="line">            char ch= s.charAt(index);</span><br><span class="line">            if(ch==&apos;[&apos;)&#123;</span><br><span class="line">                int count=0;</span><br><span class="line">                int start= index;</span><br><span class="line">                while(index&lt;s.length()-1)&#123;</span><br><span class="line">                    if(s.charAt(index)==&apos;[&apos;) count++;</span><br><span class="line">                    if(s.charAt(index)==&apos;]&apos;) count--;</span><br><span class="line">                    index++;</span><br><span class="line">                    if(count==0)&#123;</span><br><span class="line">                        res.add(deserialize(s.substring(start, index)));</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(Character.isDigit(ch) || ch==&apos;-&apos;)&#123;</span><br><span class="line">                int sign=1;</span><br><span class="line">                if(ch==&apos;-&apos;)&#123;</span><br><span class="line">                    sign=-1;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder sb= new StringBuilder();</span><br><span class="line">                while(index&lt;s.length()-1 &amp;&amp; Character.isDigit(s.charAt(index)))&#123;</span><br><span class="line">                    sb.append(s.charAt(index));</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(new NestedInteger(Integer.valueOf(sb.toString())*(sign)));</span><br><span class="line">            &#125;else if(ch==&apos;,&apos;)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别人的想法：</p>
<ol>
<li>If encounters ‘[‘, push current NestedInteger to stack and start a new one.</li>
<li>If encounters ‘]’, end current NestedInteger and pop a NestedInteger from stack to continue;</li>
<li>If encounters ‘,’, append a new number to curr NestedInteger, if this comma is not right after a brackets.</li>
<li>Update index l and r, where I shall point to the start of a integer substring, while r shall points to the end+1 of substring;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public NestedInteger deserialize(String s) &#123;</span><br><span class="line">        if(s.isEmpty()) return null;</span><br><span class="line">        if(s.charAt(0)!=&apos;[&apos;) return new NestedInteger(Integer.valueOf(s));</span><br><span class="line">        Stack&lt;NestedInteger&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        NestedInteger curr= null;</span><br><span class="line">        int l=0;</span><br><span class="line">        for(int r=0; r&lt;s.length(); r++)&#123;</span><br><span class="line">            char ch= s.charAt(r);</span><br><span class="line">            if(ch==&apos;[&apos;)&#123;</span><br><span class="line">                if(curr!= null)&#123;</span><br><span class="line">                    stack.push(curr);</span><br><span class="line">                &#125;</span><br><span class="line">                curr= new NestedInteger();</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;else if(ch==&apos;]&apos;)&#123;</span><br><span class="line">                String num= s.substring(l, r);</span><br><span class="line">                if(!num.isEmpty()) curr.add(new NestedInteger(Integer.valueOf(num)));</span><br><span class="line">                if(!stack.isEmpty())&#123;</span><br><span class="line">                    NestedInteger pop= stack.pop();</span><br><span class="line">                    pop.add(curr);</span><br><span class="line">                    curr= pop;</span><br><span class="line">                &#125;</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;else if(ch==&apos;,&apos;)&#123;</span><br><span class="line">                if(s.charAt(r-1)!= &apos;]&apos;)&#123;</span><br><span class="line">                    String num= s.substring(l, r);</span><br><span class="line">                    curr.add(new NestedInteger(Integer.valueOf(num)));</span><br><span class="line">                &#125;</span><br><span class="line">                l= r+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Find-the-intersection-of-two-lists"><a href="#Find-the-intersection-of-two-lists" class="headerlink" title="Find the intersection of two lists"></a>Find the intersection of two lists</h3><p>这道题目有两种做法， 第一种找到各条链的长度， 然后使用快慢指针。这里主要是第二种做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    ListNode nodeA= headA;</span><br><span class="line">    ListNode nodeB= headB;</span><br><span class="line">    while(nodeA!= nodeB)&#123;</span><br><span class="line">        nodeA= (nodeA==null)?headB: nodeA.next;</span><br><span class="line">        nodeB= (nodeB==null)?headA: nodeB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodeA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要要注意的一点就是对于null的处理， 如果两者不相交的话，会出现什么情况， 所以这里我们让nodeA和nodeB再取一次null来消除这种情况， 也就是说nodeA==null 的时候， 我们再进行第二次遍历。</p>
<h3 id="Abstract-class-interface-and-threading-issues"><a href="#Abstract-class-interface-and-threading-issues" class="headerlink" title="Abstract class, interface and threading issues."></a>Abstract class, interface and threading issues.</h3><p>concurrent issues.</p>
<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><h3 id="More-about-drawbridge"><a href="#More-about-drawbridge" class="headerlink" title="More about drawbridge"></a>More about drawbridge</h3><p>1st round phone interview: write a function that finds substrings that contains only consecutive repeating characters and return a list of characters that form the substrings. For example, input “thiisiissaa”, returns i i s a, input “thiiissisa” returns i, input “abcde” returns a b c d e.<br>There were three rounds of interview in the 2-hour skype interview that followed the initial phone interview. 1st round, given an unsorted array of integers, sort the array such that the numbers in it form the largest possible number, for example, given [3, 30, 9, 14, 1], the array should be sorted into [9, 3, 30, 14, 1] because 9330141 is the largest number you can form from the numbers in the array. 2nd round, implement a queue using an array. 3rd round, given a list of cities, each city has a population value, write a function that returns a city in the input list. The probability of returning a specific city should be proportional to the population of the city. For example, if the list contains city1 with 15 pop value and city2 with 5 pop value, then if you call the function 4 times, on average it should return city1 for 3 times and city2 once.</p>
<h3 id="Knight’s-travel"><a href="#Knight’s-travel" class="headerlink" title="Knight’s travel"></a>Knight’s travel</h3><h3 id="Leetcode-Frog-Jump"><a href="#Leetcode-Frog-Jump" class="headerlink" title="Leetcode Frog Jump"></a>Leetcode Frog Jump</h3><p>比较straightforward的做法：</p>
<p>利用map记录每个stone上面能跳的jump；</p>
<p>DFS-Version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canCross(int[] stones) &#123;</span><br><span class="line">        if (stones.length == 0) return false;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; stones.length; i++) &#123;</span><br><span class="line">            if (stones[i] - stones[i - 1] &gt; i) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(set, 0, 0, stones[stones.length - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean helper(Set&lt;Integer&gt; set, int step, int currStone, int lastStone) &#123;</span><br><span class="line">        if (currStone == lastStone) return true;</span><br><span class="line">        for (int i = step + 1; i &gt;= Math.max(1, step - 1); i--) &#123;</span><br><span class="line">            if (set.contains(currStone + i) &amp;&amp; helper(set, i, currStone + i, lastStone))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map-Version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canCross(int[] stones) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        map.put(0, new HashSet&lt;Integer&gt;());</span><br><span class="line">        map.get(0).add(1);</span><br><span class="line">        for(int i=0; i&lt;stones.length; i++)&#123;</span><br><span class="line">            if(map.containsKey(stones[i]))&#123;</span><br><span class="line">                for(int step: map.get(stones[i]))&#123;</span><br><span class="line">                    int next= step+ stones[i];</span><br><span class="line">                    if(next== stones[stones.length-1]) return true;</span><br><span class="line">                    if(!map.containsKey(next))&#123;</span><br><span class="line">                        map.put(next, new HashSet&lt;Integer&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.get(next).add(step+1);</span><br><span class="line">                    if(step-1&gt;0) map.get(next).add(step-1);</span><br><span class="line">                    map.get(next).add(step);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jump-Game-I-amp-amp-II"><a href="#Jump-Game-I-amp-amp-II" class="headerlink" title="Jump Game I &amp;&amp; II"></a>Jump Game I &amp;&amp; II</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>Solution:</p>
<p>这道题我们可以用bfs去解决， 每一次跳相当于从上一层跳到下一层， 每次我们遍历完上一层， 下一层的currentMax也就确定了， 直到遍历到尽头， 得到层数， 就是我们要的答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0 || nums.length==1) return 0;</span><br><span class="line">    int currentMax=0;</span><br><span class="line">    int nextMax=0;</span><br><span class="line">    int index=0;</span><br><span class="line">    int level=0;</span><br><span class="line">    while(index&lt;=currentMax)&#123;//  traversal the current </span><br><span class="line">        level++;</span><br><span class="line">        while(index&lt;= currentMax)&#123;</span><br><span class="line">            nextMax= Math.max(nextMax, index+ nums[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        currentMax=nextMax;</span><br><span class="line">        if(currentMax&gt;=nums.length-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] A)&#123;</span><br><span class="line">    // 每次到上一层的尽头， 下一层的尽头也就确定了： e: previous Max, max: current Max;</span><br><span class="line">    int sc=0;</span><br><span class="line">    int e=0;</span><br><span class="line">    int max=0;</span><br><span class="line">    for(int i=0; i&lt;A.length-1; i++)&#123;</span><br><span class="line">        max= Math.max(max, i+ A[i]);</span><br><span class="line">        if(i==e)&#123;</span><br><span class="line">            sc++;</span><br><span class="line">            e= max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>follow-up: how to find the path</p>
<p>解决路径问题的话， 大概就是找到每一层能跳到max的就好了， 找到这样的元素， 我们也就找到了一条路径， 实际上这样的路径应该有很多条（每一层的元素数量相乘）。</p>
<h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a>Verify Preorder Serialization of a Binary Tree</h3><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSerialization(String preorder) &#123;</span><br><span class="line">        String[] nodes= preorder.split(&quot;,&quot;);</span><br><span class="line">        Stack&lt;String&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        for(String node: nodes)&#123;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;) &amp;&amp; node.equals(&quot;#&quot;))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                if(stack.isEmpty()) return false;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.size()==1 &amp;&amp; stack.peek().equals(&quot;#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h3 id="Check-whether-a-given-array-is-a-k-sorted-array-or-not"><a href="#Check-whether-a-given-array-is-a-k-sorted-array-or-not" class="headerlink" title="Check whether a given array is a k sorted array or not."></a>Check whether a given array is a k sorted array or not.</h3><p>Given an array of n distinct elements, Check whether the given array is a k sorted array or not. A k sorted array is an array where each element is at most k distance away from its target position in the sorted array;</p>
<p>For example, let us consider k is 2, an element at index 7 in the sorted array, can be indexes 5, 6, 7, 8,9 in the given array;</p>
<p>这道题目的做法很straight forward， 我们可以直接排序， 然后寻找原来的顺序就好了， 我们着重要讲的是是下面这个问题：</p>
<p>如何在O(n logk)时间内将k sorted array进行排序。</p>
<p>We can sort such arrays more efficiently with the help of Heap data structure.</p>
<ol>
<li>Create a Min Heap of size k+1 with first k+1 elements. This will take O(k) time;</li>
<li>One by one remove min element from heap, put it in the result array, and add a new element to heap from remaining elements.</li>
</ol>
<p>Basically we keep a window of k+1 elements in a minHeap as any element is at most k distance away from the target position. So if an element is the smallest of the group then we extract the element for the window.</p>
<p>The fact： smallest element(first element of sorted out o/p) will always be in first K+1 elements as it can only move k places away from its original position and of course it will be the root element of minheap.</p>
<h3 id="如何计算数据的方差"><a href="#如何计算数据的方差" class="headerlink" title="如何计算数据的方差"></a>如何计算数据的方差</h3><p>有variable A, B, 问A和B的方差是否等于Var(A)+Var(B)<br>如果A, B是独立的就相等，要不不相等</p>
<h3 id="很多数，-找到k个最大的数，-stream操作。"><a href="#很多数，-找到k个最大的数，-stream操作。" class="headerlink" title="很多数， 找到k个最大的数， stream操作。"></a>很多数， 找到k个最大的数， stream操作。</h3><h3 id="很大个文本如何应用mapreduce，-找到anagram"><a href="#很大个文本如何应用mapreduce，-找到anagram" class="headerlink" title="很大个文本如何应用mapreduce， 找到anagram"></a>很大个文本如何应用mapreduce， 找到anagram</h3><h3 id="mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。"><a href="#mapreduce-10-个reducer，-99个跑的正常，-但是如果有一个跑的比较慢，-是怎么回事。" class="headerlink" title="mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。"></a>mapreduce 10 个reducer， 99个跑的正常， 但是如果有一个跑的比较慢， 是怎么回事。</h3><p>Maybe the data is skew.</p>
<p>reduce执行很慢的一个原因是数据分桶不均导致个别reduce节点的数据量远大于其他节点。 解决方案是检查分桶是否混匀， 如果不均匀考虑使用自定义的Partitioner(使用IntHashPartitioner/MapintPartitioner) 可以根据int前缀/后缀决定分到哪个桶， 如果均匀考虑单个reduce的数据里是否过大， 如果单个reduce的数据量过大则应该考虑增加reduce的量。</p>
<p>哪个key到哪个Reducer的分配过程， 是由Partitioner规定的， 它只有一个办法， 输入的是Map的结果对和reducer的数目， 输出则是分配的Reducer。 就是指定Mapper输出的键值对到哪一个reducer上去， 这样保证如果由相同的key值， 肯定被分配到同一个reducer上。 如果有N个reducer， 编号就是0，1，2，3…(N-1)</p>
<h3 id="public-static-void-main-String-args-为啥要用static。"><a href="#public-static-void-main-String-args-为啥要用static。" class="headerlink" title="public static void main (String[] args) 为啥要用static。"></a>public static void main (String[] args) 为啥要用static。</h3><p>正因为main 方法是静态的， JVM调用这个方法就不需要创建任何包含这个main方法的实例。如果JVM就没法确定调用哪个main方法。</p>
<p>静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的， 那么它就会被加载到JVM上下文成为可执行的方法。</p>
<p>如果JVM找不到main方法就会抛出 NoSuchMethodError：main异常。</p>
<p>main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</p>
<h3 id="如果不用static-是否能够通过？"><a href="#如果不用static-是否能够通过？" class="headerlink" title="如果不用static 是否能够通过？"></a>如果不用static 是否能够通过？</h3><p>编译能过， 但是不能运行。</p>
<h3 id="最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。"><a href="#最长上升子序列，-可能存在相等的情况，-要求写出nlogn的方法。" class="headerlink" title="最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。"></a>最长上升子序列， 可能存在相等的情况， 要求写出nlogn的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            int idx= binarySearch(list, nums[i]);</span><br><span class="line">            if(idx&lt;list.size())&#123;</span><br><span class="line">                list.set(idx, nums[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    public int binarySearch(List&lt;Integer&gt; nums, int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= nums.size()-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid=(lo+hi)/2;</span><br><span class="line">            if(nums.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java-heap和stack都分别存什么"><a href="#Java-heap和stack都分别存什么" class="headerlink" title="Java heap和stack都分别存什么"></a>Java heap和stack都分别存什么</h3><p><a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java Heap Space vs Stack- Memory Allocation in Java</a></p>
<h4 id="Java-Heap-Space"><a href="#Java-Heap-Space" class="headerlink" title="Java Heap Space"></a>Java Heap Space</h4><ol>
<li>Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.</li>
<li>Garbage Collection runs on the heap memory to free the memory used by objects that doesn’t have any reference. Any object created in the heap has global access and can be referenced from anywhere of the application.</li>
</ol>
<h4 id="Java-Stack-Memory"><a href="#Java-Stack-Memory" class="headerlink" title="Java Stack Memory"></a>Java Stack Memory</h4><ol>
<li>Java Stack memory is used for execution of a thread. They contain method specific values that are short lived and references to other objects in the heap that are getting referred from the method.</li>
<li>Stack memory is always referenced in LIFO order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.</li>
<li>As soon as method ends, the block becomes unused and become available for next method.</li>
<li>Stack memory size is very less compared to Heap memory.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.test;</span><br><span class="line"></span><br><span class="line">public class Memory &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123; // Line 1</span><br><span class="line">		int i=1; // Line 2</span><br><span class="line">		Object obj = new Object(); // Line 3</span><br><span class="line">		Memory mem = new Memory(); // Line 4</span><br><span class="line">		mem.foo(obj); // Line 5</span><br><span class="line">	&#125; // Line 9</span><br><span class="line"></span><br><span class="line">	private void foo(Object param) &#123; // Line 6</span><br><span class="line">		String str = param.toString(); //// Line 7</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125; // Line 8</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Below image shows the stack and heap memory with reference to above program and how they are being used to store primitive, Objects and reference variables.</p>
<p><a href="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png" target="_blank" rel="noopener"><img src="http://lic128.me/2017/11/20/Algorithm-Part1/OOD-Algorithm/Java-Heap-Stack-Memory.png" alt="img"></a></p>
<p>Let’s go through the steps of execution of the program.</p>
<ul>
<li>As soon as we run the program, it loads all the Runtime classes into the Heap space. When main() method is found at line 1, Java Runtime creates stack memory to be used by main() method thread.</li>
<li>We are creating primitive local variable at line 2, so it’s created and stored in the stack memory of main() method.</li>
<li>Since we are creating an Object in line 3, it’s created in Heap memory and stack memory contains the reference for it. Similar process occurs when we create Memory object in line 4.</li>
<li>Now when we call foo() method in line 5, a block in the top of the stack is created to be used by foo() method. Since Java is pass by value, a new reference to Object is created in the foo() stack block in line 6.</li>
<li>A string is created in line 7, it goes in the <a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">String Pool</a> in the heap space and a reference is created in the foo() stack space for it.</li>
<li>foo() method is terminated in line 8, at this time memory block allocated for foo() in stack becomes free.</li>
<li>In line 9, main() method terminates and the stack memory created for main() method is destroyed. Also the program ends at this line, hence Java Runtime frees all the memory and end the execution of the program.</li>
</ul>
<h3 id="Difference-between-Java-Heap-Space-and-Stack-Memory"><a href="#Difference-between-Java-Heap-Space-and-Stack-Memory" class="headerlink" title="Difference between Java Heap Space and Stack Memory"></a>Difference between Java Heap Space and Stack Memory</h3><p>Based on the above explanations, we can easily conclude following differences between Heap and Stack memory.</p>
<ol>
<li>Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.</li>
<li>Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.</li>
<li>Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.</li>
<li>Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at <a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">Java Garbage Collection</a>.</li>
<li>Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.</li>
<li>We can use <strong>-Xms</strong> and <strong>-Xmx</strong> JVM option to define the startup size and maximum size of heap memory. We can use <strong>-Xss</strong> to define the stack memory size.</li>
<li>When stack memory is full, Java runtime throws <code>java.lang.StackOverFlowError</code> whereas if heap memory is full, it throws <code>java.lang.OutOfMemoryError: Java Heap Space</code> error.</li>
<li>Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.</li>
</ol>
<p>That’s all for <strong>Java Heap Space vs Stack Memory</strong> in terms of java application, I hope it will clear your doubts regarding memory allocation when any java program is executed.</p>
<p>Static methods(in fact all methods) as well as static variables are stored in the PermGen section of the heap, since they are part of the reflection data(class related data, not instance related).</p>
<p>Note that only the variables and their technical values(primitives and references) are stored in PermGen space.</p>
<p>If your static variable is a reference to an object that object itself is stored in the normal sections of the heap. Those objects(unless they are internal objects like classes etc.) are not stored in PermGen space.</p>
<h3 id="SQL有几种join，-join的内部实现，-sql-index内部实现。"><a href="#SQL有几种join，-join的内部实现，-sql-index内部实现。" class="headerlink" title="SQL有几种join， join的内部实现， sql index内部实现。"></a>SQL有几种join， join的内部实现， sql index内部实现。</h3><p>SQL有inner join， left join， right join, full outer join 各种join</p>
<p>Or natural join and theta join;</p>
<p>总的来说， 四种JOIN的使用/区别可以描述为：</p>
<ol>
<li>left join 会从左表那里返回所有的记录， 即使在右表中没有匹配的行。</li>
<li>right outer join右连接， 返回右表中的所有记录， 即使在做表中没有记录与它匹配。</li>
<li>full outer join 全连接， 返回左右表中的所有记录。</li>
<li>在表中存在至少一个匹配时， inner join返回行。 关键字inner 可省略。</li>
</ol>
<p>join 的内部实现(重要的技巧: external sort)：</p>
<ol>
<li><p>Three primary techniques:</p>
<p>Sorting， Hashing， Indexing；</p>
</li>
<li><p>Three degrees of difficulty:</p>
<p>data small enough to fit in memory</p>
<p>too large to fit in main memory but small enough to be handled by a two-pass algorithm</p>
</li>
</ol>
<p>Iteration Join: conceptually- without taking into account disk block issues.</p>
<p>Merge join: Sort the two table and using merge sort;</p>
<p>Join with index: Using index;</p>
<p>Hash join: hash R1 tuples into G buckets, hash R2 tuples into H buckets and match every bucket;</p>
<h3 id="What’s-the-difference-between-B-Tree-and-B-Tree"><a href="#What’s-the-difference-between-B-Tree-and-B-Tree" class="headerlink" title="What’s the difference between B Tree and B+ Tree."></a>What’s the difference between B Tree and B+ Tree.</h3><p>In a b- tree you can store both keys and data in the internal and leaf nodes, but in a b+ tree you have to store the data in the leaf nodes only;</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys(not pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<p>Advantages of B+ trees:</p>
<ul>
<li>Because B+ tree don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.</li>
<li>The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.</li>
</ul>
<p>Advantage of B trees:</p>
<ul>
<li>Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.</li>
</ul>
<p><a href="https://i.stack.imgur.com/l6UyF.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/l6UyF.png" alt="B and B+ tree"></a></p>
<p>The principal advantage of B+ trees over B trees is they allow you to pack in more pointers to other nodes by removing pointers to data, thus increasing the fanout and potentially decreasing the depth of the tree.The disadvantage is that there are no early outs when you might have found a match in an internal node. But since both data structures have huge fanouts, the vast majority of your matches will be on leaf nodes anyway, making on average the B+ tree more efficient.</p>
<h3 id="Overfitting-如何处理"><a href="#Overfitting-如何处理" class="headerlink" title="Overfitting 如何处理"></a>Overfitting 如何处理</h3><p>Overfitting is that your model get good result on your training data, but can not generalize to the usual data set.</p>
<p>过度拟合的模型往往不能进行一般化推广。</p>
<ol>
<li>Cross Validation</li>
<li>Train with more data</li>
<li>Remove features.</li>
<li>Early Stopping</li>
<li>Regularization</li>
</ol>
<h3 id="count-min-sketch-数据结构"><a href="#count-min-sketch-数据结构" class="headerlink" title="count-min-sketch 数据结构"></a>count-min-sketch 数据结构</h3><p>Ref: 系统设计</p>
<p>主要的意思就是使用 bloom fliter来记录每个元素出现的频率， 然后以频率来代替次数。</p>
<h3 id="A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。"><a href="#A-B-C-都跟ebay竞价，-返回的是second-largest-price，-对于竞价最高的，-设计一种策略，-是否欺骗它。" class="headerlink" title="A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。"></a>A, B, C 都跟ebay竞价， 返回的是second largest price， 对于竞价最高的， 设计一种策略， 是否欺骗它。</h3><p>一个auction无限轮，A，B，C参加bid，一个operator宣布结果，赢者付其他竞价中的最高值（即第二高bid），但是operator可以作假报高价，BC want to get high profit, 给出A可以用什么策略发现A作假</p>
<h3 id="cc-150上-4-8-subtree那道题"><a href="#cc-150上-4-8-subtree那道题" class="headerlink" title="cc 150上 4.8 subtree那道题"></a>cc 150上 4.8 subtree那道题</h3><p>You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to that value. note that it can be any path in the tree– it does not have to start at the root.</p>
<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>Lets’s approach this problem by simplifying it. What if the path had to start at the root?</p>
<p>对于这道题， 其实我们可以采用 leetcode 437的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        map.put(0, 1);</span><br><span class="line">        backTrack(root, sum, map, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTrack(TreeNode root, int target, Map&lt;Integer, Integer&gt; map, int sum)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        if(map.containsKey(sum-target))&#123;</span><br><span class="line">            res+=map.get(sum-target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(sum, map.getOrDefault(sum, 0)+1);</span><br><span class="line">        backTrack(root.left, target, map, sum);</span><br><span class="line">        backTrack(root.right, target, map, sum);</span><br><span class="line">        map.put(sum, map.get(sum)-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        findSum(root, sum, new ArrayList&lt;&gt;(), 0);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        pathSum(root, sum, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void pathSum(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        findPath(root, sum,0, new ArrayList&lt;&gt;(), res);</span><br><span class="line">        pathSum(root.left, sum, res);</span><br><span class="line">        pathSum(root.right, sum, res);</span><br><span class="line">    &#125;</span><br><span class="line">    // if the path was not restricted to the from root to leaf;</span><br><span class="line">    public void findPath(TreeNode root, int target, int sum,  List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        if(sum== target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        findPath(root.left, target, sum, path, res);</span><br><span class="line">        findPath(root.right, target, sum, path, res);</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    // what if we just want to print the path;</span><br><span class="line">    public void findSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; unit, int level)&#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        int tmp= sum;</span><br><span class="line">        unit.add(root.val);</span><br><span class="line">        for(int i=level; i&gt;-1; i--)&#123;</span><br><span class="line">            tmp-= unit.get(i);</span><br><span class="line">            if(tmp==0) print(unit, i, level);</span><br><span class="line">        &#125;</span><br><span class="line">        findSum(root.left, sum, unit, level+1);</span><br><span class="line">        findSum(root.right, sum, unit, level+1);</span><br><span class="line">        unit.remove(unit.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    void print(ArrayList&lt;Integer&gt; buffer, int level, int i2)&#123;</span><br><span class="line">        for(int i= level; i&lt;= i2; i++)&#123;</span><br><span class="line">            System.out.print(buffer.get(i)+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode：-Largest-Number"><a href="#Leetcode：-Largest-Number" class="headerlink" title="Leetcode： Largest Number"></a>Leetcode： Largest Number</h3><p>这道题目只需要实现一个Comparator就可以了。</p>
<h3 id="SQL刷题。"><a href="#SQL刷题。" class="headerlink" title="SQL刷题。"></a>SQL刷题。</h3><h3 id="Move-zeros"><a href="#Move-zeros" class="headerlink" title="Move zeros"></a>Move zeros</h3><p>input: [0,2,0,-3,5,7,9,0,7,0]<br>output: [2,-3,5,7,9,7,0,0,0,0]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int index=0;</span><br><span class="line">        while(index&lt; nums.length)&#123;</span><br><span class="line">            if(nums[index]!=0)&#123;</span><br><span class="line">                swap(nums, index, start);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int temp= nums[i];</span><br><span class="line">        nums[i]= nums[j];</span><br><span class="line">        nums[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones"><a href="#From-a-list-of-integer-intervals-write-a-function-to-minimize-the-number-of-overlapping-or-consecutive-ones" class="headerlink" title="From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones."></a>From a list of integer intervals, write a function to minimize the number of overlapping or consecutive ones.</h3><p>Test Input: [4, 8], [3, 5], [-1 2], [10, 12]</p>
<p>Test output: [-1, 8], [10,12]</p>
<p>Merge Intervals;</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>三个table, salesman， customer，orders</p>
<p>a. The names of all sales people that have an order with Panasung(one customer’s name).</p>
<p>b. The names of salespeople that have 2 or more orders.</p>
<p>Select salespeople.name from orders group by name having count(*)&gt;=2</p>
<h3 id="strstr变形"><a href="#strstr变形" class="headerlink" title="strstr变形"></a>strstr变形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle)&#123;</span><br><span class="line">  if(needle.length()==0) return 0;</span><br><span class="line">  if(haystack.length()==0) reuturn -1;</span><br><span class="line">  int index=0;</span><br><span class="line">  while(index+needle.length()&lt;= haystack.length())&#123;</span><br><span class="line">    int i= index;</span><br><span class="line">    int j=0;</span><br><span class="line">    while(haystack.charAt(i)== needle.charAt(j))&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">      if(j== needle.length()) return index;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="merge-two-BST"><a href="#merge-two-BST" class="headerlink" title="merge two BST"></a>merge two BST</h3><h3 id="group-anagram"><a href="#group-anagram" class="headerlink" title="group anagram"></a>group anagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(String str: strs)&#123;</span><br><span class="line">            String s= hashStr(str);</span><br><span class="line">            if(!map.containsKey(s))&#123;</span><br><span class="line">                map.put(s, new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        for(List&lt;String&gt; list: map.values())&#123;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public String hashStr(String str)&#123;</span><br><span class="line">        char[] ch=str.toCharArray();</span><br><span class="line">        Arrays.sort(ch);</span><br><span class="line">        StringBuilder sb= new StringBuilder();</span><br><span class="line">        for(char c: ch)&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级"><a href="#给定一个整数N-一个整数array，-问把这个array里数字的倍数从1-N去除，-剩下几个数字，N可能会有-10-9-量级" class="headerlink" title="给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级"></a>给定一个整数N,一个整数array， 问把这个array里数字的倍数从1~N去除， 剩下几个数字，N可能会有 10^9 量级</h3><p>感觉可能要使用和之前质数一样的方式去进行计算。</p>
<p>Maybe we should use the inclusion-exclusion principle to calculate;</p>
<h3 id="two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？"><a href="#two-datasetAB-together，have-a-prediction-model，test-AB，then-A-always-over-predicted，-B-always-under-predicted，-why？" class="headerlink" title="two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？"></a>two datasetAB together，have a prediction model，test AB，then A always over predicted， B always under predicted， why？</h3><ol>
<li>maybe we ignore some feature, since there may be some feature in A, and no such feature in B, and the model is based on the existence of feature.</li>
<li>Shuffle the dataset A and B. and check if it is still the case.</li>
</ol>
<h3 id="use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego"><a href="#use-subset-of-string-to-generate-word-in-dict，例子-ogeg，-dict［go，ego-gap-dog］-gt-go-ego" class="headerlink" title="use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]"></a>use subset of string to generate word in dict，例子 ogeg， dict［go，ego, gap, dog］=&gt; [go, ego]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class subsetCheck &#123;</span><br><span class="line">    public static List&lt;String&gt; getList(Set&lt;String&gt; dict, String s)&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(String word: dict)&#123;</span><br><span class="line">            if(check(word, map))&#123;</span><br><span class="line">                res.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean check(String s, Map&lt;Character, Integer&gt; map)&#123;</span><br><span class="line">        boolean flag= true;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)-1);</span><br><span class="line">            if(map.get(s.charAt(i))&lt;0) flag= false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i), 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        HashSet&lt;String&gt; dict= new HashSet&lt;&gt;();</span><br><span class="line">        dict.add(&quot;go&quot;);</span><br><span class="line">        dict.add(&quot;ego&quot;);</span><br><span class="line">        dict.add(&quot;gap&quot;);</span><br><span class="line">        dict.add(&quot;dog&quot;);</span><br><span class="line">        String word=&quot;ogeg&quot;;</span><br><span class="line">        System.out.println(getList(dict, word));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash-IP-address"><a href="#hash-IP-address" class="headerlink" title="hash IP address"></a>hash IP address</h3><p>input String=&gt; long int</p>
<p>String: 123.39.255.0</p>
<h3 id="Partition-Array"><a href="#Partition-Array" class="headerlink" title="Partition Array"></a>Partition Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class kthLargest &#123;</span><br><span class="line">    public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        k= nums.length-k;</span><br><span class="line">        int hi= nums.length-1;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= partition(nums, lo, hi);</span><br><span class="line">            if(mid&lt;k)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(mid==k) return nums[mid];</span><br><span class="line">            else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int partition(int[] nums, int lo, int hi)&#123;</span><br><span class="line">        int i=lo;</span><br><span class="line">        int j=hi+1;</span><br><span class="line">        int key= nums[lo];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(i&lt;hi &amp;&amp; nums[++i]&lt;=key);</span><br><span class="line">            while(j&gt;lo &amp;&amp; nums[--j] &gt;=key);</span><br><span class="line">            if(i&gt;=j) break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int temp= nums[i];</span><br><span class="line">        nums[i]= nums[j];</span><br><span class="line">        nums[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] nums=new int[]&#123;3,2,1,5,6,4&#125;;</span><br><span class="line">        for(int i=1; i&lt;=nums.length; i++)&#123;</span><br><span class="line">            System.out.println(findKthLargest(nums,i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-721-Accounts-Merge"><a href="#Leetcode-721-Accounts-Merge" class="headerlink" title="Leetcode 721. Accounts Merge"></a>Leetcode 721. Accounts Merge</h3><p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code>is a <em>name</em>, and the rest of the elements are <em>emails</em> representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in any order.</p>
<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>这道题目比较骚， 我们可以把他转换成一道graph的题目。具体来说，题目相当于给定了一个group，然后我们需要把这些小的group来merge成一个比较大的group。</p>
<p>可以用union find 或者dfs来做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; accountMerge(List&lt;List&lt;String&gt;&gt; acts)&#123;</span><br><span class="line">  Map&lt;String, String&gt; root= new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;String, String&gt; owner= new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;String, TreeSet&lt;String&gt;&gt; components= new HashMap&lt;&gt;();</span><br><span class="line">  // here is just initialization</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    for(int i=1; i&lt;a.size(); i++)&#123;</span><br><span class="line">      root.put(a.get(i), a.get(i));</span><br><span class="line">      owner.put(a.get(i), a.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // here we just union all the node connected;</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    String root_p= find(a.get(1), root);</span><br><span class="line">    for(int i=2; i&lt;a.size(); i++)&#123;</span><br><span class="line">      root.put(find(a.get(i), root), root_p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // here we get the group of node;</span><br><span class="line">  for(List&lt;String&gt; a: acts)&#123;</span><br><span class="line">    String root_p= find(a.get(1), root);</span><br><span class="line">    if(!components.containsKey(root_p)) components.put(root_p, new TreeSet&lt;&gt;());</span><br><span class="line">    for(int i=1; i&lt;a.size(); i++)&#123;</span><br><span class="line">    	components.get(root_p).add(a.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // find Res and return</span><br><span class="line">  List&lt;List&lt;String&gt;&gt; res= new Arrayist&lt;&gt;();</span><br><span class="line">  for(String key: components.keySet())&#123;</span><br><span class="line">    List&lt;String&gt; e= new ArrayList&lt;&gt;(components.get(key));</span><br><span class="line">    e.add(0, owner.get(key));</span><br><span class="line">    res.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">private String find(String key, Map&lt;String, String&gt; root)&#123;</span><br><span class="line">  while(key!= root.get(key))&#123;</span><br><span class="line">    root.put(key, root.get(key));</span><br><span class="line">    key= root.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="海量数据如何去重"><a href="#海量数据如何去重" class="headerlink" title="海量数据如何去重"></a>海量数据如何去重</h3><p>Just using mapreduce to sort.</p>
<p>现在有2T的数据， 其中有重复， 我们需要去除这些重复的值， 内存只有1G， 我们应该怎么做？</p>
<ol>
<li>文件分块， 每次读入1G的文件， 将这些文件进行hash， 进行排序（Treeset）， 并进行初步的去重(Set的特殊性);</li>
<li>在完成第一步之后， 我们得到若干份有序的文件堆。在每个堆之中取第一个文件， 进行merge。</li>
</ol>
<p>剩下的就很好理解了。</p>
<p>有两种方式， 第一种就是上面说的：</p>
<ol>
<li>split and sort, then merge;</li>
<li>如果只需要去重， 不需要排序， 还有另外一种思路，对文件的每一行计算hash值， 按照hash值把该行内容放在某个小文件中， 假设需要分词100个文件， 则可以按照(hash%100)来分发文件内容， 然后再小文件中进行去重就可以了。</li>
</ol>
<h3 id="Find-K-th-Smallest-Pair-Distance"><a href="#Find-K-th-Smallest-Pair-Distance" class="headerlink" title="Find K-th Smallest Pair Distance"></a>Find K-th Smallest Pair Distance</h3><p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<p>Naive Method is to find all the n*(n-1)/2 possible absolute differences in O(n^2) and store them in an array. Then sort this array and print the kth minimum value from this array.</p>
<p>An Efficient Solution is based on Binary Search.</p>
<ul>
<li><p>Sort the given array a[].</p>
</li>
<li><p>We can easily find the least possible absolute difference in O(n) after sorting. The largest possible difference will be a[n-1]-a[0] after sorting the array. Let low= minimum_difference and high= maximum_difference.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while low&lt; high:</span><br><span class="line">	mid=(low+ high)/2;</span><br><span class="line">	if((number of pairs with absolute difference&lt;=mid)&lt; k):</span><br><span class="line">		low= mid+1</span><br><span class="line">	else:</span><br><span class="line">		high= mid</span><br><span class="line">return low</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/算法(一)/" data-id="cjd8dvpwb000n48zhiyow6lsm" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/03/Java面试问题/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Java面试问题
        
      </div>
    </a>
  
  
    <a href="/2018/02/03/算法(二)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">算法(二)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Algorithm/">Java, Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Data-Structure/">Java, Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java-Algorithm/" style="font-size: 15px;">Java, Algorithm</a> <a href="/tags/Java-Data-Structure/" style="font-size: 10px;">Java, Data Structure</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/03/Java面试问题/">Java面试问题</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(一)/">算法(一)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/算法(二)/">算法(二)</a>
          </li>
        
          <li>
            <a href="/2018/02/03/面试问题之海量数据/">面试问题之海量数据</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Java线程简介/">Java线程简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>