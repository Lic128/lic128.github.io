<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            Node.js 学习笔记 | 
        
        Sisyphus
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="这是一个找不到工作/妹子的老实人">
    <meta name="keywords" content="Programming,Nodejs">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Sisyphus">
    <meta name="msapplication-starturl" content="http://lic128.me/2018/02/03/Node.js 学习笔记/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Sisyphus">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://lic128.me/2018/02/03/Node.js 学习笔记/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Node.js 学习笔记 | Sisyphus">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="这是一个找不到工作/妹子的老实人">
    <meta property="og:article:tag" content="Nodejs"> 

    
        <meta property="article:published_time" content="Sat Feb 03 2018 21:54:11 GMT-0800">
        <meta property="article:modified_time" content="Sat Feb 03 2018 21:57:21 GMT-0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://lic128.me/2018/02/03/Node.js 学习笔记/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://lic128.me/2018/02/03/Node.js 学习笔记/index.html",
    "headline": "Node.js 学习笔记",
    "datePublished": "Sat Feb 03 2018 21:54:11 GMT-0800",
    "dateModified": "Sat Feb 03 2018 21:57:21 GMT-0800",
    "author": {
        "@type": "Person",
        "name": "Liyan Chen",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "醉里不知天在水，满船清梦压星河"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Sisyphus",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",NodejsProgramming",
    "description": "这是一个找不到工作/妹子的老实人",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Node-js-Note"><span class="post-toc-number">1.</span> <span class="post-toc-text">Node.js Note</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何理解node-js-的单线程"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">如何理解node.js 的单线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">参考资料</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-js-调试工具"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Node.js 调试工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Node-inspect"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">Node inspect</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Node-–inspect-brk-Chrome-Dev-Tools"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">Node –inspect-brk(Chrome Dev Tools)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考资料-1"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">参考资料</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Intro-to-ES6"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Intro to ES6</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Promise-and-Callback"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Promise and Callback</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Callback"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">Callback</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考资料："><span class="post-toc-number">1.4.1.1.</span> <span class="post-toc-text">参考资料：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Promise"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">Promise</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#制作promise的API"><span class="post-toc-number">1.4.2.1.</span> <span class="post-toc-text">制作promise的API</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一次处理多个promise的"><span class="post-toc-number">1.4.2.2.</span> <span class="post-toc-text">一次处理多个promise的</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#利用promise改写你的项目"><span class="post-toc-number">1.4.2.3.</span> <span class="post-toc-text">利用promise改写你的项目</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考资料-2"><span class="post-toc-number">1.4.2.4.</span> <span class="post-toc-text">参考资料</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Intro-to-axios"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Intro to axios</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-如何进行测试—Mocha-简介"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">Node 如何进行测试—Mocha 简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-入门"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">Node 入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一个完整的基于Node-js的web应用"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">一个完整的基于Node.js的web应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现功能："><span class="post-toc-number">1.7.1.1.</span> <span class="post-toc-text">实现功能：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#应用不同模块分析"><span class="post-toc-number">1.7.1.2.</span> <span class="post-toc-text">应用不同模块分析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基于事件驱动的回调"><span class="post-toc-number">1.7.1.3.</span> <span class="post-toc-text">基于事件驱动的回调</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何来进行请求的路由"><span class="post-toc-number">1.7.1.4.</span> <span class="post-toc-text">如何来进行请求的路由</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#路由给真正的请求处理程序"><span class="post-toc-number">1.7.1.5.</span> <span class="post-toc-text">路由给真正的请求处理程序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#不好的实现方式"><span class="post-toc-number">1.7.1.5.1.</span> <span class="post-toc-text">不好的实现方式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#阻塞与非阻塞"><span class="post-toc-number">1.7.1.5.2.</span> <span class="post-toc-text">阻塞与非阻塞</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#以非阻塞操作进行请求请求响应"><span class="post-toc-number">1.7.1.5.3.</span> <span class="post-toc-text">以非阻塞操作进行请求请求响应</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#添加upload等功能。"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">添加upload等功能。</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常见middleware简介"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">常见middleware简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么使用method-override"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">为什么使用method-override</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Express模板传值对象-app-locals-res-locals"><span class="post-toc-number">1.8.2.</span> <span class="post-toc-text">Express模板传值对象 app.locals, res.locals</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#app-locals与-res-locals"><span class="post-toc-number">1.8.2.1.</span> <span class="post-toc-text">app.locals与 res.locals</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-Express获取参数的几种方式"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">Node Express获取参数的几种方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用场景案例"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">使用场景案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#req-body"><span class="post-toc-number">1.9.1.1.</span> <span class="post-toc-text">req. body</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#req-params"><span class="post-toc-number">1.9.1.2.</span> <span class="post-toc-text">req.params</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#req-param-name"><span class="post-toc-number">1.9.1.3.</span> <span class="post-toc-text">req.param(name)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#req-query"><span class="post-toc-number">1.9.1.4.</span> <span class="post-toc-text">req.query</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区别与联系"><span class="post-toc-number">1.9.2.</span> <span class="post-toc-text">区别与联系</span></a></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                Node.js 学习笔记
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Liyan Chen</strong>
        <span>Feb 03, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Nodejs/">Nodejs</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://lic128.me/2018/02/03/Node.js 学习笔记/index.html&title=Node.js 学习笔记" target="_blank">
            <li class="mdl-menu__item">
                Share to LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="Node-js-Note"><a href="#Node-js-Note" class="headerlink" title="Node.js Note"></a>Node.js Note</h1><p>** 2017-11-25</p>
<h2 id="如何理解node-js-的单线程"><a href="#如何理解node-js-的单线程" class="headerlink" title="如何理解node.js 的单线程"></a>如何理解node.js 的单线程</h2><p>node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not a problem.</p>
<p>JavaScript的单线程， 与它的用途相关。 作为浏览器脚本语言， JavaScript的主要用途是与用户互动， 以及操作DOM。 这就决定了它只能是单线程， 否则会带来很复杂的同步问题。</p>
<p>比如， 假设JavaScript同时有两个线程， 一个线程在某个DOM节点上添加内容， 另一个线程删除了这个节点， 那么这时浏览器应该以哪个线程为准？</p>
<p>所以， 为了避免复杂性， 从一诞生， JavaScript就是单线程， 这已经成了这门语言的核心特征， 将来也不会改变。</p>
<p>为了利用多核CPU的计算能力， HTML5提出WEB Worker标准， 允许javaScript脚本创建多个线程， 但是子线程完全受主线程控制， 且不得操作DOM。</p>
<p>所以， 这个新标准并没有改变JavaScript单线程的本质。</p>
<p>单线程就意味着， 所有任务需要排队， 前一个任务结束， 才会执行后一个任务。 如果前一个任务耗时很长， 后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大， CPU忙不过来， 倒也算了， 但是很多时候CPU是闲着的， 因为IO设备很慢（比如Ajax操作从网络读取数据）， 不得不等着结果出来， 再往下执行。</p>
<p>JavaScript语言的设计者意识到， 这时主线程完全可以不管IO设备， 挂起处于等待中的任务， 先运行排在后面的任务。 等到IO设备返回了结果， 再回过头， 把挂起的任务继续执行下去。</p>
<p>于是， 所有任务可以分成两种， 一种是同步任务（synchronous）, 另一种是异步任务（asynchronous）。</p>
<blockquote>
<p>同步任务指的是， 在主线程上排队执行的任务， 只有前一个任务执行完毕， 才能执行后一个任务；</p>
<p>异步任务指的是， 不进入主线程， 而进入任务队列的任务， 只有任务队列通知主线程， 某个异步任务可以执行了， 该任务才会进入主线程执行。</p>
</blockquote>
<pre><code>for(var i=0;i&lt;10;i++){
    setTimeout(function(){
        console.log(i);
    },0)
}
</code></pre><p>for函数循环10此， 每循环以下就执行一次setTimeOut， 也就是执行了10次setTimeout， 每次setTimeout执行后， 知识将里面的function放进一个队列里， 也就是往队列里面放了10个function， 把这10个function放进队列， 但都没有直接运行， 等待后面所有的程序执行完之后， 再去询问队列里面有没有东西，如果有再去执行， 所以for循环之后， i值就变成了10， 所以会输出10个10；</p>
<p>综上述， 隐含着一个意思， 即触发的每个事件都会位于堆栈的最底部。</p>
<ol>
<li>所有同步任务都在主线程上执行， 形成一个执行栈（execution context stack）。</li>
<li>主线程之外， 还存在一个任务队列。 只要异步任务有了任务结果， 就在任务队列之中放置一个时间。</li>
<li>一旦执行栈中的所有同步任务执行完毕， 系统就会读取“任务队列”， 看看里面有哪些时间。 哪些对应的异步任务。 于是结束等待状态， 进入执行栈， 开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p>这就是JavaScript运行机制。</p>
<p>主线程从任务队列中读取事件， 这个过程是循环不断的， 所以整个的这种运行机制又称为Event Loop。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="noopener">JavaScript是单线程的深入理解</a></p>
<hr>
<h2 id="Node-js-调试工具"><a href="#Node-js-调试工具" class="headerlink" title="Node.js 调试工具"></a>Node.js 调试工具</h2><h3 id="Node-inspect"><a href="#Node-inspect" class="headerlink" title="Node inspect"></a>Node inspect</h3><h3 id="Node-–inspect-brk-Chrome-Dev-Tools"><a href="#Node-–inspect-brk-Chrome-Dev-Tools" class="headerlink" title="Node –inspect-brk(Chrome Dev Tools)"></a>Node –inspect-brk(Chrome Dev Tools)</h3><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27" target="_blank" rel="noopener">Debugging Node.js with Chrome DevTools</a></p>
<p><a href="http://www.jianshu.com/p/611e7be13655" target="_blank" rel="noopener">Node.js 调试方法</a></p>
<h2 id="Intro-to-ES6"><a href="#Intro-to-ES6" class="headerlink" title="Intro to ES6"></a>Intro to ES6</h2><h2 id="Promise-and-Callback"><a href="#Promise-and-Callback" class="headerlink" title="Promise and Callback"></a>Promise and Callback</h2><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>要理解callback的概念， 我们先要理解同步， 异步， 阻塞， 非阻塞的概念。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://larry850806.github.io/2016/06/16/nodejs-async/" target="_blank" rel="noopener">理解Node.js事件驱动</a></p>
<p><a href="http://larry850806.github.io/2016/05/31/async/" target="_blank" rel="noopener">如何使用async控制流程</a></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在开始谈论正题之前，我们先来看看下面一段代码：</p>
<pre><code>step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // Do something with value4
            });
        });
    });
});
</code></pre><p>是不是感觉很恐怖，随着嵌套的回调函数增加，结尾会有大量的花括号和圆括号 }); 出现。(Callback 地狱)</p>
<p>在javascript中实现异步最简单的方式是Callback。遗憾的是，这种编程方式牺牲了控制流，同时你也不能throw new Error()并在外部捕获异常。 Promise的出现解决了这两个需求，又保持了javascript异步的优势，不同于Fiber这种多线程的实现方式，Promise只是一种编程方式的变化。而无须在底层改变。</p>
<p>CommonJS的规范提到了多种Promise，我们只介绍其中一种的实现q (<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a>)</p>
<p>我们在这里不讲解抽象的Promise规范，这多半是实现者应该关心的，我们直接从示例入手，如果你有兴趣，可以参见<a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a>。</p>
<p>q的核心是一个promise对象的then方法，他接受两个回调方法，一个promise被定义之后有3种状态，pending（过渡状态），fullfilled（完成状态），rejected(错误状态)。一个promise只能是这三种状态种的一种，而无法是他们的混合状态。</p>
<ul>
<li>pending状态可以理解为promise还没有获得确定值，就相当于一个任务还没有完成。</li>
<li>fullfilled状态可以理解为完成并返回结果。这时then(onFullfilled, onRejected)的onFullfilled方法会被调用。</li>
<li>rejected状态可以理解为错误，并结束。返回错误。这时then(onFullfilled, onRejected)的onRejected方法会被调用。</li>
</ul>
<p>了解了核心思想后，我们来看一个例子，在这个例子中我们先读取一个json文本文件，然后将其解析成javascript对象，最后这个对象进行修改再保存回去。 按照传统的callback写法，有如下代码：</p>
<pre><code>fs.readFile(&#39;example.json&#39;, function(err, data){
  if(err) {
    console.log(err):
  } else {
    try {
      var obj = JSON.parse(data);
      obj.prop = &#39;something new&#39;;
      fs.writeFile(&#39;example.json&#39;, JSON.stringify(obj), function(error){
        if(err) {
          console.log(error);
        } else {
          console.log(&#39;success&#39;);
        }
      });
    } catch(e) {
      console.log(e);
    }
  }
});
</code></pre><p>在这个例子中，控制流被切割成多个部分（每次异步都要处理一次错误），并且 <strong>JSON.parse</strong> 的错误必须在内部捕获，但却不能跑到外部。因为在异步回调中无法抛出异常。 现在当我们使用promise的时候，假设我们有个能够返回一个 <em>promise</em> 对象的 <strong>readFile</strong> 和 <strong>writeFile</strong> 方法。那么上面的代码就可以变成如下形式：</p>
<pre><code>var promise = readFile();
promise
  .then(function(data){
  // we don&#39;t need to catch error. in other words. we can throw error in this callback.
  var obj = JSON.parse(data);
  obj.prop = &#39;something new&#39;;
  // return a promise. so we can chain the then() method.
  return writeFile(JSON.stringify(obj));
  })
  .then(function(){
    console.log(&#39;success&#39;);
  }, function(err){
    // all error will fall down here.
    console.log(err);
  });
</code></pre><p>上面的例子中，我们首先从 <strong>readFile()</strong> 方法里获得了一个返回的 <em>promise</em> 对象，然后使用这个对象的 <strong>then()</strong> 方法。在这里，我们只传入了一个 <strong>onFullfilled</strong>回调方法，根据Promise/A+的文档。<strong>then()</strong> 一定会返回一个 <em>promise</em> 对象，所以我们又连接了一个 <strong>then()</strong> ，由于这个 <strong>then()</strong> 是最后一个，所以我们需要在这里提供一个 <strong>onRejected()</strong> 回调方法来处理所有的错误。在第一个 <strong>onFullfilled()</strong>回调方法中，我们返回了一个 <em>promise</em> ，这个 <em>promise</em> 的处理结果将会在下一个 <strong>then()</strong> 的 <strong>onFullfilled()</strong> 方法中取得。</p>
<p>这段代码执行的时候，当任意位置抛出异常的时候，最后一个then的 <strong>onRejected</strong> 回调会被执行。否则一切按照从上至下的顺序执行，整个控制流都十分简洁明了。</p>
<p>因为 <strong>then()</strong> 方法必须返回一个promise，实际上我们也可以结合同步方法返回一个已经fullfilled的promise 比如下面这个例子</p>
<pre><code>var promise = readFile();
promise
  .then(function(data){
    return JSON.parse(data);
  })
  .then(function(obj){
    obj.prop = &#39;something new&#39;;
    console.log(obj);
  },function(err){
    console.log(err);
  });
</code></pre><p>上面例子中第二个then会在第一个then返回之后被执行，因为第一个then返回的时候，由于JSON.parse是同步方法，所以返回了一个值，这个值会被包装成一个fullfilled的promise.</p>
<h4 id="制作promise的API"><a href="#制作promise的API" class="headerlink" title="制作promise的API"></a>制作promise的API</h4><p>上面例子中我们知道了如何使用promise提供的核心方法 <strong>then()</strong> 。但是对于平时使用的fs等异步的库我们要怎么才能利用promise呢。 在q的文档中介绍了q-io库，里面将常用的io方法都用promise的模式包装了一遍，在实际使用中，你可以使用那个库的方法。不过我们在这里简单的对fs进行包装，让其支持promise，这样以后遇到任何异步方法，你都可以将其转化。</p>
<p>首先定义改一个readFile方法，返回promise，这里利用了 <strong>Q</strong> 的 <strong>defer()</strong> 方法，创建一个 <em>deferred</em> 对象。这个对象有连个关键的方法 <strong>resolve</strong> 和 <strong>reject()</strong> 。当resolve(value)执行之后，promise变成fullfilled状态，fullfilled的值就是value 当 <strong>reject(reason)</strong> 执行之后，promise变成了rejected状态，reason会被传递到onRejected()方法。</p>
<pre><code>var Q = require(&#39;q&#39;);
function readFile(callback){
  var deferred = Q.defer();
  fs.readFile(&#39;example.json&#39;, function(err, data){
    if(err){
      deferred.reject(err);
    } else {
      deferred.resolve(data);
    }
  });
  return deferred.promise.nodeify(callback);
}
</code></pre><p>注意到这里面我们依然提供了一个callback，用于提供一些需要callback的场合的兼容性，我们利用 <em>promise</em> 对象的nodeify方法来调用这个callback，这个callback可以为undefined。</p>
<p>另外一点需要注意的是，一个promise状态改变之后，不能再次改变，所以，你只能调用一次reject或resolve。</p>
<p>有了这个API，我们便可以像前面例子里那样，使用promise来执行读取文件的操作了。其他异步回调转化成返回promise的异步方法基本上都可以参照这个模式来做。</p>
<h4 id="一次处理多个promise的"><a href="#一次处理多个promise的" class="headerlink" title="一次处理多个promise的"></a>一次处理多个promise的</h4><p>如果你有几个异步方法，他们都返回promise，并且当这些方法都处理完之后，你才能进行下一步，Q提供了一个all()方法来帮助你消化多个promise。</p>
<pre><code>Q.all([
  readFile(&#39;file1.json&#39;),
  readFile(&#39;file2.json&#39;)
  ])
  .then(function(dataArray){
    for(var i = 0; i &lt; dataArray.length; i++){
      console.log(dataArray[i]);
    }
  }, function(err){
    console.log(err);
  });
</code></pre><p>在这里例子里，我们将一个promise数组传给 <strong>all()</strong> all返回一个promise，当数组里面的所有promise都为fullfilled状态时，我们的then()方法才会被调用。这时fullfilled值是一个数组，每个元素对应前面promise的fullfilled值。 当任意一个promise变成rejected状态的时候，all的promise会立即reject而不等其他的完成。</p>
<h4 id="利用promise改写你的项目"><a href="#利用promise改写你的项目" class="headerlink" title="利用promise改写你的项目"></a>利用promise改写你的项目</h4><p>最佳的理解方法便是事件，你可以把一些nodejs的基本异步方法包装成promise，这样你就可以在整个程序的多个地方使用这些方法。并且让你的程序的异步代码看起来更整洁，更容易理解。 阅读 <a href="http://documentup.com/kriskowal/q/" target="_blank" rel="noopener">Q的文档</a> 了解更多的API和方法。并在程序中使用这些方法，使你的代码更优美，逻辑更健壮。 阅读 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a> 。了解promise原理。</p>
<h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn" target="_blank" rel="noopener">JavaScript Promise 简介</a></p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">node.js promise 简介</a></p>
<hr>
<h2 id="Intro-to-axios"><a href="#Intro-to-axios" class="headerlink" title="Intro to axios"></a>Intro to axios</h2><h2 id="Node-如何进行测试—Mocha-简介"><a href="#Node-如何进行测试—Mocha-简介" class="headerlink" title="Node 如何进行测试—Mocha 简介"></a>Node 如何进行测试—Mocha 简介</h2><h2 id="Node-入门"><a href="#Node-入门" class="headerlink" title="Node 入门"></a>Node 入门</h2><p>原文地址：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">戳这里</a></p>
<p>此文仅当作上述文档的笔记使用</p>
<p>JavaScript最早是运行在浏览器中， 然而浏览器只是提供了一个上下文， 它定义了使用JavaScript可以做什么， 但并没有“说”太多关于JavaScript语言本身可以做什么。事实上， JavaScript是一门完整的语言: 它可以使用在不同的额上下文中， 其能力与其他同类语言相比有过之而无不及。</p>
<p>Node.js 事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>
<p>要实现在后台运行JavaScript代码， 代码需要先被解释然后正确的执行。 Node.js 的原理正是如此， 它使用了Google的V8虚拟机来解释和执行JavaScript代码。</p>
<p>除此之外， 伴随着Node.js的还有许多 有用的模块， 他们可以简化很多重复的劳作， 比如向terminal输出字符串。</p>
<p>因此， Node.js事实上既是一个运行时环境， 同时又是一个库。</p>
<h3 id="一个完整的基于Node-js的web应用"><a href="#一个完整的基于Node-js的web应用" class="headerlink" title="一个完整的基于Node.js的web应用"></a>一个完整的基于Node.js的web应用</h3><h4 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h4><ul>
<li>用户可以通过浏览器使用我们的应用。</li>
<li>当用户请求<a href="http://domain.start/" target="_blank" rel="noopener">http://domain.start</a> 时， 可以看到一个欢迎界面， 页面上有一个文件上传的表单。</li>
<li>用户可以选择一个图片并提交表单， 随后文件将被上传到<a href="http://domain/ipload%EF%BC%8C" target="_blank" rel="noopener">http://domain/ipload，</a> 该页面完成上传后会把图片显示在页面上。</li>
</ul>
<h4 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h4><p>为了实现上文的用例， 我们需要实现哪些部分呢？</p>
<ul>
<li>我们需要提供Web页面， 因此需要一个HTTP服务器</li>
<li>对于不同的请求， 根据请求的URL， 我们的服务器需要给予不同的相应， 因此我们需要一个路由， 用于把请求对应到请求处理程序。</li>
<li>当请求被服务器接受并通过路由传递之后， 需要可以对其进行处理， 因此我们需要最终的请求处理程序。</li>
<li>路由还应该能处理POST数据， 并且把数据封装成更友好的格式传递给请求处理的程序， 因此需要请求数据处理功能。</li>
<li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>
<li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>
</ul>
<p>基础服务器的实现：</p>
<pre><code>var http = require(&quot;http&quot;);

http.createServer(function(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}).listen(8888);
</code></pre><p>由上代码，我们先接受这一点: 在JavaScript中， 一个函数可以作为另一个函数接受的参数。 我们可以先定义一个函数， 然后传递， 也可以在传递参数的地方直接定义函数（匿名函数）。</p>
<p>用下面的代码我们也可以达到同样的目的：</p>
<pre><code>var http = require(&quot;http&quot;);

function onRequest(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}

http.createServer(onRequest).listen(8888);
</code></pre><p>那么我们为什么要使用这种方式呢？</p>
<h4 id="基于事件驱动的回调"><a href="#基于事件驱动的回调" class="headerlink" title="基于事件驱动的回调"></a>基于事件驱动的回调</h4><p>这是Node.js原生的工作方式。 它是事件驱动的， 这也是它为什么这么快的原因。</p>
<p>参考资料：<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="noopener">Understanding node.js</a></p>
<p>当我们使用http.createServer方法的时候， 我们当然不只是想要一个侦听某个端口的服务器， 我们还想它在服务器收到一个HTTP请求的时候做点什么。</p>
<p>问题是， 这是异步的： 请求任何时候都可能到达， 但是我们的服务器却跑在一个单进程中。</p>
<p>我们创建了服务器， 并且向创建它的方法传递了一个函数。 无论何时我们的服务器收到一个请求， 这个函数就会被调用。</p>
<p>我们不知道这件事情什么时候会发生， 但是我们现在有了一个处理请求的地方：它就是我们传递过去的哪个函数。 至于它是被预先定义的函数还是匿名函数， 就无关紧要了。</p>
<p>这个就是传说中的回调。 我们给某个方法传递了一个函数， 这个方法在有相应事件发生时调用这个函数来进行回调。</p>
<p>我们仍然只拥有整个应用的最初部分： 我们可以接受HTTP请求。 但是我们得做点什么–对于不同的URL请求， 服务器应该有不同的反应。</p>
<p>对于一个非常简单的应用来说， 你可以直接在回调函数<code>onRequest()</code>中做这件事情。 不过就像我所说的， 我们应该加入一些抽象的元素， 让我们的例子变得更有趣一些。</p>
<p>处理不同的HTTP请求在我们的代码中是一个不同的部分， 叫做“路由选择”—-那么， 我们接下来就创造一个叫做路由的模块吧。</p>
<h4 id="如何来进行请求的路由"><a href="#如何来进行请求的路由" class="headerlink" title="如何来进行请求的路由"></a>如何来进行请求的路由</h4><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>
<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>
<pre><code>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)[&quot;foo&quot;]    |
                                            |
                         querystring(string)[&quot;hello&quot;]
</code></pre><p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>
<p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>
<p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
<p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>
<pre><code>function route(pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
}

exports.route = route;
</code></pre><p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>
<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>
<p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>
<pre><code>var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);

server.start(router.route);
</code></pre><p>在这里，我们传递的函数依旧什么也没做。</p>
<p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<pre><code>bash$ node index.js
Request for /foo received.
About to route a request for /foo
</code></pre><p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>
<h4 id="路由给真正的请求处理程序"><a href="#路由给真正的请求处理程序" class="headerlink" title="路由给真正的请求处理程序"></a>路由给真正的请求处理程序</h4><p>回到正题，现在我们的 HTTP服务器和请求路由模块已经如我们的期望可以相互交流了，但是这还远远不够—我们的业务逻辑还没有实现。</p>
<p>在现在的实现下， 路由过程会在路由模块中结束， 并且路由模块并不是真正针对请求采取行动的模块，否则当我们的应用程序变得更为复杂时， 将无法很好地扩展。</p>
<p>我们暂时把作为路由目标的函数称为请求处理程序。 现在我们不要急着来开发路由模块， 因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>
<p>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>
<pre><code>function start() {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
}

function upload() {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
}

exports.start = start;
exports.upload = upload;
</code></pre><p>这样我们就可以把请求处理程序和路由模块连接起来， 让路由“有路可循”。</p>
<p>在这里我们得做个决定： 是将requestHandlers模块硬编码到路由里来使用， 还是再添加一点依赖注入？ 虽然和其他模式一样， 以来注入不应该仅仅为使用而使用， 但是现在这个情况下， 使用依赖注入可以让路由和请求处理程序之间的耦合更加松散， 也因此能让路由的重用性更高。</p>
<p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>
<p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<em>if request == x then call handler y</em>也使得系统丑陋不堪。</p>
<p>在C++或C#中， 当我们谈到对象， 指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类）， 会拥有不同的属性和方法。 但是在JavaScript里对象不是这个概念。 在JavaScript中， 对象就是一个键/值对的集合–你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>
<p>好了，最后再回到代码上来。 现在我们已经确定将一系列请求处理程序通过一个对象来传递， 并且需要使用松耦合的方式将这个对象注入到route（）函数中。</p>
<p>我们先将这个对象引入到主文件<em>index.js</em>中：</p>
<pre><code>var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);
var requestHandlers = require(&quot;./requestHandlers&quot;);

var handle = {}
handle[&quot;/&quot;] = requestHandlers.start;
handle[&quot;/start&quot;] = requestHandlers.start;
handle[&quot;/upload&quot;] = requestHandlers.upload;

server.start(router.route, handle);
</code></pre><p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为<em>“/“</em>的属性，对应<em>requestHandlers.start</em>即可，这样我们就可以干净简洁地配置<em>/start</em>和<em>/</em>的请求都交由<em>start</em>这一处理程序处理。</p>
<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将<em>server.js</em>修改如下：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>这样我们就在start（）函数里添加了handle参数， 并且把handle对象作为第一个参数传递给了route（）回调函数。</p>
<p>然后我们相应地在route.js文件中修改route()函数:</p>
<pre><code>function route(handle, pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) {
    handle[pathname]();
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
  }
}

exports.route = route;
</code></pre><p>我们上述程序只是实现了一个基本的框架， 即server-router-handler的模式，但是如果我们要求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”， 那就更好了。</p>
<h5 id="不好的实现方式"><a href="#不好的实现方式" class="headerlink" title="不好的实现方式"></a>不好的实现方式</h5><p>对于我们这样拥有PHP或者Ruby技术背景的开发者来说， 最直截了当的实现方式事实上并不是非常靠谱： 看似有效， 实际上未必如此。</p>
<p>这里我指的“直截了当的实现方式”意思是：让请求处理程序通过<em>onRequest</em>函数直接返回（<em>return()</em>）他们要展示给用户的信息。</p>
<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>
<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将<em>requestHandler.js</em>修改为如下形式：</p>
<pre><code>function start() {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
  return &quot;Hello Start&quot;;
}

function upload() {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将<em>router.js</em>修改为如下形式：</p>
<pre><code>function route(handle, pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) {
    return handle[pathname]();
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    return &quot;404 Not found&quot;;
  }
}

exports.route = route;
</code></pre><p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>
<p>最后，我们需要对我们的<em>server.js</em>进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    var content = route(handle, pathname)
    response.write(content);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>如果我们运行重构后的应用，一切都会工作的很好：请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>,浏览器会输出“Hello Start”，请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>会输出“Hello Upload”,而请求<a href="http://localhost:8888/foo" target="_blank" rel="noopener">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>
<p>好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。</p>
<p>没理解？没关系，下面就来详细解释下。</p>
<h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</p>
<p>我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</p>
<p>这里，我们来修改下<em>start</em>请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似<em>sleep()</em>这样的操作，所以这里只能够来点小Hack来模拟实现。</p>
<p>让我们将<em>requestHandlers.js</em>修改成如下形式：</p>
<pre><code>function start() {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  function sleep(milliSeconds) {
    var startTime = new Date().getTime();
    while (new Date().getTime() &lt; startTime + milliSeconds);
  }

  sleep(10000);//here we add the blocking event here.
  return &quot;Hello Start&quot;;
}

function upload() {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>上述代码中，当函数<em>start()</em>被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用<em>upload()</em>的时候，会和此前一样立即返回。</p>
<p>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>
<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>
<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>， 但是先不要打开它！</p>
<p>在第二个浏览器窗口的地址栏中输入<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>， 同样的，先不要打开它！</p>
<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>
<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然<em>也</em>花了10秒，而它在对应的请求处理程序中并没有类似于<em>sleep()</em>这样的操作！</p>
<p>这到底是为什么呢？原因就是<em>start()</em>包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<p>这显然是个问题，因为Node一向是这样来标榜自己的：<em>“在node中除了代码，所有一切都是并行执行的”</em>。</p>
<p>这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>
<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>
<p>对于Node.js来说，它是这样处理的：<em>“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</em></p>
<p>（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="noopener">理解node.js的事件轮询</a>。）</p>
<p>接下来，我们会介绍一种错误的使用非阻塞操作的方式。</p>
<p>和上次一样，我们通过修改我们的应用来暴露问题。</p>
<p>这次我们还是拿<em>start</em>请求处理程序来“开刀”。将其修改成如下形式：</p>
<pre><code>var exec = require(&quot;child_process&quot;).exec;

function start() {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);
  var content = &quot;empty&quot;;

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) {
    content = stdout;
  });

  return content;
}

function upload() {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  return &quot;Hello Upload&quot;;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>上述代码中，我们引入了一个新的Node.js模块，<em>child_process</em>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<em>exec()</em>。</p>
<p><em>exec()</em>做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当<em>/start</em>URL请求的时候将文件信息输出到浏览器中。</p>
<p>上述代码是非常直观的： 创建了一个新的变量<em>content</em>（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>
<p>和往常一样，我们启动服务器，然后访问“<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>” 。</p>
<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>
<p>这个时候，你可能大致已经猜到了，<em>exec()</em>在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>
<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>
<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>
<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>
<p>问题就在于，为了进行非阻塞工作，<em>exec()</em>使用了回调函数。</p>
<p>在我们的例子中，该回调函数就是作为第二个参数传递给<em>exec()</em>的匿名函数：</p>
<pre><code>function (error, stdout, stderr) {
  content = stdout;
}
</code></pre><p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用<em>exec()</em>之后，Node.js会立即执行 <em>return content</em> ；在这个时候，<em>content</em>仍然是“empty”，因为传递给<em>exec()</em>的回调函数还未执行到——因为<em>exec()</em>的操作是异步的。</p>
<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>
<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当<em>exec()</em>在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给<em>exec()</em>的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>
<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>
<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>
<h5 id="以非阻塞操作进行请求请求响应"><a href="#以非阻塞操作进行请求请求响应" class="headerlink" title="以非阻塞操作进行请求请求响应"></a>以非阻塞操作进行请求请求响应</h5><p>我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>
<p>不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。</p>
<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>现在我们采用如下这种新的实现方式： 相对采用将内容传递给服务器的方式， 我们这次采用将服务器传递给内容的方式。 从实践角度来说， 就是将response对象（从服务器的回调函数onRequest（）获取）通过请求路由传递给请求处理程序， 随后， 处理程序就可以采用该对象上的函数来对请求做出响应。</p>
<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>
<p>先从<em>server.js</em>开始：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname, response);
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>相对此前从<em>route()</em>函数获取返回值的做法，这次我们将response对象作为第三个参数传递给<em>route()</em>函数，并且，我们将<em>onRequest()</em>处理程序中所有有关<em>response</em>的函数调都移除，因为我们希望这部分工作让<em>route()</em>函数来完成。</p>
<p>下面就来看看我们的<em>router.js</em>:</p>
<pre><code>function route(handle, pathname, response) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &#39;function&#39;) {
    handle[pathname](response);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;
</code></pre><p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递<em>response</em>对象。</p>
<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>
<p>最后，我们将<em>requestHandler.js</em>修改为如下形式：</p>
<pre><code>var exec = require(&quot;child_process&quot;).exec;

function start(response) {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(stdout);
    response.end();
  });
}

function upload(response) {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>
<p><em>start</em>处理程序在<em>exec()</em>的匿名回调函数中做请求响应的操作，而<em>upload</em>处理程序仍然是简单的回复“Hello World”，只是这次是使用<em>response</em>对象而已。</p>
<p>这时再次我们启动应用（<em>node index.js</em>），一切都会工作的很好。</p>
<p>如果想要证明<em>/start</em>处理程序中耗时的操作不会阻塞对<em>/upload</em>请求作出立即响应的话，可以将<em>requestHandlers.js</em>修改为如下形式：</p>
<pre><code>var exec = require(&quot;child_process&quot;).exec;

function start(response) {
  console.log(&quot;Request handler &#39;start&#39; was called.&quot;);

  exec(&quot;find /&quot;,
    { timeout: 10000, maxBuffer: 20000*1024 },
    function (error, stdout, stderr) {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(stdout);
      response.end();
    });
}

function upload(response) {
  console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>这样一来，当请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>的时候，会花10秒钟的时间才载入，而当请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>的时候，会立即响应，纵然这个时候/start响应还在处理中。</p>
<h3 id="添加upload等功能。"><a href="#添加upload等功能。" class="headerlink" title="添加upload等功能。"></a>添加upload等功能。</h3><p>具体见：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">node.js入门</a></p>
<h2 id="常见middleware简介"><a href="#常见middleware简介" class="headerlink" title="常见middleware简介"></a>常见middleware简介</h2><h3 id="为什么使用method-override"><a href="#为什么使用method-override" class="headerlink" title="为什么使用method-override"></a>为什么使用method-override</h3><p>这个需求主要来自前端的form， 比如我们在后端提供一个针对HTTP PUT的API， 前端的数据提交时， 我们自然希望FORM能够产生一个PUT请求。 然而， 浏览器的FORM只能GET或者POST。 这个时候， 我们就需要使用method-override来帮助我们。</p>
<h3 id="Express模板传值对象-app-locals-res-locals"><a href="#Express模板传值对象-app-locals-res-locals" class="headerlink" title="Express模板传值对象 app.locals, res.locals"></a>Express模板传值对象 app.locals, res.locals</h3><p>locals是Express应用中 Application(app)对象和Response(res)对象中的属性， 该属性是一个对象。该对象的主要作用是， 将值传递到所传递的模板中。</p>
<p>locals对象会被传递到页面， 在模板中可以直接引用该对象的属性， 也可以通过该对象引用。如：<code>&lt;%= name %&gt;</code>属性同样可以通过<code>&lt;%= locals.name %&gt;</code>来引用。</p>
<h4 id="app-locals与-res-locals"><a href="#app-locals与-res-locals" class="headerlink" title="app.locals与 res.locals"></a>app.locals与 res.locals</h4><p>locals可能存在于app对象中， 即： app.locals； 也可能存在于res对象中， 即： res.locals。 两者都会将对象传递至所渲染的页面中。 不同的是， app.locals会在整个生命周期中起作用； 而res.locals只会有当前请求中起作用。 由于app.locals 在当前应用所有的渲染模中访问， 这样我们就可以在对象中定义一些顶级/全局的数据， 并在渲染模板中使用。</p>
<h2 id="Node-Express获取参数的几种方式"><a href="#Node-Express获取参数的几种方式" class="headerlink" title="Node Express获取参数的几种方式"></a>Node Express获取参数的几种方式</h2><p>Node 配合Express框架获取参数主要有以下四种反射方式：</p>
<ul>
<li>req.body</li>
<li>req.params</li>
<li>req.param()</li>
<li>req.query</li>
</ul>
<h3 id="使用场景案例"><a href="#使用场景案例" class="headerlink" title="使用场景案例"></a>使用场景案例</h3><h4 id="req-body"><a href="#req-body" class="headerlink" title="req. body"></a>req. body</h4><p><code>req.body</code>在<a href="http://expressjs.com/4x/api.html#request" target="_blank" rel="noopener">官方文档</a>是没有提供的，但是它也是很好用的获取表单参数的方法。<code>req.body</code>是<strong>配合Express中间件bodyParser()中间件</strong>提供的。当<code>bodyParser()</code>中间件使用后，这个对象默认为 <code>{}</code>,<code>req.body</code>可以获取到post到body中的内容。<br>举个栗子：</p>
<pre><code>app.post(&#39;/user/signup&#39;,function(req,res){
    var _user = req.body.user;
})
// POST user[name]=tobi&amp;user[email]=tobi@learnboost.com
req.body.user.name
// =&gt; &quot;tobi&quot;

req.body.user.email
// =&gt; &quot;tobi@learnboost.com&quot;

// POST { &quot;name&quot;: &quot;tobi&quot; }
req.body.name
// =&gt; &quot;tobi&quot;
</code></pre><h4 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h4><p>这是一个数组对象， 命名过的参数会以键值对的形式存放。 比如你有一个路由<code>/user/:name</code>， name属性会存放在req.params.name. 这个对象默认为{}， 比如：</p>
<pre><code>app.post(&#39;/user/signup/:userid&#39;,function(req,res){
    req.params.userid;
})
</code></pre><h4 id="req-param-name"><a href="#req-param-name" class="headerlink" title="req.param(name)"></a>req.param(name)</h4><p>req.param() 是req.query, req.body 以及 req.params 获取参数的三种方式的封装。 req.param(name)返回name参数的值。</p>
<h4 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h4><p>这是一个解析过的请求参数对象，默认为<code>{}</code>.<br>举个栗子：</p>
<pre><code>// GET /search?q=tobi+ferret
req.query.q
// =&gt; &quot;tobi ferret&quot;

// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse
req.query.order
// =&gt; &quot;desc&quot;

req.query.shoe.color
// =&gt; &quot;blue&quot;

req.query.shoe.type
// =&gt; &quot;converse&quot;
</code></pre><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>总结出以下四点：</p>
<ol>
<li>对于path中的变量， 均可以使用 req.params.XXXXX方法</li>
<li>于get请求的<code>?xxxx=</code>,使用<code>req.query.xxxxx</code>方法</li>
<li>对于post请求中的变量，使用<code>req.body.xxxxx</code>方法</li>
<li>以上三种情形，均可以使用<code>req.param()</code>方法，所以说<code>req.param()</code>是<code>req.query</code>、<code>req.body</code>、以及<code>req.params</code>获取参数的三种方式的封装。</li>
</ol>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/02/03/Java线程简介/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/02/03/面试中的随机算法/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Liyan Chen's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        liyanchen128@outlook.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="liyanchen128@outlook.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                Home
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    Archives
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/02/">February 2018<span class="sidebar_archives-count">13</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            Theme - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Lic128" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    
        <a href="https://www.linkedin.com/in/liyan-chen-015063127/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-linkedin">
                <span class="visuallyhidden">LinkedIn</span>
            </button><!--
     --></a>
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Sisyphus
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
