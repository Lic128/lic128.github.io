<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            算法(二) | 
        
        Sisyphus
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="这是一个找不到工作/妹子的老实人">
    <meta name="keywords" content="Programming,Java, Algorithm">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Sisyphus">
    <meta name="msapplication-starturl" content="http://lic128.me/2018/02/03/算法(二)/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Sisyphus">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://lic128.me/2018/02/03/算法(二)/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="算法(二) | Sisyphus">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="这是一个找不到工作/妹子的老实人">
    <meta property="og:article:tag" content="Java, Algorithm"> 

    
        <meta property="article:published_time" content="Sat Feb 03 2018 21:54:11 GMT-0800">
        <meta property="article:modified_time" content="Sat Feb 03 2018 21:59:28 GMT-0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://lic128.me/2018/02/03/算法(二)/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://lic128.me/2018/02/03/算法(二)/index.html",
    "headline": "算法(二)",
    "datePublished": "Sat Feb 03 2018 21:54:11 GMT-0800",
    "dateModified": "Sat Feb 03 2018 21:59:28 GMT-0800",
    "author": {
        "@type": "Person",
        "name": "Liyan Chen",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "醉里不知天在水，满船清梦压星河"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Sisyphus",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",Java, AlgorithmProgramming",
    "description": "这是一个找不到工作/妹子的老实人",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Algorithm-Part-2"><span class="post-toc-number">1.</span> <span class="post-toc-text">Algorithm Part 2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#How-to-efficiently-hash-the-ip-address"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">How to efficiently hash the ip-address</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Merge-Two-Balanced-Binary-Search-Trees"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">Merge Two Balanced Binary Search Trees</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-1-Insert-elements-of-first-tree-to-second"><span class="post-toc-number">1.0.2.1.</span> <span class="post-toc-text">Method 1 : Insert elements of first tree to second.</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-2-Merge-Inorder-Traversals"><span class="post-toc-number">1.0.2.2.</span> <span class="post-toc-text">Method 2: Merge Inorder Traversals</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Cherry-Picker"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">Cherry Picker</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">Lowest Common Ancestor of a Binary Tree</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Sqrt-x"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">Sqrt(x)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Top-K"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">Top K</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#将数据全部排序"><span class="post-toc-number">1.0.6.1.</span> <span class="post-toc-text">将数据全部排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#局部淘汰法"><span class="post-toc-number">1.0.6.2.</span> <span class="post-toc-text">局部淘汰法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Heap"><span class="post-toc-number">1.0.6.3.</span> <span class="post-toc-text">Heap</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分治法"><span class="post-toc-number">1.0.6.4.</span> <span class="post-toc-text">分治法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">Leetcode 332. Reconstruct Itinerary</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#How-to-handle-id-generation-on-a-hadoop-cluster"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">How to handle id generation on a hadoop cluster?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Using-Map-Reduce-to-implement-outer-left-join"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">Using Map Reduce to implement outer left join</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Can-you-Override-Main-method-in-Java"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">Can you Override Main method in Java?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Intersection-of-Two-Arrays"><span class="post-toc-number">1.0.11.</span> <span class="post-toc-text">Intersection of Two Arrays</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Follow-up"><span class="post-toc-number">1.0.11.1.</span> <span class="post-toc-text">Follow up:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Answer-to-follow-up"><span class="post-toc-number">1.0.11.2.</span> <span class="post-toc-text">Answer to follow up</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#code"><span class="post-toc-number">1.0.11.3.</span> <span class="post-toc-text">code:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Subsequence-with-sub-closest-to-t"><span class="post-toc-number">1.0.12.</span> <span class="post-toc-text">Subsequence with sub closest to t</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#House-Robber"><span class="post-toc-number">1.0.13.</span> <span class="post-toc-text">House Robber</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="post-toc-number">1.0.14.</span> <span class="post-toc-text">Leetcode 329. Longest Increasing Path in a Matrix</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#code-1"><span class="post-toc-number">1.0.14.1.</span> <span class="post-toc-text">code</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Coins-in-a-line"><span class="post-toc-number">1.0.15.</span> <span class="post-toc-text">Coins in a line</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Stone-Game"><span class="post-toc-number">1.0.16.</span> <span class="post-toc-text">Stone Game</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最小调整代价"><span class="post-toc-number">1.0.17.</span> <span class="post-toc-text">最小调整代价</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ugly-Number"><span class="post-toc-number">1.0.18.</span> <span class="post-toc-text">Ugly Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树查找树中搜索区间"><span class="post-toc-number">1.0.19.</span> <span class="post-toc-text">二叉树查找树中搜索区间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Majority-Element-II"><span class="post-toc-number">1.0.20.</span> <span class="post-toc-text">Majority Element II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="post-toc-number">1.0.21.</span> <span class="post-toc-text">Leetcode 123. Best Time to Buy and Sell Stock III</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><span class="post-toc-number">1.0.22.</span> <span class="post-toc-text">Leetcode 309. Best Time to Buy and Sell Stock with cooldown</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Move-zeros-amp-amp-Sort-Colors"><span class="post-toc-number">1.0.23.</span> <span class="post-toc-text">Move zeros &amp;&amp; Sort Colors</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-220-Contains-Duplicate"><span class="post-toc-number">1.0.24.</span> <span class="post-toc-text">Leetcode 220. Contains Duplicate</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-287-Find-the-Duplicate-Number"><span class="post-toc-number">1.0.25.</span> <span class="post-toc-text">Leetcode 287. Find the Duplicate Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-41-First-Missing-Positive"><span class="post-toc-number">1.0.26.</span> <span class="post-toc-text">Leetcode 41. First Missing Positive</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Find-Two-missing-numbers"><span class="post-toc-number">1.0.27.</span> <span class="post-toc-text">Find Two missing numbers</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><span class="post-toc-number">1.0.28.</span> <span class="post-toc-text">给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><span class="post-toc-number">1.0.29.</span> <span class="post-toc-text">What’s the time complexity of merge k sorted linked lists;</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-1"><span class="post-toc-number">1.0.29.1.</span> <span class="post-toc-text">Method 1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-2"><span class="post-toc-number">1.0.29.2.</span> <span class="post-toc-text">Method 2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-3"><span class="post-toc-number">1.0.29.3.</span> <span class="post-toc-text">Method 3</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode472-Concatenated-Words"><span class="post-toc-number">1.0.30.</span> <span class="post-toc-text">Leetcode472 Concatenated Words</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#491-Increasing-subsequence"><span class="post-toc-number">1.0.31.</span> <span class="post-toc-text">491. Increasing subsequence</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Zuma-Game"><span class="post-toc-number">1.0.32.</span> <span class="post-toc-text">Zuma Game</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-210-Course-Schedule-II"><span class="post-toc-number">1.0.33.</span> <span class="post-toc-text">Leetcode 210. Course Schedule II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-57-Insert-Interval"><span class="post-toc-number">1.0.34.</span> <span class="post-toc-text">Leetcode 57. Insert Interval</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-630-Course-Schedule-III"><span class="post-toc-number">1.0.35.</span> <span class="post-toc-text">Leetcode 630 Course Schedule III</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-621-Task-Scheduler"><span class="post-toc-number">1.0.36.</span> <span class="post-toc-text">Leetcode 621. Task Scheduler</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-546-Remove-Boxes"><span class="post-toc-number">1.0.37.</span> <span class="post-toc-text">Leetcode 546. Remove Boxes</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-424-Longest-Repeating-Character-Replacement"><span class="post-toc-number">1.0.38.</span> <span class="post-toc-text">Leetcode 424. Longest Repeating Character Replacement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-76-Minimum-Window-Substring"><span class="post-toc-number">1.0.39.</span> <span class="post-toc-text">Leetcode 76. Minimum Window Substring</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-84-Largest-Rectangle-in-Histogram"><span class="post-toc-number">1.0.40.</span> <span class="post-toc-text">Leetcode 84. Largest Rectangle in Histogram</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-218-the-skyline-problem"><span class="post-toc-number">1.0.41.</span> <span class="post-toc-text">Leetcode 218 the skyline problem</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-239-Sliding-Window-Maximum"><span class="post-toc-number">1.0.42.</span> <span class="post-toc-text">Leetcode 239. Sliding Window Maximum</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self"><span class="post-toc-number">1.0.43.</span> <span class="post-toc-text">Leetcode 315. Count of Smaller Numbers After Self.</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#buildTree"><span class="post-toc-number">1.0.43.1.</span> <span class="post-toc-text">buildTree:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Binary-Search"><span class="post-toc-number">1.0.43.2.</span> <span class="post-toc-text">Binary Search</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-312-Burst-Balloons"><span class="post-toc-number">1.0.44.</span> <span class="post-toc-text">Leetcode 312. Burst Balloons</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set-Intersection-Size-At-least-Two"><span class="post-toc-number">1.0.45.</span> <span class="post-toc-text">Set Intersection Size At least Two</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-173-Binary-Search-Tree-Iterator"><span class="post-toc-number">1.0.46.</span> <span class="post-toc-text">Leetcode 173. Binary Search Tree Iterator</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-285-Inorder-Successor-in-BST"><span class="post-toc-number">1.0.47.</span> <span class="post-toc-text">Leetcode 285. Inorder Successor in BST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Successor"><span class="post-toc-number">1.0.47.1.</span> <span class="post-toc-text">Successor</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Predecessor"><span class="post-toc-number">1.0.47.2.</span> <span class="post-toc-text">Predecessor</span></a></li></ol></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                算法(二)
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Liyan Chen</strong>
        <span>Feb 03, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Java-Algorithm/">Java, Algorithm</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://lic128.me/2018/02/03/算法(二)/index.html&title=算法(二)" target="_blank">
            <li class="mdl-menu__item">
                Share to LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="Algorithm-Part-2"><a href="#Algorithm-Part-2" class="headerlink" title="Algorithm Part 2"></a>Algorithm Part 2</h1><p>** 2018-01-02</p>
<h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==p || root==q || root==null) return root;
        TreeNode left= lowestCommonAncestor(root.left, p, q);
        TreeNode right= lowestCommonAncestor(root.right, p, q);
        if(left!=null &amp;&amp; right!=null ) return root;
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
</code></pre><p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int min=Math.min(p.val, q.val);
        int max=Math.max(p.val, q.val);
        if(root.val&lt;min)  return lowestCommonAncestor(root.right, p, q);
        if(root.val&gt;max)  return lowestCommonAncestor(root.left, p, q);
        return root;
    }
}
</code></pre><h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><pre><code>class Solution {
    public int mySqrt(int x) {
        if(x==0) return 0;
        if(x&lt;=3) return 1;
        int lo=2;
        int hi=x/2;
        while(lo&lt;=hi){
            int mid= lo+ (hi-lo)/2;
            if(mid&lt; x/mid){
                lo= mid+1;
            }else if(mid== x/mid) return mid;
            else hi= mid-1;
        }
        return hi;
    }
}
</code></pre><p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><pre><code>Left Table: Transaction Table
Left Mapper: 
the transaction map() reads(transaction_id, product_id, user_id, quantity, amout) and emits a key-value pair composed of (user_id, product_id);

Right Table: User Table
Right Mapper:
the user map() reads(user_id, location_id) and emits a key-value pair composed of (user_id, location_id)


// Transaction mapper
map(key value){
  String[] tokens= StringUtil.split(value, &quot;\t&quot;);
  String productID=tokens[1];
  String userID= tokens[2];
  outputKey= Pair(userID, 2);
  outputValue= Pair(&quot;P&quot;, productID);
  emit(outputKey, outputValue);
}

// User mapper
map(key, value){
  String[] tokens= StringUtil.split(value, &quot;\t&quot;);
  String userID= tokens[0];
  String locationID= tokens[1];
  outputKey= Pair(userID, 1);// make sure location shows before produ
  outputValue=Pair(&quot;L&quot;, locationID);
  emit(outputKey, outputValue);
}

// values=List&lt;&gt;{
  Pair&lt;&quot;L&quot;, locationID&gt;,
  Pair&lt;&quot;P&quot;, productID1&gt;,
  Pair&lt;&quot;P&quot;, productID2&gt;,
}
reduce(key, values){
  locationID=&quot;undefined&quot;;
  for(Pair&lt;left, right&gt; value: values){
    if(value.left.equals(&quot;L&quot;)){
      locationID= value.right;
      continue;
    }
    productID= value.right;
    emit(productID, locationID);
  }
}
</code></pre><p>主要的意思就是要设置label。</p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash.</li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><pre><code>class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();
        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
        for(int num: nums1){
            map.put(num, map.getOrDefault(num, 0)+1);
        }
        for(int num: nums2){
            if(map.containsKey(num)){
                map.put(num, map.get(num)-1);
                if(map.get(num)==0){
                    map.remove(num);
                } 
                res.add(num);
            }
        }
        int[] arr= new int[res.size()];
        for(int i=0; i&lt;res.size(); i++){
            arr[i]= res.get(i);
        }
        return arr;
    }
}
</code></pre><h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<pre><code>public static double closestToT(double[] x, double t){
    double prefix=0;
  TreeSet&lt;Double&gt; set= new TreeSet&lt;&gt;();
  set.add(prefix);
  double leastDiff= Double.MAX_VALUE;
  for(double i: x){
      prefix+=i;
    double rest= prefix-t;
    // the next step is binary search, we can coporate the tree set api into it to solve this.
    if(set.first()&lt;= rest){
        double theSum= prefix- set.floor(rest);
      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));
    }
    if(set.last()&gt; last){
        double theSum= prefix- set.ceiling(rest);
      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));
    }
  }
  set.add(prefix);
}
return leastDiff;
</code></pre><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<pre><code>public static int rob(int[] nums){
    int ifRobbedPrevious= 0;
      int ifDidntRobPrevious=0;
      for(int i=0; i&lt;nums.length; i++){
        int currRobbed= ifDidntRobPrevious+nums[i];
      int currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);

      ifDidntRobPrevious= currNotRobbed;
      ifRobbedPrevious= currRobbed;
    }
  return Math.max(ifRobbedPrevious, ifDidntRobPrevious);
}
</code></pre><h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
]
</code></pre><p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><pre><code>class Solution {
    int[][] direction= new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int longestIncreasingPath(int[][] matrix) {
        if(matrix.length==0 || matrix[0].length==0) return 0;
        int[][] len= new int[matrix.length][matrix[0].length];
        int res=1;
        for(int i=0; i&lt;matrix.length; i++){
            for(int j=0; j&lt;matrix[0].length; j++){
                if(len[i][j]==0) dfs(i, j, len, matrix);
                res= Math.max(res, len[i][j]);
            }
        }
        return  res;
    }
    public int dfs(int x, int y, int[][] len, int[][] matrix){
        if(len[x][y]!=0) return len[x][y];
        len[x][y]=1;
        for(int i=0; i&lt;direction.length; i++){
            int newX= x+ direction[i][0];
            int newY= y+ direction[i][1];
            if(newX&gt;=0 &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=0 &amp;&amp; newY&lt;matrix[0].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y]){
                len[x][y]= Math.max(len[x][y], 1+ dfs(newX, newY, len, matrix));
            }
        }
        return len[x][y];
    }
}
</code></pre><h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<pre><code>public class Solution {
    /**
     * @param n: an integer
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        if (n % 3 == 0) {
            return false;
        }
        return true;
    }
}
</code></pre><p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<pre><code>public boolean firstWillWin(int[] values) {
    // write your code here
    if(values.length==0) return false;
    if(values.length&lt;3) return true;
    // so here we are get to take number from left, so what happens h
    // dp[i] means the max value we can get from i~end;

    // choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);
    // choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);
    int[] dp=new int[values.length];
    for(int i=values.length-1; i&gt;=0; i--){
        dp[i]=Math.max(values[i]+ Math.min((i+2&lt;dp.length?dp[i+2]:0),(i+3&lt;dp.length?dp[i+3]:0)), values[i]+ (i+1&lt;values.length? values[i+1]: 0)+ Math.min((i+3&lt;dp.length?dp[i+3]:0), (i+4&lt;dp.length?dp[i+4]:0)));
    }
    //print(dp);
    int sum=0;
    for(int num: values){
        sum+= num;
    }
    return dp[0]&gt;sum- dp[0];
}
</code></pre><p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<pre><code>public boolean firstWillWin(int[] values){
    // dp[i]= sum[i]-max(dp[i-1], dp[i-2]);
    int[] sum= new int[values.length];
    int[] dp= new int[values.length];
    for(int i=values.length-1; i&gt;=0; i--){
        sum[i]= (i+1&lt;values.length?sum[i+1]:0)+values[i];
        dp[i]= sum[i]- Math.min((i+1&lt;dp.length?dp[i+1]:0), (i+2&lt;dp.length?dp[i+2]:0));
        //System.out.println(dp[i]);
    }
    return sum[0]-dp[0]&lt;dp[0];
}
</code></pre><p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<pre><code>1. Merge second and third piles =&gt; [4, 2, 4], score +2
2. Merge the first two piles =&gt; [6, 4]，score +6
3. Merge the last two piles =&gt; [10], score +10
</code></pre><pre><code>public class stonegame {
    public static int getMaxScore(int[] nums){
        int[][] dp= new int[nums.length][nums.length];
        //int[][] sum= new int[nums.length][nums.length];
        int[] sum= new int[nums.length];
        for(int i=0; i&lt;nums.length; i++){
            sum[i]= (i&gt;0?sum[i-1]:0)+nums[i];
        }
        for(int len=1; len&lt;=nums.length; len++){
            for(int i=0; i+len-1&lt;nums.length; i++){
                int left= i;
                int right= i+len-1;
                if(left!=right)
                    dp[left][right]=Integer.MAX_VALUE;
                for(int mid= left; mid&lt;right; mid++){
                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+1][right]+sum[right]-(left&gt;0?sum[left-1]:0), dp[left][right]);
                }
            }
        }
        return dp[0][dp.length-1];
    }
    public static void main(String[] args){
        int[] nums= new int[]{4,4,5,9};
        System.out.println(getMaxScore(nums));
    }
}
</code></pre><h3 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h3><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<pre><code>public class minAdjustCost {
    /**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个
     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价
     * 之和最小是多少。**/
    public int MinAdjustmentCost(ArrayList&lt;Integer&gt;A, int target){
        int n= A.size();
        int[][] f= new int[n+1][101];
        Arrays.fill(f, Integer.MAX_VALUE);
        for(int i=0; i&lt;100; i++){
            f[0][i]=0;
        }
        for(int i=1; i&lt;=n; i++){
            for(int j=0; j&lt;=100; j++){
                if(f[i-1][j]!= Integer.MAX_VALUE){// if the previous is restricted to the condition;
                    for(int k=0; k&lt;=100; k++){
                        if(Math.abs(j-k)&lt;= target){
                            if(f[i][k]&gt; f[i-1][j]+Math.abs(A.get(i-1)-k))
                                f[i][k] = f[i-1][j] + Math.abs(A.get(i-1)-k);
                        }
                    }
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i &lt;= 100; ++i)
            if (f[n][i] &lt; ans)
                ans = f[n][i];
        return ans;
    }
}
</code></pre><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<pre><code>class Solution {
    public int nthUglyNumber(int n) {
        int[] dp= new int[n];
        dp[0]=1;
        int index_2= 0;
        int index_3= 0;
        int index_5= 0;
        // we say it&#39;s a merge process;
        for(int i=1; i&lt;n; i++){
            int candidate_2=2* dp[index_2];
            int candidate_3=3* dp[index_3];
            int candidate_5=5* dp[index_5];
            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);
            if(dp[i]== candidate_2) index_2++;
            if(dp[i]== candidate_3) index_3++;
            if(dp[i]== candidate_5) index_5++;
        }
        return dp[n-1];
    }
}
</code></pre><h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<pre><code>public class Solution {
    /*
     * @param root: param root: The root of the binary search tree
     * @param k1: An integer
     * @param k2: An integer
     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order
     */
    // public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {
    //     // write your code here
    //     if(root==null) return new ArrayList&lt;&gt;();
    //     if(k2&lt;root.val) return searchRange(root.left, k1, k2);
    //     if(k1&gt;root.val) return searchRange(root.right,k1, k2);
    //     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
    //     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);
    //     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);
    //     res.addAll(left);
    //     res.add(root.val);
    //     res.addAll(right);
    //     return res;
    // }


  public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        helper(root, k1, k2, result);

        return result;
    }

    private void helper(TreeNode root, int k1, int k2, ArrayList&lt;Integer&gt; result) {
        if (root == null) return;

        // in-order binary tree iteration
        helper(root.left, k1, k2, result);
        if (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) {
            result.add(root.val);
        }
        helper(root.right, k1, k2, result);
    }
}
</code></pre><h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<pre><code>public List&lt;Integer&gt; majorityElement(int[] nums){
    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
  if(nums.length==0) return res;
  int candidate_1= nums[0];
  int candidate_2= nums[0];
  int count_1=0;
  int count_2=0;
  for(int i=0; i&lt;nums.length; i++){
    if(nums[i]==candidate_1){
        count_1++;
    }else if(nums[i]== candidate_2){
        count_2++;
    }else if(count_1==0){
        count_1=1;
          candidate_1=nums[i];
    }else if(count_2==0){
        count_2=1;
          candidate_2= nums[i];
    }else{
        count_1--;
          count_2--;
    }
  }
  count_1=0;
  count_2=0;
  for(int num: nums){
      if(num==candidate_1) count_1++;
    else if(num==candidate_2) count_2++;
  }
  if(count_1&gt; nums.length/3) res.add(candidate_1);
  if(count_2&gt; nums.length/3)
    res.add(candidate_2);
  return res;
}
</code></pre><h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<pre><code>public int maxProfix(int[] prices){
    int firstBuy= Integer.MIN_VALUE;
      int firstSell=0;
      int secondBuy= Integer.MIN_VALUE;
      int secondSell= 0;
      for(int price: prices){
        secondSell= Math.max(secondBuy+price, secondSell);
          secondBuy= Math.max(firstSell- price, secondBuy);
          firstSell= Math.max(firstBuy+price, firstSell);
          firstBuy= Math.max(firstBuy, -price);
    }
  return secondSell;
}
</code></pre><h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        // state 1: after buy;
        // state 2: after sell;
        // buy[i] means until day i, the last action is buy, the max profit;
        // buy[i]=sell[i-2]-price[i];
        // sell[i] means until day j, the last action is sell, the max profit;
        // sell[i]=buy[i-1]+ price[i];
        if(prices.length==0) return 0;
        int[] buy= new int[prices.length];
        int[] sell= new int[prices.length];
        buy[0]= -prices[0];
        for(int i=1; i&lt;prices.length; i++){
            buy[i]= Math.max(buy[i-1], (i&gt;=2?sell[i-2]:0)-prices[i]);
            sell[i]= Math.max(sell[i-1], buy[i-1]+prices[i]);
        }
        return sell[prices.length-1];
    }
}
</code></pre><p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<pre><code>public int maxProfix(int[] prices, int fee){
    int[] buy= new int[prices.length];
      int[] sell= new int[prices.length];
      buy[0]= -prices[0];
      sell[0]= 0;
      for(int i=1; i&lt;prices.length; i++){
        buy[i]= Math.max(sell[i-1]-prices[i], buy[i-1]);
          sell[i]= Math.max(buy[i-1]+prices[i]- fee, sell[i-1]);
    }
      return sell[prices.length-1];
}
</code></pre><p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros &amp;&amp; Sort Colors"></a>Move zeros &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<pre><code>public void sortColors(int[] nums){
    int p1= 0;
      int p2= nums.length-1;
      int index=0;
      while(index&lt; nums.length){
        if(nums[index]==0 &amp;&amp; index&gt; p1){
            swap(p1, index, nums);
              p1++;
              continue;
        }
          if(nums[index]==2 &amp;&amp; index&lt;p2){
            swap(p2, index, nums);
              p2--;
              continue;
        }
          index++;
    }
      public void swap(int p1, int p2, int nums){
        int temp= nums[p1];
          nums[p1]= nums[p2];
          nums[p2]= temp;
    }
}
</code></pre><p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>
<p>这里还有一道follow up：</p>
<p>Given an array of integers, remove the duplicate number in it. You should:</p>
<ol>
<li>Do it in place in the array.</li>
<li>Move the unique numbers to the front of the array</li>
<li>Return the total number of the unique numbers.</li>
</ol>
<pre><code>public int deduplicatation(int[] nums){
  if(nums.length==0) return 0;
  Arrays.sort(nums);
  int len=0;
  for(int i=0; i&lt;nums.length; i++){
    if(nums[i]!= nums[len]){
      swap(i, ++len, nums);
    }
  }
  return len+1;
}
</code></pre><h3 id="Leetcode-220-Contains-Duplicate"><a href="#Leetcode-220-Contains-Duplicate" class="headerlink" title="Leetcode 220. Contains Duplicate"></a>Leetcode 220. Contains Duplicate</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k;</p>
<p>这道题其实是一道很不错的题目， 对于这道题目， 我们可以有两个解法。</p>
<p>解法1： 利用TreeSet, 维持一个k大小的TreeSet， 每次进行查看， 复杂度 O(n lgk);</p>
<p>解法2： 利用bucket sort，限制bucket的大小， 使得处于一个bucket内的两个数字之差不能大于t, 这里我们选取t+1为bucket size， 而后每次查看前后两个两个bucket是否存在符合条件的点（因为两个相邻bucket之间也有可能存在的）。</p>
<pre><code>public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){
        if(k&lt;1 || t&lt;0) return false;
        Map&lt;Long, Long&gt; map= new HashMap&lt;&gt;();
        for(int i=0; i&lt;nums.length; i++){
            long remappedNum= (long) nums[i]- Integer.MIN_VALUE;
            long bucket= remappedNum/((long) t +1);
            if(map.containsKey(bucket)
                    || (map.containsKey(bucket-1) &amp;&amp; remappedNum- map.get(bucket-1)&lt;=t)
                    || (map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1)-remappedNum&lt;=t))
                return true;
            if(map.entrySet().size()&gt;=k){
                long lastBucket=((long) nums[i-k]- Integer.MIN_VALUE)/((long) t+1);
                map.remove(lastBucket);
            }
            map.put(bucket, remappedNum);
        }
        return false;
    }
</code></pre><p>Solution 1:</p>
<pre><code>public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){
  // floor(x) is the maximum number but still &lt;x
  // ceiling(x) is the minimum number but still&gt;x
    if(nums==null || nums.length==0 || k&lt;=0)  return false;
  final TreeSet&lt;Integer&gt; values= new TreeSet&lt;&gt;();
  for(int ind=0; ind&lt;nums.length; ind++){
      final Integer floor= values.floor(nums[ind]+ t);
    final Integer ceil= values.ceiling(nums[ind]-t);
    if((floor!=null &amp;&amp; floor&gt;nums[ind])  || (ceil!=null &amp;&amp; ceil&lt;=nums[ind])){
        return true;
    }
    values.add(nums[ind]);
            if (ind &gt;= k) {
                values.remove(nums[ind - k]);
       }
  }
  return false;
}
</code></pre><h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287. Find the Duplicate Number"></a>Leetcode 287. Find the Duplicate Number</h3><p>Given an array nums containing n+1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<pre><code>public int findDuplicate(int[] nums){
      int slow= nums[0];
      int fast= nums[nums[0]];
      while(slow!= fast){
        slow= nums[slow];
          fast= nums[nums[fast]];
    }
      fast=0;
      while(slow!= fast){
        slow= nums[slow];
          fast= nums[fast];
    }
      return slow;
}
</code></pre><p>主要有一些细节需要注意：</p>
<ol>
<li>对于slow和fast的初始化， 我们为什么要这么设；</li>
<li>在找到交点之后我们为什么又设置为0；</li>
</ol>
<p>以上两点都要从我们对于这道题目原理的理解进行出发开始解答， fast走了多远， slow走了多远， 把带环的linkedlist示意图画出来大概就能理解了。</p>
<h3 id="Leetcode-41-First-Missing-Positive"><a href="#Leetcode-41-First-Missing-Positive" class="headerlink" title="Leetcode 41. First Missing Positive"></a>Leetcode 41. First Missing Positive</h3><p>Given an unsorted integer array, find the first missing positive integer.</p>
<pre><code>public int firstMissingPositive(int[] nums){
  int end= nums.length -1;
  for(int i=0; i&lt;nums.length; i++){
     if(nums[i]==i+1) continue;
     int index= nums[i]-1;
     if(index&gt;=0 &amp;&amp; index&lt;nums.length &amp;&amp; nums[index]!= nums[i]){
       swap(index, i, nums);
       i--;
     }
  }
  for(int i=0; i&lt;nums.length; i++){
    if(nums[i]!= i+1) return i+1;
  }
  return nums.length+1;
}
</code></pre><p>两边扫描的方法， 第一遍扫描， 将可以放入正确slot的值放入其正确的slot， 第二遍扫描， 找到第一个不属于自己地方的num。</p>
<h3 id="Find-Two-missing-numbers"><a href="#Find-Two-missing-numbers" class="headerlink" title="Find Two missing numbers"></a>Find Two missing numbers</h3><p>Given an array of n unique integers where each element in the array is in range(1, n). The array has all distinct elements and size of array is(n-2). Hence Two numbers from the range are missing from this array. Find the two missing numbers.</p>
<p>Below are steps:</p>
<ol>
<li><p>Find XOR of all array elements and natural numbers from 1 to n.</p>
</li>
<li><p>As per the property of XOR, same elements will cancel out and we will be left with the two missing numbers A XOR B. But we don’t know the exact numbers.</p>
</li>
<li><p>A bit is set in XOR only of corresponding bits in A and B are different. This is the crucial step to understand.</p>
</li>
<li><p>We take a set bit in XOR. Let us consider the rightmost set bit in XOR, for example , we miss 2 and 4 in {1, 3, 5, 6}. the OXR we get is 110, then set_bit_no= 010.</p>
</li>
<li><p>Now again if we XOR all the elements of arr[] and 1 to n that have rightmost bit set we will get one of the repeating numbers, say x.</p>
<p>Ex:</p>
<p>Elements in arr[] with bit set: {3, 6}</p>
<p>Elements from 1 to n with bit set {2, 3, 6}</p>
<p>Result of XOR all these is x=2;</p>
</li>
<li><p>Similarly, if we XOR all the elements of arr[] and 1 to n that have rightmost bit not set, we will get the other element, say y.</p>
</li>
</ol>
<pre><code>static void findTwoMissingNumbers(int[] arr, int n){
  int XOR= arr[0];
  for(int i=1; i&lt;n-2; i++){
    XOR^=arr[i];
  }
  for(int i=1; i&lt;=n; i++){
    XOR^=i;
  }
  //Get a set bit of XOR(we get the rightmost set bit)
  int set_bit_no= XOR &amp; ~(XOR-1);
  // now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element.
  int x=0, y=0;
  for(int i=0; i&lt;n-2; i++){
    if((arr[i] &amp; set_bit_no)&gt; 0){
      x= x^arr[i];
    }else{
      y=y ^arr[i];
    }
  }
  for(int i=1; i&lt;=n; i++){
    if((i&amp; set_bit_no)&gt;0){
      x= x^i;
    }else{
      y=y^i;
    }
  }
  // Here we get x and y, which is the result;

}
</code></pre><h3 id="给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><a href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。" class="headerlink" title="给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。"></a>给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</h3><p>For each node:</p>
<ol>
<li>add node to a HashSet</li>
<li>increment the block count by one.</li>
<li>If the node’s previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counter blocks.</li>
</ol>
<h3 id="What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><a href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists" class="headerlink" title="What’s the time complexity of merge k sorted linked lists;"></a>What’s the time complexity of merge k sorted linked lists;</h3><p>Given K sorted linked lists of size n each, merge them and print the sorted output.</p>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>A Simple Solution is to initialize result as first list. Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way. Time complexity of this solution is O(N2) where N is total number of nodes, i.e., N = kn.</p>
<h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>A better solution is to use Min Heap based solution. Time complexity of this solution would be O(nk Log k); n is the size of the list.</p>
<h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><p>Merge recursively, the time complexity is just like method 2;</p>
<h3 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472 Concatenated Words"></a>Leetcode472 Concatenated Words</h3><p>Given a list of words(without duplicates). Please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of least shorter words in the given array,</p>
<p>其实这道题目本质上就是wordbreak， 用wordbreak的思路就能做出来。</p>
<pre><code>class Solution {
    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) {
        List&lt;String&gt; res= new ArrayList&lt;&gt;();
        if(words.length==0) return res;
        Arrays.sort(words, (s1, s2)-&gt;{
            return s1.length()- s2.length();
        });
        Set&lt;String&gt; dict= new HashSet&lt;&gt;();
        for(int i=0; i&lt;words.length; i++){
            if(canForm(dict, words[i])){
                res.add(words[i]);
            }
            dict.add(words[i]);
        }
        return res;

    }
    public boolean canForm(Set&lt;String&gt; dict, String word){
        if(dict.size()==0) return false;
        boolean[] dp= new boolean[word.length()+1];
        dp[0]= true;
        for(int i=1; i&lt;=word.length(); i++){
            for(int j=i-1; j&gt;=0; j--){
                if(!dp[j]) continue;
                if(dict.contains(word.substring(j, i))){
                    dp[i]= true;
                    break;
                }
            }
        }
        return dp[word.length()];
    }
}
</code></pre><h3 id="491-Increasing-subsequence"><a href="#491-Increasing-subsequence" class="headerlink" title="491. Increasing subsequence"></a>491. Increasing subsequence</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.</p>
<p>这道题目， 属于对于去重的考察比较好的一道题目， 为了完成去重， 我们要确定， 每一次加进去的数字都是第一次被访问的。 并且， 这是一个未排序的数列， 所以只能用hashset来完成。</p>
<pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();
        helper(0, nums, new ArrayList&lt;&gt;(), res);
        return res;
    }
    public void helper(int pos, int[] nums, List&lt;Integer&gt; unit, List&lt;List&lt;Integer&gt;&gt; res){
        if(unit.size()&gt;=2){
            res.add(new ArrayList&lt;&gt;(unit));
        }
        Set&lt;Integer&gt; used= new HashSet&lt;&gt;();
        for(int i= pos; i&lt;nums.length; i++){
            if(used.contains(nums[i])) continue;
            if(unit.size()==0 || unit.get(unit.size()-1)&lt;=nums[i]){
                used.add(nums[i]);
                unit.add(nums[i]);
                helper(i+1, nums, unit, res);
                unit.remove(unit.size()-1);
            }
        }
    }
}
</code></pre><h3 id="Zuma-Game"><a href="#Zuma-Game" class="headerlink" title="Zuma Game"></a>Zuma Game</h3><p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>
<p>Each time, you may choose a ball in your hand, and insert it into the row(including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>
<p>Find the minimum balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1;</p>
<pre><code>public class Solution {
   int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&#39;t exceed 5&quot;

public int findMinStep(String board, String hand) {
    int[] handCount = new int[26];
    for (int i = 0; i &lt; hand.length(); ++i) ++handCount[hand.charAt(i) - &#39;A&#39;];
    int rs = helper(board + &quot;#&quot;, handCount);  // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.
    return rs == MAXCOUNT ? -1 : rs;
}
private int helper(String s, int[] h) {
    s = removeConsecutive(s);     
    if (s.equals(&quot;#&quot;)) return 0;
    int  rs = MAXCOUNT, need = 0;
    for (int i = 0, j = 0 ; j &lt; s.length(); ++j) {
        if (s.charAt(j) == s.charAt(i)) continue;
        need = 3 - (j - i);     //balls need to remove current consecutive balls.
        if (h[s.charAt(i) - &#39;A&#39;] &gt;= need) {
            h[s.charAt(i) - &#39;A&#39;] -= need;
            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));
            h[s.charAt(i) - &#39;A&#39;] += need;
        }
        i = j;
    }
    return rs;
}
//remove consecutive balls longer than 3
private String removeConsecutive(String board) {
    for (int i = 0, j = 0; j &lt; board.length(); ++j) {
        if (board.charAt(j) == board.charAt(i)) continue;
        if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));
        else i = j;
    }
    return board;
}

}
</code></pre><p>暴力破解， 每次计算需要多少个球进行一次消失， 然后对board进行更新。进行递归计算。</p>
<h3 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210. Course Schedule II"></a>Leetcode 210. Course Schedule II</h3><p>除了喜闻乐见的bfs（即 topologic sort）做法来完成这一道题， 还可以用dfs来做， 所不同的是， 我们在这里用stack进行递归， 这样保证， 如果p-&gt;q, 那么p肯定属于stack的外层， 也就是说 整个stack的结构肯定是符合Schedule的。 这个做法还是非常之骚气的。</p>
<pre><code>class Solution {
   boolean hasCycle=false;
    public int[] findOrder(int numCourses, int[][] prerequisites){
        Map&lt;Integer, List&lt;Integer&gt;&gt; map= new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();
        for(int[] prerequisite: prerequisites){
            int curr=prerequisite[0];
            int prev=prerequisite[1];
            if(!map.containsKey(prev)){
                map.put(prev, new ArrayList&lt;Integer&gt;());
            }
            map.get(prev).add(curr);
        }
        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();
        int[] visited= new int[numCourses];
        for(int i=0; i&lt;numCourses; i++){
            dfs(i, visited, map, stack);
            if(hasCycle) return new int[0];
        }
        int[] res= new int[stack.size()];
        int index=0;
        while(!stack.isEmpty()){
            res[index++]=stack.pop();
        }
        return res;
    }
    public void dfs(int curr,int[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; map, Stack&lt;Integer&gt; stack){
        if(visited[curr]==1){
            hasCycle=true;
            return;
        }
        if(visited[curr]==-1) return;
        if(!map.containsKey(curr)){
            stack.push(curr);
            visited[curr]=-1;
            return;
            // we have find the terminate, which means the end of one chain;
        }
        visited[curr]=1;
        List&lt;Integer&gt; next= map.get(curr);
        for(int num: next){
            dfs(num, visited, map, stack);
        }
        stack.push(curr);

        // post order
        visited[curr]=-1;
    }
}
</code></pre><h3 id="Leetcode-57-Insert-Interval"><a href="#Leetcode-57-Insert-Interval" class="headerlink" title="Leetcode 57. Insert Interval"></a>Leetcode 57. Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals(merge if necessary). You may assume that the intervals were initially sorted according to their start time.</p>
<pre><code>class Solution {
    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) {
        List&lt;Interval&gt; res= new ArrayList&lt;&gt;();
        Interval prev= newInterval;
        for(Interval curr: intervals){
            if(prev==null){
                res.add(curr);
                continue;
            }
            if(prev!= null &amp;&amp; curr.end&lt;prev.start){
                res.add(curr);
                continue;
            }
            if(prev!= null &amp;&amp; curr.start&lt;=prev.end){
                prev.start = Math.min(prev.start,curr.start);
                prev.end= Math.max(prev.end, curr.end);
            }else{
                res.add(prev);
                res.add(curr);
                prev= null;
            }
        }
        if(prev!=null) res.add(prev);
        return res;
    }
}
</code></pre><p>理清楚思路， 对于这道题， 我们所要完成的功能是把interval插进去。</p>
<ol>
<li>interval 已经插入过了， 那么interval是null， 我们直接continue;</li>
<li>interval在左边， 我们插入interval， 插入当前， 然后将interval置为null,表示已经插入过了。</li>
<li>interval在右边， 我们将curr插入， 继续遍历。</li>
<li>interval和当前重叠， 我们将curr 与interval merge， 作为新的interval；</li>
</ol>
<h3 id="Leetcode-630-Course-Schedule-III"><a href="#Leetcode-630-Course-Schedule-III" class="headerlink" title="Leetcode 630 Course Schedule III"></a>Leetcode 630 Course Schedule III</h3><p>There are n different online courses numbered from 1 to n. Each course has some duration(course length) t, and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given n online courses represented by pairs(t, d), your task is to find the maximal number of courses that can be taken;</p>
<pre><code>public class Solution{
  public int scheduleCourse(int[][] courses){
    Arrays.sort(courses, (a, b)-&gt; a[1]-b[1]);// sort the courses by their deadlines. Greedy! We have to deal with courses with early deadlines first
    PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;&gt;((a, b)-&gt; b-a);
    int time=0;
    for(int[] c: courses){
      time+=c[0];
      pq.add(c[0]);
      if(time&gt;c[1]) time-=pq.poll();// if time exceeds, drop the previous course which costs the most time.
    }
    return pq.size();
  }
}
</code></pre><p>这道题算是比较蛋疼的了。 记住做法就是了， 每一步， 我们先放入队列中， 如果发现不能满足条件的话， 我们删除占用时间最多的， 这样的话得到的结果总是最好的。</p>
<p>其实还是比较intuitive的。</p>
<h3 id="Leetcode-621-Task-Scheduler"><a href="#Leetcode-621-Task-Scheduler" class="headerlink" title="Leetcode 621. Task Scheduler"></a>Leetcode 621. Task Scheduler</h3><p>其实这道题目， 如果能够理解题目的话， 并不难。</p>
<pre><code>public int leastInterval(char[] tasks, int n){
  int[] c= new int[26];
  for(char t: tasks){
    c[t-&#39;A&#39;]++;
  }
  Arrays.sort(c);
  int i=25;
  while(i&gt;=0 &amp;&amp; c[i]==c[25]) i--;
  return Math.max(tasks.length, (c[25]-1)*(n+1)+25-i);
}
</code></pre><p>相当于形成了一个框架， 然后往这个框架里面放元素。</p>
<h3 id="Leetcode-546-Remove-Boxes"><a href="#Leetcode-546-Remove-Boxes" class="headerlink" title="Leetcode 546. Remove Boxes"></a>Leetcode 546. Remove Boxes</h3><p>Given several boxes with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color(composed of k boxes, k&gt;=1), remove them and get k*k points.</p>
<p>Find the maximum points you can get.</p>
<p>暴力 backtracking 做法：</p>
<pre><code>class Solution {
    public int removeBoxes(int[] boxes) {
        if(boxes.length==0) return 0;
        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();
        for(int box: boxes){
            list.add(box);
        }
        return removeBoxes(list);

    }
    public int removeBoxes(List&lt;Integer&gt; boxes){
        if(boxes.size()==0) return 0;
        int res=0;
        for(int i=0; i&lt;boxes.size(); i++){
            int start=i;
            while(i&lt;boxes.size() &amp;&amp; boxes.get(i)==boxes.get(start)) i++;
            List&lt;Integer&gt; next= new ArrayList&lt;&gt;();
            for(int idx=0; idx&lt;boxes.size(); idx++){
                if(idx&gt;=start &amp;&amp; idx&lt;i) continue;
                next.add(boxes.get(idx));
            }
            res= Math.max(res, removeBoxes(next)+ (i-start)*(i-start));
            i--;
        }
        return res;
    }
}
</code></pre><p>top-down dp:</p>
<pre><code>public int remooveBoxes(int[] boxes){
  int n= boxes.length;
  int[][][] dp= new int[n][n][n];
  return removeBoxesSum(boxes, 0, n-1, 0, dp);
}
private int removeBoxesSub(int[] boxes, int i, int j, int k, int[][] dp){
  if(i&gt;j) return 0;
  if(dp[i][j][k]&gt;0) return dp[i][j][k];
  for(; i+1&lt;= j &amp;&amp; boxes[i+1]==boxes[i], i++, k++);// optimization: all boxes of the same color counted continuously from the first box should be grouped together;
  int res=(k+1)*(k+1)+ removeBoxesSub(i+1, j. 0, dp);
  for(int m= i+1; m&lt;=j; m++){
    if(boxes[i]==boxes[m]){
      res= Math.max(res, removeBoxesSub(boxes, i+1, m-1, 0, dp)+ removeBoxesSub(boxes, m, j, k+1, dp));
    }
  }
 dp[i][j][k]= res;
 return res;
}
</code></pre><h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><pre><code>public int characterReplacement(String s, int k){
  int[] count= new int[128];
  int max=0;
  int start=0;
  for(int end=0; end&lt; s.length(); end++){
    max= Math.max(max, ++count[s.charAt(end)]);
    if(max+k&lt;=end-start){
      count[s.charAt(start++)]--;
    }
  }
  return s.length()- start;
}
</code></pre><h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n);</p>
<p>For example:</p>
<p>S=”ADOBECODEBANC”</p>
<p>T=”ABC”</p>
<p>Minimum window is “BANC”</p>
<p>这道题是window的一道很经典的题目了， 碰到这种题目的时候， 我们需要让window满足一个性质， 然后移动左右边界去更新。 得到我们想要的值。</p>
<pre><code>public String minWindow(String s, String t){
  int count=0;
  int[] cnt= new int[256];
  for(int i=0; i&lt;t.length(); i++){
    cnt[t.charAt(i)]++;
  }
  int left= 0;
  int min= Integer.MAX_VALUE;
  String res= &quot;&quot;;
  for(int right= 0; right&lt;s.length(); right++){
    cnt[s.charAt(right)]--;
    if(cnt[s.charAt(right)]&gt;=0) count++;
    while(count&gt;= t.length()){
      if(right-left+1&lt;min){
        min= right- left+1;
        res=s.substring(left, right+1);
      }
      cnt[s.charAt(left)]++;
      if(cnt[s.charAt(left)]&gt;0) count--;
      left++;
    }
  }
  return res;
}
</code></pre><h3 id="Leetcode-84-Largest-Rectangle-in-Histogram"><a href="#Leetcode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="Leetcode 84. Largest Rectangle in Histogram"></a>Leetcode 84. Largest Rectangle in Histogram</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>这道题目很经典， 在面试的时候stack基本都是这样用， 用来维持一个顺序， 我们在这里维持一个递增的stack， 每次发现数字比栈顶的数字要小的情况时， 对于栈顶而言， 我们找到了以栈顶为最高点的最大的长方形， 因此该长方形面积也能算出来。</p>
<pre><code>class Solution {
    public int largestRectangleArea(int[] heights) {
        //maintain a stack which is strictly non-decreasing
        int[] arr= new int[heights.length+1];
        for(int i=0; i&lt;heights.length; i++){
            arr[i]=heights[i];
        }
        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();
        int res=0;
        for(int i=0; i&lt;arr.length; i++){
            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&gt;arr[i]){
                int height= arr[stack.pop()];
                int right=i-1;
                int left=(stack.isEmpty()?-1:stack.peek())+1;
               //System.out.println(&quot;height=&quot;+ height);
               // System.out.println(&quot;width=&quot;+ (right-left+1));
                res= Math.max(res, (right-left+1)* height);
            }
            stack.push(i);
        }
        return res;
    }
}
</code></pre><h3 id="Leetcode-218-the-skyline-problem"><a href="#Leetcode-218-the-skyline-problem" class="headerlink" title="Leetcode 218 the skyline problem"></a>Leetcode 218 the skyline problem</h3><p>在这道题里面， 我们给定了每个建筑的位置以及高度， 要我们输出一系列点（天际线）： A key point is the left endpoint of a horizontal line segment.</p>
<p>想法：</p>
<p>for position in sorted(all start points and all end points)</p>
<p>if this position is a start point:</p>
<p> add its height</p>
<p>if this position is a end point:</p>
<p> delete its height</p>
<p>Compare current max height with previous height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height;</p>
<pre><code>public List&lt;int[]&gt; getSkyline(int[][] buildings){
  List&lt;int[]&gt; res= new ArrayList&lt;&gt;();
  List&lt;int[]&gt; height= new ArrayList&lt;&gt;();
  for(int[] b: buildings){
    height.add(new int[]{b[0], -b[2]});
    height.add(new int[]{b[1], b[2]});
  }
  Collections.sort(height, (a, b)-&gt;{
    if(a[0]==b[0]){
      return a[1]-b[1];
    }
    return a[0]-b[0];
  });
  PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;Integer&gt;((a, b)-&gt;{return b-a;});
  pq.offer(0);
  int prev_max=0;
  for(int[] h: height){
    if(h[1]&lt;0){
      pq.offer(-h[1]);
    }else{
      pq.remove(h[1]);
    }
    int max= pq.peek();
    if(prev_max!= max){
      res.add(new int[]{h[0], max});
      prev_max= max;
    }
  }
  return res;
}
</code></pre><h3 id="Leetcode-239-Sliding-Window-Maximum"><a href="#Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="Leetcode 239. Sliding Window Maximum"></a>Leetcode 239. Sliding Window Maximum</h3><p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>这道题目还是关于stack的题目， 所不同的是， 由于其特殊性， 这个栈的大小不能大于k， 所以在这里， 我们维持一个不大于k且递减的栈：</p>
<pre><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // maintain a decreasing linkedlist;
        if(nums.length==0) return new int[0];
        Deque&lt;Integer&gt; deque= new LinkedList&lt;&gt;();
        int[] res= new int[nums.length- k+1];
        int index=0;
        for(int i=0; i&lt;nums.length; i++){
            while(deque.size()!=0 &amp;&amp; nums[i]&gt;nums[deque.peekLast()]){
                deque.removeLast();
            }
            deque.addLast(i);
            if(i-deque.peekFirst()+1&gt;k){
                deque.removeFirst();
            }
            if(i&gt;=k-1) res[index++]= nums[deque.peekFirst()];
        }
        return res;
    }
}
</code></pre><h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315. Count of Smaller Numbers After Self."></a>Leetcode 315. Count of Smaller Numbers After Self.</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p>这道题可以用不同的方式来做， 比如说建树， merge sort， binarySearch等等， 这里我们使用建树和binarySearch两种方式来做。</p>
<h4 id="buildTree"><a href="#buildTree" class="headerlink" title="buildTree:"></a>buildTree:</h4><pre><code>public class Solution {
    class TreeNode{
        int val;
        int size; // to kept the size node on his left;
        int duplicate;
        TreeNode left;
        TreeNode right;
        TreeNode(int val){
            this.val=val;
            this.size=0;
            this.duplicate=1;
        }
    }
    public List&lt;Integer&gt; countSmaller(int[] nums) {
        List&lt;Integer&gt; res= new ArrayList&lt;Integer&gt;();
        if(nums.length==0) return res;
        TreeNode root= new TreeNode(nums[nums.length-1]);
        res.add(0);
        for(int i=nums.length-2; i&gt;=0; i--){
            TreeNode node=new TreeNode(nums[i]);
            insert(root, node, 0, res);
        }
        Collections.reverse(res);
        return res;
    }
    public TreeNode insert(TreeNode root, TreeNode node, int curr, List&lt;Integer&gt; res){
        if(root==null){
            res.add(curr);
            return node;
        }
        if(node.val&gt;root.val){
            curr+=root.size+root.duplicate;
            root.right=insert(root.right, node, curr, res);
        }else if(node.val==root.val){
            root.duplicate++;
            res.add(root.size+curr);
            return root;
        }else{
            root.size++;
            root.left=insert(root.left, node, curr, res);
        }
        return root;
    }
}
</code></pre><h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><pre><code>class Solution {
    public List&lt;Integer&gt; countSmaller(int[] nums) {
        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();
        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();
        for(int i= nums.length-1; i&gt;=0; i--){
            int index= findIndex(list, nums[i]);
            //System.out.println(index);
            res.add(index);
            if(index==list.size()) list.add(nums[i]);
            else list.add(index, nums[i]);
            //System.out.println(list);
        }
        Collections.reverse(res);
        return res;
    }
    public int findIndex(List&lt;Integer&gt; list, int target){
        int lo= 0;
        int hi= list.size()-1;
        while(lo&lt;=hi){
            int mid= lo+(hi- lo)/2;
            if(list.get(mid)&lt;target){
                lo= mid+1;
            }else{
                hi= mid-1;
            }
        }
        return lo;
    }
}
</code></pre><p>上面这种做法可以延伸至 reverse pairs 这一道题目。</p>
<h3 id="Leetcode-312-Burst-Balloons"><a href="#Leetcode-312-Burst-Balloons" class="headerlink" title="Leetcode 312. Burst Balloons"></a>Leetcode 312. Burst Balloons</h3><p>注意思维方式： 我们关注的是最后一个爆掉的气球。 关于dp的话， 注意边界和构造就可以了。</p>
<pre><code>class Solution {
    public int maxCoins(int[] nums) {
        int[] arr= new int[nums.length+2];
        arr[0]=1;
        for(int i=0; i&lt;nums.length; i++){
            arr[i+1]= nums[i];
        }
        arr[nums.length+1]=1;
        int[][] dp= new int[arr.length][arr.length];
        for(int len=2;  len&lt;=arr.length; len++){
            for(int i=0; i+len&lt;arr.length; i++){
                int start= i;
                int end=i+len;
                for(int j= start+1; j&lt;end; j++){
                    dp[start][end]= Math.max(dp[start][j]+ dp[j][end]+ arr[start]*arr[end]*arr[j], dp[start][end]);
                }
            }
        }
        return dp[0][dp.length-1];
    }
}
</code></pre><h3 id="Set-Intersection-Size-At-least-Two"><a href="#Set-Intersection-Size-At-least-Two" class="headerlink" title="Set Intersection Size At least Two"></a>Set Intersection Size At least Two</h3><p>An integer interval {a, b}( for integers a&lt;b) is a set of all consecutive integers from a to b, including a and b.</p>
<p>Find the minimum size of a set S such that for every integer intervals A in intervals, the intersection of S with A has size at east 2.</p>
<p>Example 1:</p>
<p>Input: intervals[[1, 3], [1, 4], [2, 5], [3,5]]</p>
<p>Output: 3</p>
<p>思路， 在选择区间中的元素时， 我们可以随意选， 但随意选的后果就是不能让set最优， 所以可以从侧面反映出如果有规则的选择， 可能达到全局最优。 一个思路： 对end进行排序， 这样我们就能根据end进行规则的选择了。</p>
<ol>
<li>很明显， 对于待选区间， 如果之前没有元素被选择过， 那么一定选择最后两个元素， 这样能够覆盖的后续区间最多， 不过这个时候需要判断一下， 选择两个元素之后， 后续区间是否都包含该两个元素。 包含一个+1， 包含两个+2， 不包含则跳出。</li>
<li>对于一个元素被选择了， 我们依旧选取当前区间的最后一个元素，不过此时只选择了一个， 所以只需要测试后续区间是否包含该元素即可。</li>
</ol>
<pre><code>class P implements Comparable&lt;P&gt;{
  int s;
  int e;
  int c;
  P(int s, int e){
    this.s= s;
    this.e= e;
    this.c=0;
  }
  @Override
  public int compareTo(P o){
    return this.e- o.e;
  }
}
public int intersectionSizeTwo(int[][] intervals){
  List&lt;P&gt; ps= new ArrayList&lt;&gt;();
  int n= intervals.length;
  for(int i=0; i&lt;n; i++){
    ps.add(new P(intervals[i][0], intervals[i][1]));
  }
  Collections.sort(ps);
  int res=0;
  for(int i=0; i&lt;n; i++){
    P inter= ps.get(i);
    if(inter.c==0){
      int pos= i+1;
      // the first point we choose the end of curr
      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;=inter.e){
        ps.get(pos).c++; 
        if(ps.get(pos).s&lt;=inter.e-1){
          ps.get(pos).c++;
        }
        pos++;
      }
      res+=2;
    }else if(inter.c==1){
      int pos=i+1;
      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;= inter.e){
        ps.get(pos).c++;
        pos++;
      }
      res++;
    }
  }
  return res;
}
</code></pre><p>其实就是之前intervals问题的推广版本， 我们每次选点都要求局部最优， 也就是选择最后两个点， 然后排除之后的点再次进行选择。 还是很具有价值的一道题目。</p>
<h3 id="Leetcode-173-Binary-Search-Tree-Iterator"><a href="#Leetcode-173-Binary-Search-Tree-Iterator" class="headerlink" title="Leetcode 173. Binary Search Tree Iterator"></a>Leetcode 173. Binary Search Tree Iterator</h3><p>Implement an iterator over a binary search tree(BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.</p>
<p>next() and hasNext() should run in average O(1) and uses O(h) memory, where h is the height of the tree.</p>
<h3 id="Leetcode-285-Inorder-Successor-in-BST"><a href="#Leetcode-285-Inorder-Successor-in-BST" class="headerlink" title="Leetcode 285. Inorder Successor in BST"></a>Leetcode 285. Inorder Successor in BST</h3><p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>If the given node has no in-order successor in the tree, return null.</p>
<p>MySolution:</p>
<pre><code>class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if(root==null) return null;
        if(p.right!=null){
            TreeNode node= p.right;
            while(node.left!= null){
                node= node.left;
            }
            return node;
        }       
        TreeNode node= root;
        TreeNode prev= null;
        while(node!= null){
            if(node.val&lt;=p.val){
                node=node.right;
            }else{
                prev= node;
                node= node.left;
            }
        }
        return prev;
    }
}
</code></pre><h4 id="Successor"><a href="#Successor" class="headerlink" title="Successor"></a>Successor</h4><pre><code>public TreeNode successor(TreeNode root, TreeNode p){
  if(root==null) return null;
  if(root.val&lt;=p.val){
    return successor(root.right, p);
  }else{
    TreeNode left= successor(root.left, p);
    return( left!= null)? left: root;
  }
}
</code></pre><h4 id="Predecessor"><a href="#Predecessor" class="headerlink" title="Predecessor"></a>Predecessor</h4><pre><code>public TreeNode predecessor(TreeNode root, TreeNode p){
  if(root==null) return null;
  if(root.val&gt;= p.val){
    return predecessor(root.left, p);
  }else{
    TreeNode right= predecessor(root.right, p);
    return (right!= null) ? right: root;
  }
}
</code></pre>
        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/02/03/Java线程简介/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/02/03/Resume Review/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Liyan Chen's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        liyanchen128@outlook.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="liyanchen128@outlook.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                Home
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    Archives
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/02/">February 2018<span class="sidebar_archives-count">13</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            Theme - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Lic128" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    
        <a href="https://www.linkedin.com/in/liyan-chen-015063127/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-linkedin">
                <span class="visuallyhidden">LinkedIn</span>
            </button><!--
     --></a>
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Sisyphus
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
