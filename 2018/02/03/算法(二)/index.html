<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            算法(二) | 
        
        Sisyphus
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="这是一个找不到工作/妹子的老实人">
    <meta name="keywords" content=",Java, Algorithm">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Sisyphus">
    <meta name="msapplication-starturl" content="http://lic128.me/2018/02/03/算法(二)/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Sisyphus">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://lic128.me/2018/02/03/算法(二)/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="算法(二) | Sisyphus">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="这是一个找不到工作/妹子的老实人">
    <meta property="og:article:tag" content="Java, Algorithm"> 

    
        <meta property="article:published_time" content="Sat Feb 03 2018 21:54:11 GMT-0800">
        <meta property="article:modified_time" content="Sat Feb 03 2018 21:59:28 GMT-0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://lic128.me/2018/02/03/算法(二)/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://lic128.me/2018/02/03/算法(二)/index.html",
    "headline": "算法(二)",
    "datePublished": "Sat Feb 03 2018 21:54:11 GMT-0800",
    "dateModified": "Sat Feb 03 2018 21:59:28 GMT-0800",
    "author": {
        "@type": "Person",
        "name": "Liyan Chen",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "Hi, nice to meet you"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Sisyphus",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",Java, Algorithm",
    "description": "这是一个找不到工作/妹子的老实人",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Algorithm-Part-2"><span class="post-toc-number">1.</span> <span class="post-toc-text">Algorithm Part 2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#How-to-efficiently-hash-the-ip-address"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">How to efficiently hash the ip-address</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Merge-Two-Balanced-Binary-Search-Trees"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">Merge Two Balanced Binary Search Trees</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-1-Insert-elements-of-first-tree-to-second"><span class="post-toc-number">1.0.2.1.</span> <span class="post-toc-text">Method 1 : Insert elements of first tree to second.</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-2-Merge-Inorder-Traversals"><span class="post-toc-number">1.0.2.2.</span> <span class="post-toc-text">Method 2: Merge Inorder Traversals</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Cherry-Picker"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">Cherry Picker</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">Lowest Common Ancestor of a Binary Tree</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Sqrt-x"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">Sqrt(x)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Top-K"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">Top K</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#将数据全部排序"><span class="post-toc-number">1.0.6.1.</span> <span class="post-toc-text">将数据全部排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#局部淘汰法"><span class="post-toc-number">1.0.6.2.</span> <span class="post-toc-text">局部淘汰法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Heap"><span class="post-toc-number">1.0.6.3.</span> <span class="post-toc-text">Heap</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分治法"><span class="post-toc-number">1.0.6.4.</span> <span class="post-toc-text">分治法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">Leetcode 332. Reconstruct Itinerary</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#How-to-handle-id-generation-on-a-hadoop-cluster"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">How to handle id generation on a hadoop cluster?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Using-Map-Reduce-to-implement-outer-left-join"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">Using Map Reduce to implement outer left join</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Can-you-Override-Main-method-in-Java"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">Can you Override Main method in Java?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Intersection-of-Two-Arrays"><span class="post-toc-number">1.0.11.</span> <span class="post-toc-text">Intersection of Two Arrays</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Follow-up"><span class="post-toc-number">1.0.11.1.</span> <span class="post-toc-text">Follow up:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Answer-to-follow-up"><span class="post-toc-number">1.0.11.2.</span> <span class="post-toc-text">Answer to follow up</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#code"><span class="post-toc-number">1.0.11.3.</span> <span class="post-toc-text">code:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Subsequence-with-sub-closest-to-t"><span class="post-toc-number">1.0.12.</span> <span class="post-toc-text">Subsequence with sub closest to t</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#House-Robber"><span class="post-toc-number">1.0.13.</span> <span class="post-toc-text">House Robber</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="post-toc-number">1.0.14.</span> <span class="post-toc-text">Leetcode 329. Longest Increasing Path in a Matrix</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#code-1"><span class="post-toc-number">1.0.14.1.</span> <span class="post-toc-text">code</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Coins-in-a-line"><span class="post-toc-number">1.0.15.</span> <span class="post-toc-text">Coins in a line</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Stone-Game"><span class="post-toc-number">1.0.16.</span> <span class="post-toc-text">Stone Game</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最小调整代价"><span class="post-toc-number">1.0.17.</span> <span class="post-toc-text">最小调整代价</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ugly-Number"><span class="post-toc-number">1.0.18.</span> <span class="post-toc-text">Ugly Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树查找树中搜索区间"><span class="post-toc-number">1.0.19.</span> <span class="post-toc-text">二叉树查找树中搜索区间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Majority-Element-II"><span class="post-toc-number">1.0.20.</span> <span class="post-toc-text">Majority Element II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="post-toc-number">1.0.21.</span> <span class="post-toc-text">Leetcode 123. Best Time to Buy and Sell Stock III</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><span class="post-toc-number">1.0.22.</span> <span class="post-toc-text">Leetcode 309. Best Time to Buy and Sell Stock with cooldown</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Move-zeros-amp-amp-Sort-Colors"><span class="post-toc-number">1.0.23.</span> <span class="post-toc-text">Move zeros &amp;&amp; Sort Colors</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-220-Contains-Duplicate"><span class="post-toc-number">1.0.24.</span> <span class="post-toc-text">Leetcode 220. Contains Duplicate</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-287-Find-the-Duplicate-Number"><span class="post-toc-number">1.0.25.</span> <span class="post-toc-text">Leetcode 287. Find the Duplicate Number</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-41-First-Missing-Positive"><span class="post-toc-number">1.0.26.</span> <span class="post-toc-text">Leetcode 41. First Missing Positive</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Find-Two-missing-numbers"><span class="post-toc-number">1.0.27.</span> <span class="post-toc-text">Find Two missing numbers</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><span class="post-toc-number">1.0.28.</span> <span class="post-toc-text">给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><span class="post-toc-number">1.0.29.</span> <span class="post-toc-text">What’s the time complexity of merge k sorted linked lists;</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-1"><span class="post-toc-number">1.0.29.1.</span> <span class="post-toc-text">Method 1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-2"><span class="post-toc-number">1.0.29.2.</span> <span class="post-toc-text">Method 2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Method-3"><span class="post-toc-number">1.0.29.3.</span> <span class="post-toc-text">Method 3</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode472-Concatenated-Words"><span class="post-toc-number">1.0.30.</span> <span class="post-toc-text">Leetcode472 Concatenated Words</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#491-Increasing-subsequence"><span class="post-toc-number">1.0.31.</span> <span class="post-toc-text">491. Increasing subsequence</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Zuma-Game"><span class="post-toc-number">1.0.32.</span> <span class="post-toc-text">Zuma Game</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-210-Course-Schedule-II"><span class="post-toc-number">1.0.33.</span> <span class="post-toc-text">Leetcode 210. Course Schedule II</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-57-Insert-Interval"><span class="post-toc-number">1.0.34.</span> <span class="post-toc-text">Leetcode 57. Insert Interval</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-630-Course-Schedule-III"><span class="post-toc-number">1.0.35.</span> <span class="post-toc-text">Leetcode 630 Course Schedule III</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-621-Task-Scheduler"><span class="post-toc-number">1.0.36.</span> <span class="post-toc-text">Leetcode 621. Task Scheduler</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-546-Remove-Boxes"><span class="post-toc-number">1.0.37.</span> <span class="post-toc-text">Leetcode 546. Remove Boxes</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-424-Longest-Repeating-Character-Replacement"><span class="post-toc-number">1.0.38.</span> <span class="post-toc-text">Leetcode 424. Longest Repeating Character Replacement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-76-Minimum-Window-Substring"><span class="post-toc-number">1.0.39.</span> <span class="post-toc-text">Leetcode 76. Minimum Window Substring</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-84-Largest-Rectangle-in-Histogram"><span class="post-toc-number">1.0.40.</span> <span class="post-toc-text">Leetcode 84. Largest Rectangle in Histogram</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-218-the-skyline-problem"><span class="post-toc-number">1.0.41.</span> <span class="post-toc-text">Leetcode 218 the skyline problem</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-239-Sliding-Window-Maximum"><span class="post-toc-number">1.0.42.</span> <span class="post-toc-text">Leetcode 239. Sliding Window Maximum</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self"><span class="post-toc-number">1.0.43.</span> <span class="post-toc-text">Leetcode 315. Count of Smaller Numbers After Self.</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#buildTree"><span class="post-toc-number">1.0.43.1.</span> <span class="post-toc-text">buildTree:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Binary-Search"><span class="post-toc-number">1.0.43.2.</span> <span class="post-toc-text">Binary Search</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-312-Burst-Balloons"><span class="post-toc-number">1.0.44.</span> <span class="post-toc-text">Leetcode 312. Burst Balloons</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set-Intersection-Size-At-least-Two"><span class="post-toc-number">1.0.45.</span> <span class="post-toc-text">Set Intersection Size At least Two</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-173-Binary-Search-Tree-Iterator"><span class="post-toc-number">1.0.46.</span> <span class="post-toc-text">Leetcode 173. Binary Search Tree Iterator</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leetcode-285-Inorder-Successor-in-BST"><span class="post-toc-number">1.0.47.</span> <span class="post-toc-text">Leetcode 285. Inorder Successor in BST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Successor"><span class="post-toc-number">1.0.47.1.</span> <span class="post-toc-text">Successor</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Predecessor"><span class="post-toc-number">1.0.47.2.</span> <span class="post-toc-text">Predecessor</span></a></li></ol></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                算法(二)
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Liyan Chen</strong>
        <span>Feb 03, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Java-Algorithm/">Java, Algorithm</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=算法(二)&url=http://lic128.me/2018/02/03/算法(二)/index.html&pic=http://lic128.me/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                Share to Weibo
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=算法(二)&url=http://lic128.me/2018/02/03/算法(二)/index.html&via=Liyan Chen" target="_blank">
            <li class="mdl-menu__item">
                Share to Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://lic128.me/2018/02/03/算法(二)/index.html" target="_blank">
            <li class="mdl-menu__item">
                Share to Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://lic128.me/2018/02/03/算法(二)/index.html" target="_blank">
            <li class="mdl-menu__item">
                Share to Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="Algorithm-Part-2"><a href="#Algorithm-Part-2" class="headerlink" title="Algorithm Part 2"></a>Algorithm Part 2</h1><p>** 2018-01-02</p>
<h3 id="How-to-efficiently-hash-the-ip-address"><a href="#How-to-efficiently-hash-the-ip-address" class="headerlink" title="How to efficiently hash the ip-address"></a>How to efficiently hash the ip-address</h3><p>Question: You have 10 million IP address(IPv4 4 byte addresses). Create a hash function for these IP addresses.</p>
<p>Hint: Using the IP’s themselves as a key is a bad idea because there will be a lot of wasted space.</p>
<h3 id="Merge-Two-Balanced-Binary-Search-Trees"><a href="#Merge-Two-Balanced-Binary-Search-Trees" class="headerlink" title="Merge Two Balanced Binary Search Trees"></a>Merge Two Balanced Binary Search Trees</h3><p>平衡树： AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>You are given two balanced binary search trees. Write a function that merges the two given balanced BSTs into a balanced binary search tree.</p>
<p>Let there be m elements in first tree and n elements in the oter tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, the we can get the size by traversing the tree.</p>
<h4 id="Method-1-Insert-elements-of-first-tree-to-second"><a href="#Method-1-Insert-elements-of-first-tree-to-second" class="headerlink" title="Method 1 : Insert elements of first tree to second."></a>Method 1 : Insert elements of first tree to second.</h4><h4 id="Method-2-Merge-Inorder-Traversals"><a href="#Method-2-Merge-Inorder-Traversals" class="headerlink" title="Method 2: Merge Inorder Traversals"></a>Method 2: Merge Inorder Traversals</h4><ol>
<li>Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.</li>
<li>Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time.</li>
<li>The arrays created in step 1 and 2 are sorted arrays, Merge the two sorted arrays into one array of size m+n. This step takes O(m+n) time.</li>
<li>Construct a balanced tree from the merged array using the technique discussed in <a href="https://www.geeksforgeeks.org/archives/17138" target="_blank" rel="noopener">this</a> post. This step takes O(m+n) time.</li>
</ol>
<h3 id="Cherry-Picker"><a href="#Cherry-Picker" class="headerlink" title="Cherry Picker"></a>Cherry Picker</h3><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root==p || root==q || root==null) return root;</span><br><span class="line">        TreeNode left= lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right= lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left!=null &amp;&amp; right!=null ) return root;</span><br><span class="line">        if(left==null) return right;</span><br><span class="line">        if(right==null) return left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find p or q, if we found p and q in both left and right, then the lca must be root, else if we didn’t find p or q in left, then the lca must be right, vice versa;</p>
<p>if it’s a binary search tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        int min=Math.min(p.val, q.val);</span><br><span class="line">        int max=Math.max(p.val, q.val);</span><br><span class="line">        if(root.val&lt;min)  return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(root.val&gt;max)  return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if(x==0) return 0;</span><br><span class="line">        if(x&lt;=3) return 1;</span><br><span class="line">        int lo=2;</span><br><span class="line">        int hi=x/2;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+ (hi-lo)/2;</span><br><span class="line">            if(mid&lt; x/mid)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else if(mid== x/mid) return mid;</span><br><span class="line">            else hi= mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这道题比较奇怪， lo左边的都是小于等于的该条件， hi右边的都是大于等于该条件。所以相当于是寻找插入位置， 这样就更好理解了。 对于binarySearch的题目， 记住hi以及lo代表边界就是了。</p>
<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><h4 id="将数据全部排序"><a href="#将数据全部排序" class="headerlink" title="将数据全部排序"></a>将数据全部排序</h4><h4 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h4><p>用一个容器保存前1000个数， 然后将剩余的所有数字与容器内的最小数字进行相比，和Heap的想法是逸雅阁的</p>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p>将大数据分为很多份， 每份100万个数据， 找到每份数据中最大的10000个， 最后在剩下的100*10000个数据里面找出最大的10000个， 利用 array partition做法。</p>
<p>top K问题很适合采用MapReduce框架解决， 用户只需要编写一个Map函数和两个Reduce函数， 然后提交到Hadoop上即可解决问题。 具体而言， 就是首先根据数据值或者把数据hash后的值按照范围划分到不同的机器上， 最好可以让数据划分后一次读入内存， 这样不同的机器负责处理不同的数值范围， 实际上就是Map。 得到结果之后， 各个机器只需要拿出各自出现次数最多的前N个数据， 然后汇总， 选出所有数据中出现词素最多的前N个数据，这实际上就是Reduce函数。对于Map函数， 采用Hash算法， 将hash相同的数据交给同一个Reduce task； 对于第一个Reduce函数， 采用 HashMap 统计出每个词出现的频率， 对于第二个Reduce函数， 统计所有Reduce task， 输出数据中的top k即可。</p>
<p>直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。 因为一个数据可能被均分到不同的机器上， 而另一个则可能完全聚集到一个机器上， 同时还可能存在具有相同数目的数据。</p>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332. Reconstruct Itinerary"></a>Leetcode 332. Reconstruct Itinerary</h3><h3 id="How-to-handle-id-generation-on-a-hadoop-cluster"><a href="#How-to-handle-id-generation-on-a-hadoop-cluster" class="headerlink" title="How to handle id generation on a hadoop cluster?"></a>How to handle id generation on a hadoop cluster?</h3><p>You have two problems. First you want to make sure that you assigned exactly one id for each token. To do that you should sort and group records by token and make the assignment in a reducer. Once you’ve made sure that the reducer method is called exactly once for each token you can use the partition number from the context and a unique numeric id maintained by the reducer(one instance per partition)- just use an instance variable initialized to 1 in the setup method and incremented in the reduce method.</p>
<h3 id="Using-Map-Reduce-to-implement-outer-left-join"><a href="#Using-Map-Reduce-to-implement-outer-left-join" class="headerlink" title="Using Map Reduce to implement outer left join"></a>Using Map Reduce to implement outer left join</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Left Table: Transaction Table</span><br><span class="line">Left Mapper: </span><br><span class="line">the transaction map() reads(transaction_id, product_id, user_id, quantity, amout) and emits a key-value pair composed of (user_id, product_id);</span><br><span class="line"></span><br><span class="line">Right Table: User Table</span><br><span class="line">Right Mapper:</span><br><span class="line">the user map() reads(user_id, location_id) and emits a key-value pair composed of (user_id, location_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Transaction mapper</span><br><span class="line">map(key value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String productID=tokens[1];</span><br><span class="line">  String userID= tokens[2];</span><br><span class="line">  outputKey= Pair(userID, 2);</span><br><span class="line">  outputValue= Pair(&quot;P&quot;, productID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// User mapper</span><br><span class="line">map(key, value)&#123;</span><br><span class="line">  String[] tokens= StringUtil.split(value, &quot;\t&quot;);</span><br><span class="line">  String userID= tokens[0];</span><br><span class="line">  String locationID= tokens[1];</span><br><span class="line">  outputKey= Pair(userID, 1);// make sure location shows before produ</span><br><span class="line">  outputValue=Pair(&quot;L&quot;, locationID);</span><br><span class="line">  emit(outputKey, outputValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// values=List&lt;&gt;&#123;</span><br><span class="line">  Pair&lt;&quot;L&quot;, locationID&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID1&gt;,</span><br><span class="line">  Pair&lt;&quot;P&quot;, productID2&gt;,</span><br><span class="line">&#125;</span><br><span class="line">reduce(key, values)&#123;</span><br><span class="line">  locationID=&quot;undefined&quot;;</span><br><span class="line">  for(Pair&lt;left, right&gt; value: values)&#123;</span><br><span class="line">    if(value.left.equals(&quot;L&quot;))&#123;</span><br><span class="line">      locationID= value.right;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    productID= value.right;</span><br><span class="line">    emit(productID, locationID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的意思就是要设置label。</p>
<h3 id="Can-you-Override-Main-method-in-Java"><a href="#Can-you-Override-Main-method-in-Java" class="headerlink" title="Can you Override Main method in Java?"></a>Can you Override Main method in Java?</h3><p>No, main is a static method and static method cannot be overridden in Java. they can only be hidden.</p>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums 1’s size is small compared to num2’s size? which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all element into the memory at once.</li>
</ul>
<h4 id="Answer-to-follow-up"><a href="#Answer-to-follow-up" class="headerlink" title="Answer to follow up"></a>Answer to follow up</h4><ol>
<li>If both arrays are sorted, I would use two pointers to iterate, which somehow resembles the merge process in merge sort.</li>
<li>Suppose lengths of two arrays are N and M, the time complexity of my solution is O(N+M) and the space complexity is O(N) considering the hash. So it’s better to use to use the smaller array to construct the counter hash.</li>
<li><ul>
<li>if only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually(external sort), then read 2 elements from each array at a time in memory, record intersections.</li>
</ul>
</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int num: nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, 0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int num: nums2)&#123;</span><br><span class="line">            if(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)-1);</span><br><span class="line">                if(map.get(num)==0)&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125; </span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr= new int[res.size()];</span><br><span class="line">        for(int i=0; i&lt;res.size(); i++)&#123;</span><br><span class="line">            arr[i]= res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subsequence-with-sub-closest-to-t"><a href="#Subsequence-with-sub-closest-to-t" class="headerlink" title="Subsequence with sub closest to t"></a>Subsequence with sub closest to t</h3><p>Find a contiguous non-empty subsequence such that its sum is as close as t possible;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static double closestToT(double[] x, double t)&#123;</span><br><span class="line">    double prefix=0;</span><br><span class="line">  TreeSet&lt;Double&gt; set= new TreeSet&lt;&gt;();</span><br><span class="line">  set.add(prefix);</span><br><span class="line">  double leastDiff= Double.MAX_VALUE;</span><br><span class="line">  for(double i: x)&#123;</span><br><span class="line">      prefix+=i;</span><br><span class="line">    double rest= prefix-t;</span><br><span class="line">    // the next step is binary search, we can coporate the tree set api into it to solve this.</span><br><span class="line">    if(set.first()&lt;= rest)&#123;</span><br><span class="line">        double theSum= prefix- set.floor(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">    if(set.last()&gt; last)&#123;</span><br><span class="line">        double theSum= prefix- set.ceiling(rest);</span><br><span class="line">      leastDiff= Math.min(leastDiff, Math.abs(theSum- t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set.add(prefix);</span><br><span class="line">&#125;</span><br><span class="line">return leastDiff;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>很多时候dp的题目都需要进行空间的优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(int[] nums)&#123;</span><br><span class="line">    int ifRobbedPrevious= 0;</span><br><span class="line">  	int ifDidntRobPrevious=0;</span><br><span class="line">  	for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        int currRobbed= ifDidntRobPrevious+nums[i];</span><br><span class="line">      int currNotRobbed= Math.max(ifDidntRobPrevious, ifRobbedPrevious);</span><br><span class="line">      </span><br><span class="line">      ifDidntRobPrevious= currNotRobbed;</span><br><span class="line">      ifRobbedPrevious= currRobbed;</span><br><span class="line">    &#125;</span><br><span class="line">  return Math.max(ifRobbedPrevious, ifDidntRobPrevious);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329. Longest Increasing Path in a Matrix"></a>Leetcode 329. Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[][] direction= new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    public int longestIncreasingPath(int[][] matrix) &#123;</span><br><span class="line">        if(matrix.length==0 || matrix[0].length==0) return 0;</span><br><span class="line">        int[][] len= new int[matrix.length][matrix[0].length];</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int i=0; i&lt;matrix.length; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;matrix[0].length; j++)&#123;</span><br><span class="line">                if(len[i][j]==0) dfs(i, j, len, matrix);</span><br><span class="line">                res= Math.max(res, len[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfs(int x, int y, int[][] len, int[][] matrix)&#123;</span><br><span class="line">        if(len[x][y]!=0) return len[x][y];</span><br><span class="line">        len[x][y]=1;</span><br><span class="line">        for(int i=0; i&lt;direction.length; i++)&#123;</span><br><span class="line">            int newX= x+ direction[i][0];</span><br><span class="line">            int newY= y+ direction[i][1];</span><br><span class="line">            if(newX&gt;=0 &amp;&amp; newX&lt;matrix.length &amp;&amp; newY&gt;=0 &amp;&amp; newY&lt;matrix[0].length &amp;&amp; matrix[newX][newY]&gt;matrix[x][y])&#123;</span><br><span class="line">                len[x][y]= Math.max(len[x][y], 1+ dfs(newX, newY, len, matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coins-in-a-line"><a href="#Coins-in-a-line" class="headerlink" title="Coins in a line"></a>Coins in a line</h3><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p>
<p>上面这个问题存在一个特殊的解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param n: an integer</span><br><span class="line">     * @return: a boolean which equals to true if the first player will win</span><br><span class="line">     */</span><br><span class="line">    public boolean firstWillWin(int n) &#123;</span><br><span class="line">        if (n % 3 == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有n个不同价值的硬币排成一条线， 两个参赛者轮流从左边依次拿走1或2个硬币， 直到没有硬币未知。 计算两个人分别拿到的硬币总价值，价值高的人获胜。 请判定第一个玩家是赢还是输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values) &#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    if(values.length==0) return false;</span><br><span class="line">    if(values.length&lt;3) return true;</span><br><span class="line">    // so here we are get to take number from left, so what happens h</span><br><span class="line">    // dp[i] means the max value we can get from i~end;</span><br><span class="line">    </span><br><span class="line">    // choice 1: values[i]+ Math.min(dp[i+2], dp[i+3]);</span><br><span class="line">    // choice 2: values[i]+ values[i+1]+ Math.min(dp[i+3], dp[i+4]);</span><br><span class="line">    int[] dp=new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        dp[i]=Math.max(values[i]+ Math.min((i+2&lt;dp.length?dp[i+2]:0),(i+3&lt;dp.length?dp[i+3]:0)), values[i]+ (i+1&lt;values.length? values[i+1]: 0)+ Math.min((i+3&lt;dp.length?dp[i+3]:0), (i+4&lt;dp.length?dp[i+4]:0)));</span><br><span class="line">    &#125;</span><br><span class="line">    //print(dp);</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int num: values)&#123;</span><br><span class="line">        sum+= num;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0]&gt;sum- dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的做法：</p>
<p>dp[i]: 现在还剩i个硬币， 现在当前取硬币的人最后取硬币价值。</p>
<p>dp[i]= sum[i]-min(dp[i-1], dp[i-2]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean firstWillWin(int[] values)&#123;</span><br><span class="line">    // dp[i]= sum[i]-max(dp[i-1], dp[i-2]);</span><br><span class="line">    int[] sum= new int[values.length];</span><br><span class="line">    int[] dp= new int[values.length];</span><br><span class="line">    for(int i=values.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        sum[i]= (i+1&lt;values.length?sum[i+1]:0)+values[i];</span><br><span class="line">        dp[i]= sum[i]- Math.min((i+1&lt;dp.length?dp[i+1]:0), (i+2&lt;dp.length?dp[i+2]:0));</span><br><span class="line">        //System.out.println(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum[0]-dp[0]&lt;dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目倒不难， 需要注意的是题目叙述中的从左边取， 所以不能从左边开始循环。</p>
<p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p>
<p>Could you please decide the first player win or lose.</p>
<p>Follow-Up: if n is even, is there are any hacky algorithm that can decide whether first player will win or lose in O(1) memory and O(n) time?</p>
<ul>
<li>State:<ul>
<li><code>dp[i][j]</code> 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</li>
</ul>
</li>
<li>Function:<ul>
<li><code>sum[i][j]</code>第i到第j的硬币价值总和</li>
<li><code>dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</code></li>
</ul>
</li>
<li>Initialize:<ul>
<li><code>dp[i][i] = coin[i]</code></li>
</ul>
</li>
<li>Answer:<ul>
<li><code>dp[0][n-1]</code></li>
</ul>
</li>
</ul>
<p>上面这种做法比我之前的想法可能更加好一点？不用去考虑初始状态的特殊性。</p>
<h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><p>There is a stone game. At the beginning of the game, the player picks n piles of stones in a line.</p>
<p>The goal is to merge the stones in one pile observing the following rules:</p>
<ol>
<li>At each step of the game, the player can merge two adjacent piles to a new pile.</li>
<li>The score is the number of stones in the new pile.</li>
</ol>
<p><strong>Example</strong></p>
<p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Merge second and third piles =&gt; [4, 2, 4], score +2</span><br><span class="line">2. Merge the first two piles =&gt; [6, 4]，score +6</span><br><span class="line">3. Merge the last two piles =&gt; [10], score +10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class stonegame &#123;</span><br><span class="line">    public static int getMaxScore(int[] nums)&#123;</span><br><span class="line">        int[][] dp= new int[nums.length][nums.length];</span><br><span class="line">        //int[][] sum= new int[nums.length][nums.length];</span><br><span class="line">        int[] sum= new int[nums.length];</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum[i]= (i&gt;0?sum[i-1]:0)+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int len=1; len&lt;=nums.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len-1&lt;nums.length; i++)&#123;</span><br><span class="line">                int left= i;</span><br><span class="line">                int right= i+len-1;</span><br><span class="line">                if(left!=right)</span><br><span class="line">                    dp[left][right]=Integer.MAX_VALUE;</span><br><span class="line">                for(int mid= left; mid&lt;right; mid++)&#123;</span><br><span class="line">                    dp[left][right]=Math.min(dp[left][mid]+ dp[mid+1][right]+sum[right]-(left&gt;0?sum[left-1]:0), dp[left][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] nums= new int[]&#123;4,4,5,9&#125;;</span><br><span class="line">        System.out.println(getMaxScore(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h3><p>给一个整数数组， 调整每个数的大小，使得相邻的每个数的差不大于一个给的那个的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价之和最小是多少。</p>
<p>ex. [1, 4, 2, 3], target=1=&gt; return, because the optimal res is [2, 3, 2, 3];</p>
<p>这道题目的tag是dp，dp(i, j) means the min cost if we set the ith number to j, and the previous sequence satisfy the condition we have.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class minAdjustCost &#123;</span><br><span class="line">    /**给一个整数数组， 调整每个数的大小， 使得相邻的两个数的差不大于一个</span><br><span class="line">     * 给定的整数target， 调整每个数的代价为调整前后的差的绝对值， 求调整代价</span><br><span class="line">     * 之和最小是多少。**/</span><br><span class="line">    public int MinAdjustmentCost(ArrayList&lt;Integer&gt;A, int target)&#123;</span><br><span class="line">        int n= A.size();</span><br><span class="line">        int[][] f= new int[n+1][101];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;</span><br><span class="line">            f[0][i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">            for(int j=0; j&lt;=100; j++)&#123;</span><br><span class="line">                if(f[i-1][j]!= Integer.MAX_VALUE)&#123;// if the previous is restricted to the condition;</span><br><span class="line">                    for(int k=0; k&lt;=100; k++)&#123;</span><br><span class="line">                        if(Math.abs(j-k)&lt;= target)&#123;</span><br><span class="line">                            if(f[i][k]&gt; f[i-1][j]+Math.abs(A.get(i-1)-k))</span><br><span class="line">                                f[i][k] = f[i-1][j] + Math.abs(A.get(i-1)-k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt;= 100; ++i)</span><br><span class="line">            if (f[n][i] &lt; ans)</span><br><span class="line">                ans = f[n][i];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
<p>其实这道题目就是 merge sort。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int nthUglyNumber(int n) &#123;</span><br><span class="line">        int[] dp= new int[n];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        int index_2= 0;</span><br><span class="line">        int index_3= 0;</span><br><span class="line">        int index_5= 0;</span><br><span class="line">        // we say it&apos;s a merge process;</span><br><span class="line">        for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">            int candidate_2=2* dp[index_2];</span><br><span class="line">            int candidate_3=3* dp[index_3];</span><br><span class="line">            int candidate_5=5* dp[index_5];</span><br><span class="line">            dp[i]= Math.min(Math.min(candidate_2, candidate_3), candidate_5);</span><br><span class="line">            if(dp[i]== candidate_2) index_2++;</span><br><span class="line">            if(dp[i]== candidate_3) index_3++;</span><br><span class="line">            if(dp[i]== candidate_5) index_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树查找树中搜索区间"><a href="#二叉树查找树中搜索区间" class="headerlink" title="二叉树查找树中搜索区间"></a>二叉树查找树中搜索区间</h3><p>给定两个值k1 和 k2(k1&lt;k2)和一个二叉查找树的根节点， 找到树中所有值在k1到k2范围内的所有节点。 即打印所有x(k1&lt;=x&lt;=k2)其中x是二叉查找树中的节点值。 返回所有升序的节点值。</p>
<p>两种方法: 递归/ inorder traversal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param root: param root: The root of the binary search tree</span><br><span class="line">     * @param k1: An integer</span><br><span class="line">     * @param k2: An integer</span><br><span class="line">     * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span><br><span class="line">     */</span><br><span class="line">    // public List&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">    //     // write your code here</span><br><span class="line">    //     if(root==null) return new ArrayList&lt;&gt;();</span><br><span class="line">    //     if(k2&lt;root.val) return searchRange(root.left, k1, k2);</span><br><span class="line">    //     if(k1&gt;root.val) return searchRange(root.right,k1, k2);</span><br><span class="line">    //     List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">    //     List&lt;Integer&gt; left= searchRange(root.left, k1, root.val);</span><br><span class="line">    //     List&lt;Integer&gt; right= searchRange(root.right, root.val,k2);</span><br><span class="line">    //     res.addAll(left);</span><br><span class="line">    //     res.add(root.val);</span><br><span class="line">    //     res.addAll(right);</span><br><span class="line">    //     return res;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, k1, k2, result);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void helper(TreeNode root, int k1, int k2, ArrayList&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line"></span><br><span class="line">        // in-order binary tree iteration</span><br><span class="line">        helper(root.left, k1, k2, result);</span><br><span class="line">        if (k1 &lt;= root.val &amp;&amp; root.val &lt;= k2) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k1, k2, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p>Given an integer array of size n, find all elements that appear more than [n/3] times. The algorithm should run in linear time and in O(1) space.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; majorityElement(int[] nums)&#123;</span><br><span class="line">    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  if(nums.length==0) return res;</span><br><span class="line">  int candidate_1= nums[0];</span><br><span class="line">  int candidate_2= nums[0];</span><br><span class="line">  int count_1=0;</span><br><span class="line">  int count_2=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">	if(nums[i]==candidate_1)&#123;</span><br><span class="line">        count_1++;</span><br><span class="line">    &#125;else if(nums[i]== candidate_2)&#123;</span><br><span class="line">        count_2++;</span><br><span class="line">    &#125;else if(count_1==0)&#123;</span><br><span class="line">        count_1=1;</span><br><span class="line">      	candidate_1=nums[i];</span><br><span class="line">    &#125;else if(count_2==0)&#123;</span><br><span class="line">        count_2=1;</span><br><span class="line">      	candidate_2= nums[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        count_1--;</span><br><span class="line">      	count_2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count_1=0;</span><br><span class="line">  count_2=0;</span><br><span class="line">  for(int num: nums)&#123;</span><br><span class="line">      if(num==candidate_1) count_1++;</span><br><span class="line">    else if(num==candidate_2) count_2++;</span><br><span class="line">  &#125;</span><br><span class="line">  if(count_1&gt; nums.length/3) res.add(candidate_1);</span><br><span class="line">  if(count_2&gt; nums.length/3)</span><br><span class="line">    res.add(candidate_2);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices)&#123;</span><br><span class="line">    int firstBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int firstSell=0;</span><br><span class="line">  	int secondBuy= Integer.MIN_VALUE;</span><br><span class="line">  	int secondSell= 0;</span><br><span class="line">  	for(int price: prices)&#123;</span><br><span class="line">        secondSell= Math.max(secondBuy+price, secondSell);</span><br><span class="line">      	secondBuy= Math.max(firstSell- price, secondBuy);</span><br><span class="line">      	firstSell= Math.max(firstBuy+price, firstSell);</span><br><span class="line">      	firstBuy= Math.max(firstBuy, -price);</span><br><span class="line">    &#125;</span><br><span class="line">  return secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with cooldown</h3><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // state 1: after buy;</span><br><span class="line">        // state 2: after sell;</span><br><span class="line">        // buy[i] means until day i, the last action is buy, the max profit;</span><br><span class="line">        // buy[i]=sell[i-2]-price[i];</span><br><span class="line">        // sell[i] means until day j, the last action is sell, the max profit;</span><br><span class="line">        // sell[i]=buy[i-1]+ price[i];</span><br><span class="line">        if(prices.length==0) return 0;</span><br><span class="line">        int[] buy= new int[prices.length];</span><br><span class="line">        int[] sell= new int[prices.length];</span><br><span class="line">        buy[0]= -prices[0];</span><br><span class="line">        for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">            buy[i]= Math.max(buy[i-1], (i&gt;=2?sell[i-2]:0)-prices[i]);</span><br><span class="line">            sell[i]= Math.max(sell[i-1], buy[i-1]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell[prices.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stock这几道题基本上都是dp+state machine，理清楚状态关系以及迭代就可以成功做出来。</p>
<p>比如下面这一道题目：</p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfix(int[] prices, int fee)&#123;</span><br><span class="line">    int[] buy= new int[prices.length];</span><br><span class="line">  	int[] sell= new int[prices.length];</span><br><span class="line">  	buy[0]= -prices[0];</span><br><span class="line">  	sell[0]= 0;</span><br><span class="line">  	for(int i=1; i&lt;prices.length; i++)&#123;</span><br><span class="line">        buy[i]= Math.max(sell[i-1]-prices[i], buy[i-1]);</span><br><span class="line">      	sell[i]= Math.max(buy[i-1]+prices[i]- fee, sell[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">  	return sell[prices.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三道题目其实都是一样的题目====》 状态的迭代进行更新。</p>
<h3 id="Move-zeros-amp-amp-Sort-Colors"><a href="#Move-zeros-amp-amp-Sort-Colors" class="headerlink" title="Move zeros &amp;&amp; Sort Colors"></a>Move zeros &amp;&amp; Sort Colors</h3><p>这两道题目的思路都是一样的， sort color更需要的注意是对于一些情况的理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums)&#123;</span><br><span class="line">    int p1= 0;</span><br><span class="line">  	int p2= nums.length-1;</span><br><span class="line">  	int index=0;</span><br><span class="line">  	while(index&lt; nums.length)&#123;</span><br><span class="line">        if(nums[index]==0 &amp;&amp; index&gt; p1)&#123;</span><br><span class="line">            swap(p1, index, nums);</span><br><span class="line">          	p1++;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	if(nums[index]==2 &amp;&amp; index&lt;p2)&#123;</span><br><span class="line">            swap(p2, index, nums);</span><br><span class="line">          	p2--;</span><br><span class="line">          	continue;</span><br><span class="line">        &#125;</span><br><span class="line">      	index++;</span><br><span class="line">    &#125;</span><br><span class="line">  	public void swap(int p1, int p2, int nums)&#123;</span><br><span class="line">        int temp= nums[p1];</span><br><span class="line">      	nums[p1]= nums[p2];</span><br><span class="line">      	nums[p2]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所不同的是因为我们还需要对swap过之后的元素进行判断， 也就是说， 我们这里不能直接就像move zero 一样直接move on, 这里是容易出现错误的点。</p>
<p>这里还有一道follow up：</p>
<p>Given an array of integers, remove the duplicate number in it. You should:</p>
<ol>
<li>Do it in place in the array.</li>
<li>Move the unique numbers to the front of the array</li>
<li>Return the total number of the unique numbers.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int deduplicatation(int[] nums)&#123;</span><br><span class="line">  if(nums.length==0) return 0;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  int len=0;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= nums[len])&#123;</span><br><span class="line">      swap(i, ++len, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-220-Contains-Duplicate"><a href="#Leetcode-220-Contains-Duplicate" class="headerlink" title="Leetcode 220. Contains Duplicate"></a>Leetcode 220. Contains Duplicate</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k;</p>
<p>这道题其实是一道很不错的题目， 对于这道题目， 我们可以有两个解法。</p>
<p>解法1： 利用TreeSet, 维持一个k大小的TreeSet， 每次进行查看， 复杂度 O(n lgk);</p>
<p>解法2： 利用bucket sort，限制bucket的大小， 使得处于一个bucket内的两个数字之差不能大于t, 这里我们选取t+1为bucket size， 而后每次查看前后两个两个bucket是否存在符合条件的点（因为两个相邻bucket之间也有可能存在的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">        if(k&lt;1 || t&lt;0) return false;</span><br><span class="line">        Map&lt;Long, Long&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            long remappedNum= (long) nums[i]- Integer.MIN_VALUE;</span><br><span class="line">            long bucket= remappedNum/((long) t +1);</span><br><span class="line">            if(map.containsKey(bucket)</span><br><span class="line">                    || (map.containsKey(bucket-1) &amp;&amp; remappedNum- map.get(bucket-1)&lt;=t)</span><br><span class="line">                    || (map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1)-remappedNum&lt;=t))</span><br><span class="line">                return true;</span><br><span class="line">            if(map.entrySet().size()&gt;=k)&#123;</span><br><span class="line">                long lastBucket=((long) nums[i-k]- Integer.MIN_VALUE)/((long) t+1);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Solution 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t)&#123;</span><br><span class="line">  // floor(x) is the maximum number but still &lt;x</span><br><span class="line">  // ceiling(x) is the minimum number but still&gt;x</span><br><span class="line">    if(nums==null || nums.length==0 || k&lt;=0)  return false;</span><br><span class="line">  final TreeSet&lt;Integer&gt; values= new TreeSet&lt;&gt;();</span><br><span class="line">  for(int ind=0; ind&lt;nums.length; ind++)&#123;</span><br><span class="line">      final Integer floor= values.floor(nums[ind]+ t);</span><br><span class="line">    final Integer ceil= values.ceiling(nums[ind]-t);</span><br><span class="line">    if((floor!=null &amp;&amp; floor&gt;nums[ind])  || (ceil!=null &amp;&amp; ceil&lt;=nums[ind]))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    values.add(nums[ind]);</span><br><span class="line">            if (ind &gt;= k) &#123;</span><br><span class="line">                values.remove(nums[ind - k]);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287. Find the Duplicate Number"></a>Leetcode 287. Find the Duplicate Number</h3><p>Given an array nums containing n+1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int findDuplicate(int[] nums)&#123;</span><br><span class="line">  	int slow= nums[0];</span><br><span class="line">  	int fast= nums[nums[0]];</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">  	fast=0;</span><br><span class="line">  	while(slow!= fast)&#123;</span><br><span class="line">        slow= nums[slow];</span><br><span class="line">      	fast= nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">  	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有一些细节需要注意：</p>
<ol>
<li>对于slow和fast的初始化， 我们为什么要这么设；</li>
<li>在找到交点之后我们为什么又设置为0；</li>
</ol>
<p>以上两点都要从我们对于这道题目原理的理解进行出发开始解答， fast走了多远， slow走了多远， 把带环的linkedlist示意图画出来大概就能理解了。</p>
<h3 id="Leetcode-41-First-Missing-Positive"><a href="#Leetcode-41-First-Missing-Positive" class="headerlink" title="Leetcode 41. First Missing Positive"></a>Leetcode 41. First Missing Positive</h3><p>Given an unsorted integer array, find the first missing positive integer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums)&#123;</span><br><span class="line">  int end= nums.length -1;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">     if(nums[i]==i+1) continue;</span><br><span class="line">     int index= nums[i]-1;</span><br><span class="line">     if(index&gt;=0 &amp;&amp; index&lt;nums.length &amp;&amp; nums[index]!= nums[i])&#123;</span><br><span class="line">       swap(index, i, nums);</span><br><span class="line">       i--;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">    if(nums[i]!= i+1) return i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums.length+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两边扫描的方法， 第一遍扫描， 将可以放入正确slot的值放入其正确的slot， 第二遍扫描， 找到第一个不属于自己地方的num。</p>
<h3 id="Find-Two-missing-numbers"><a href="#Find-Two-missing-numbers" class="headerlink" title="Find Two missing numbers"></a>Find Two missing numbers</h3><p>Given an array of n unique integers where each element in the array is in range(1, n). The array has all distinct elements and size of array is(n-2). Hence Two numbers from the range are missing from this array. Find the two missing numbers.</p>
<p>Below are steps:</p>
<ol>
<li><p>Find XOR of all array elements and natural numbers from 1 to n.</p>
</li>
<li><p>As per the property of XOR, same elements will cancel out and we will be left with the two missing numbers A XOR B. But we don’t know the exact numbers.</p>
</li>
<li><p>A bit is set in XOR only of corresponding bits in A and B are different. This is the crucial step to understand.</p>
</li>
<li><p>We take a set bit in XOR. Let us consider the rightmost set bit in XOR, for example , we miss 2 and 4 in {1, 3, 5, 6}. the OXR we get is 110, then set_bit_no= 010.</p>
</li>
<li><p>Now again if we XOR all the elements of arr[] and 1 to n that have rightmost bit set we will get one of the repeating numbers, say x.</p>
<p>Ex:</p>
<p>Elements in arr[] with bit set: {3, 6}</p>
<p>Elements from 1 to n with bit set {2, 3, 6}</p>
<p>Result of XOR all these is x=2;</p>
</li>
<li><p>Similarly, if we XOR all the elements of arr[] and 1 to n that have rightmost bit not set, we will get the other element, say y.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void findTwoMissingNumbers(int[] arr, int n)&#123;</span><br><span class="line">  int XOR= arr[0];</span><br><span class="line">  for(int i=1; i&lt;n-2; i++)&#123;</span><br><span class="line">    XOR^=arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    XOR^=i;</span><br><span class="line">  &#125;</span><br><span class="line">  //Get a set bit of XOR(we get the rightmost set bit)</span><br><span class="line">  int set_bit_no= XOR &amp; ~(XOR-1);</span><br><span class="line">  // now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element.</span><br><span class="line">  int x=0, y=0;</span><br><span class="line">  for(int i=0; i&lt;n-2; i++)&#123;</span><br><span class="line">    if((arr[i] &amp; set_bit_no)&gt; 0)&#123;</span><br><span class="line">      x= x^arr[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y ^arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">    if((i&amp; set_bit_no)&gt;0)&#123;</span><br><span class="line">      x= x^i;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      y=y^i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // Here we get x and y, which is the result;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。"><a href="#给定一个Double-Linked-List-以及一个装有node指针的array。-如果把前后连续的node，-算作一个block-求在这个array里面有多少个block。" class="headerlink" title="给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。"></a>给定一个Double Linked List, 以及一个装有node指针的array。 如果把前后连续的node， 算作一个block, 求在这个array里面有多少个block。</h3><p>For each node:</p>
<ol>
<li>add node to a HashSet</li>
<li>increment the block count by one.</li>
<li>If the node’s previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counter blocks.</li>
</ol>
<h3 id="What’s-the-time-complexity-of-merge-k-sorted-linked-lists"><a href="#What’s-the-time-complexity-of-merge-k-sorted-linked-lists" class="headerlink" title="What’s the time complexity of merge k sorted linked lists;"></a>What’s the time complexity of merge k sorted linked lists;</h3><p>Given K sorted linked lists of size n each, merge them and print the sorted output.</p>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>A Simple Solution is to initialize result as first list. Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way. Time complexity of this solution is O(N2) where N is total number of nodes, i.e., N = kn.</p>
<h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>A better solution is to use Min Heap based solution. Time complexity of this solution would be O(nk Log k); n is the size of the list.</p>
<h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><p>Merge recursively, the time complexity is just like method 2;</p>
<h3 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472 Concatenated Words"></a>Leetcode472 Concatenated Words</h3><p>Given a list of words(without duplicates). Please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of least shorter words in the given array,</p>
<p>其实这道题目本质上就是wordbreak， 用wordbreak的思路就能做出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        if(words.length==0) return res;</span><br><span class="line">        Arrays.sort(words, (s1, s2)-&gt;&#123;</span><br><span class="line">            return s1.length()- s2.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        Set&lt;String&gt; dict= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i=0; i&lt;words.length; i++)&#123;</span><br><span class="line">            if(canForm(dict, words[i]))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dict.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean canForm(Set&lt;String&gt; dict, String word)&#123;</span><br><span class="line">        if(dict.size()==0) return false;</span><br><span class="line">        boolean[] dp= new boolean[word.length()+1];</span><br><span class="line">        dp[0]= true;</span><br><span class="line">        for(int i=1; i&lt;=word.length(); i++)&#123;</span><br><span class="line">            for(int j=i-1; j&gt;=0; j--)&#123;</span><br><span class="line">                if(!dp[j]) continue;</span><br><span class="line">                if(dict.contains(word.substring(j, i)))&#123;</span><br><span class="line">                    dp[i]= true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="491-Increasing-subsequence"><a href="#491-Increasing-subsequence" class="headerlink" title="491. Increasing subsequence"></a>491. Increasing subsequence</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.</p>
<p>这道题目， 属于对于去重的考察比较好的一道题目， 为了完成去重， 我们要确定， 每一次加进去的数字都是第一次被访问的。 并且， 这是一个未排序的数列， 所以只能用hashset来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        helper(0, nums, new ArrayList&lt;&gt;(), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void helper(int pos, int[] nums, List&lt;Integer&gt; unit, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        if(unit.size()&gt;=2)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(unit));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; used= new HashSet&lt;&gt;();</span><br><span class="line">        for(int i= pos; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(used.contains(nums[i])) continue;</span><br><span class="line">            if(unit.size()==0 || unit.get(unit.size()-1)&lt;=nums[i])&#123;</span><br><span class="line">                used.add(nums[i]);</span><br><span class="line">                unit.add(nums[i]);</span><br><span class="line">                helper(i+1, nums, unit, res);</span><br><span class="line">                unit.remove(unit.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zuma-Game"><a href="#Zuma-Game" class="headerlink" title="Zuma Game"></a>Zuma Game</h3><p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>
<p>Each time, you may choose a ball in your hand, and insert it into the row(including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>
<p>Find the minimum balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&apos;t exceed 5&quot;</span><br><span class="line"></span><br><span class="line">public int findMinStep(String board, String hand) &#123;</span><br><span class="line">    int[] handCount = new int[26];</span><br><span class="line">    for (int i = 0; i &lt; hand.length(); ++i) ++handCount[hand.charAt(i) - &apos;A&apos;];</span><br><span class="line">    int rs = helper(board + &quot;#&quot;, handCount);  // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.</span><br><span class="line">    return rs == MAXCOUNT ? -1 : rs;</span><br><span class="line">&#125;</span><br><span class="line">private int helper(String s, int[] h) &#123;</span><br><span class="line">    s = removeConsecutive(s);     </span><br><span class="line">    if (s.equals(&quot;#&quot;)) return 0;</span><br><span class="line">    int  rs = MAXCOUNT, need = 0;</span><br><span class="line">    for (int i = 0, j = 0 ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        if (s.charAt(j) == s.charAt(i)) continue;</span><br><span class="line">        need = 3 - (j - i);     //balls need to remove current consecutive balls.</span><br><span class="line">        if (h[s.charAt(i) - &apos;A&apos;] &gt;= need) &#123;</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] -= need;</span><br><span class="line">            rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));</span><br><span class="line">            h[s.charAt(i) - &apos;A&apos;] += need;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br><span class="line">//remove consecutive balls longer than 3</span><br><span class="line">private String removeConsecutive(String board) &#123;</span><br><span class="line">    for (int i = 0, j = 0; j &lt; board.length(); ++j) &#123;</span><br><span class="line">        if (board.charAt(j) == board.charAt(i)) continue;</span><br><span class="line">        if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));</span><br><span class="line">        else i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    return board;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解， 每次计算需要多少个球进行一次消失， 然后对board进行更新。进行递归计算。</p>
<h3 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210. Course Schedule II"></a>Leetcode 210. Course Schedule II</h3><p>除了喜闻乐见的bfs（即 topologic sort）做法来完成这一道题， 还可以用dfs来做， 所不同的是， 我们在这里用stack进行递归， 这样保证， 如果p-&gt;q, 那么p肯定属于stack的外层， 也就是说 整个stack的结构肯定是符合Schedule的。 这个做法还是非常之骚气的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   boolean hasCycle=false;</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites)&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map= new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        for(int[] prerequisite: prerequisites)&#123;</span><br><span class="line">            int curr=prerequisite[0];</span><br><span class="line">            int prev=prerequisite[1];</span><br><span class="line">            if(!map.containsKey(prev))&#123;</span><br><span class="line">                map.put(prev, new ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(prev).add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int[] visited= new int[numCourses];</span><br><span class="line">        for(int i=0; i&lt;numCourses; i++)&#123;</span><br><span class="line">            dfs(i, visited, map, stack);</span><br><span class="line">            if(hasCycle) return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[stack.size()];</span><br><span class="line">        int index=0;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            res[index++]=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int curr,int[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; map, Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">        if(visited[curr]==1)&#123;</span><br><span class="line">            hasCycle=true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(visited[curr]==-1) return;</span><br><span class="line">        if(!map.containsKey(curr))&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            visited[curr]=-1;</span><br><span class="line">            return;</span><br><span class="line">            // we have find the terminate, which means the end of one chain;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[curr]=1;</span><br><span class="line">        List&lt;Integer&gt; next= map.get(curr);</span><br><span class="line">        for(int num: next)&#123;</span><br><span class="line">            dfs(num, visited, map, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curr);</span><br><span class="line"></span><br><span class="line">        // post order</span><br><span class="line">        visited[curr]=-1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-57-Insert-Interval"><a href="#Leetcode-57-Insert-Interval" class="headerlink" title="Leetcode 57. Insert Interval"></a>Leetcode 57. Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals(merge if necessary). You may assume that the intervals were initially sorted according to their start time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        List&lt;Interval&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        Interval prev= newInterval;</span><br><span class="line">        for(Interval curr: intervals)&#123;</span><br><span class="line">            if(prev==null)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.end&lt;prev.start)&#123;</span><br><span class="line">                res.add(curr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev!= null &amp;&amp; curr.start&lt;=prev.end)&#123;</span><br><span class="line">                prev.start = Math.min(prev.start,curr.start);</span><br><span class="line">                prev.end= Math.max(prev.end, curr.end);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.add(prev);</span><br><span class="line">                res.add(curr);</span><br><span class="line">                prev= null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prev!=null) res.add(prev);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清楚思路， 对于这道题， 我们所要完成的功能是把interval插进去。</p>
<ol>
<li>interval 已经插入过了， 那么interval是null， 我们直接continue;</li>
<li>interval在左边， 我们插入interval， 插入当前， 然后将interval置为null,表示已经插入过了。</li>
<li>interval在右边， 我们将curr插入， 继续遍历。</li>
<li>interval和当前重叠， 我们将curr 与interval merge， 作为新的interval；</li>
</ol>
<h3 id="Leetcode-630-Course-Schedule-III"><a href="#Leetcode-630-Course-Schedule-III" class="headerlink" title="Leetcode 630 Course Schedule III"></a>Leetcode 630 Course Schedule III</h3><p>There are n different online courses numbered from 1 to n. Each course has some duration(course length) t, and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given n online courses represented by pairs(t, d), your task is to find the maximal number of courses that can be taken;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">  public int scheduleCourse(int[][] courses)&#123;</span><br><span class="line">    Arrays.sort(courses, (a, b)-&gt; a[1]-b[1]);// sort the courses by their deadlines. Greedy! We have to deal with courses with early deadlines first</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;&gt;((a, b)-&gt; b-a);</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int[] c: courses)&#123;</span><br><span class="line">      time+=c[0];</span><br><span class="line">      pq.add(c[0]);</span><br><span class="line">      if(time&gt;c[1]) time-=pq.poll();// if time exceeds, drop the previous course which costs the most time.</span><br><span class="line">    &#125;</span><br><span class="line">    return pq.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题算是比较蛋疼的了。 记住做法就是了， 每一步， 我们先放入队列中， 如果发现不能满足条件的话， 我们删除占用时间最多的， 这样的话得到的结果总是最好的。</p>
<p>其实还是比较intuitive的。</p>
<h3 id="Leetcode-621-Task-Scheduler"><a href="#Leetcode-621-Task-Scheduler" class="headerlink" title="Leetcode 621. Task Scheduler"></a>Leetcode 621. Task Scheduler</h3><p>其实这道题目， 如果能够理解题目的话， 并不难。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int leastInterval(char[] tasks, int n)&#123;</span><br><span class="line">  int[] c= new int[26];</span><br><span class="line">  for(char t: tasks)&#123;</span><br><span class="line">    c[t-&apos;A&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(c);</span><br><span class="line">  int i=25;</span><br><span class="line">  while(i&gt;=0 &amp;&amp; c[i]==c[25]) i--;</span><br><span class="line">  return Math.max(tasks.length, (c[25]-1)*(n+1)+25-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于形成了一个框架， 然后往这个框架里面放元素。</p>
<h3 id="Leetcode-546-Remove-Boxes"><a href="#Leetcode-546-Remove-Boxes" class="headerlink" title="Leetcode 546. Remove Boxes"></a>Leetcode 546. Remove Boxes</h3><p>Given several boxes with different colors represented by different positive numbers.</p>
<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color(composed of k boxes, k&gt;=1), remove them and get k*k points.</p>
<p>Find the maximum points you can get.</p>
<p>暴力 backtracking 做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeBoxes(int[] boxes) &#123;</span><br><span class="line">        if(boxes.length==0) return 0;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int box: boxes)&#123;</span><br><span class="line">            list.add(box);</span><br><span class="line">        &#125;</span><br><span class="line">        return removeBoxes(list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int removeBoxes(List&lt;Integer&gt; boxes)&#123;</span><br><span class="line">        if(boxes.size()==0) return 0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;boxes.size(); i++)&#123;</span><br><span class="line">            int start=i;</span><br><span class="line">            while(i&lt;boxes.size() &amp;&amp; boxes.get(i)==boxes.get(start)) i++;</span><br><span class="line">            List&lt;Integer&gt; next= new ArrayList&lt;&gt;();</span><br><span class="line">            for(int idx=0; idx&lt;boxes.size(); idx++)&#123;</span><br><span class="line">                if(idx&gt;=start &amp;&amp; idx&lt;i) continue;</span><br><span class="line">                next.add(boxes.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res, removeBoxes(next)+ (i-start)*(i-start));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top-down dp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int remooveBoxes(int[] boxes)&#123;</span><br><span class="line">  int n= boxes.length;</span><br><span class="line">  int[][][] dp= new int[n][n][n];</span><br><span class="line">  return removeBoxesSum(boxes, 0, n-1, 0, dp);</span><br><span class="line">&#125;</span><br><span class="line">private int removeBoxesSub(int[] boxes, int i, int j, int k, int[][] dp)&#123;</span><br><span class="line">  if(i&gt;j) return 0;</span><br><span class="line">  if(dp[i][j][k]&gt;0) return dp[i][j][k];</span><br><span class="line">  for(; i+1&lt;= j &amp;&amp; boxes[i+1]==boxes[i], i++, k++);// optimization: all boxes of the same color counted continuously from the first box should be grouped together;</span><br><span class="line">  int res=(k+1)*(k+1)+ removeBoxesSub(i+1, j. 0, dp);</span><br><span class="line">  for(int m= i+1; m&lt;=j; m++)&#123;</span><br><span class="line">    if(boxes[i]==boxes[m])&#123;</span><br><span class="line">      res= Math.max(res, removeBoxesSub(boxes, i+1, m-1, 0, dp)+ removeBoxesSub(boxes, m, j, k+1, dp));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> dp[i][j][k]= res;</span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k)&#123;</span><br><span class="line">  int[] count= new int[128];</span><br><span class="line">  int max=0;</span><br><span class="line">  int start=0;</span><br><span class="line">  for(int end=0; end&lt; s.length(); end++)&#123;</span><br><span class="line">    max= Math.max(max, ++count[s.charAt(end)]);</span><br><span class="line">    if(max+k&lt;=end-start)&#123;</span><br><span class="line">      count[s.charAt(start++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s.length()- start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n);</p>
<p>For example:</p>
<p>S=”ADOBECODEBANC”</p>
<p>T=”ABC”</p>
<p>Minimum window is “BANC”</p>
<p>这道题是window的一道很经典的题目了， 碰到这种题目的时候， 我们需要让window满足一个性质， 然后移动左右边界去更新。 得到我们想要的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t)&#123;</span><br><span class="line">  int count=0;</span><br><span class="line">  int[] cnt= new int[256];</span><br><span class="line">  for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">    cnt[t.charAt(i)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  int left= 0;</span><br><span class="line">  int min= Integer.MAX_VALUE;</span><br><span class="line">  String res= &quot;&quot;;</span><br><span class="line">  for(int right= 0; right&lt;s.length(); right++)&#123;</span><br><span class="line">    cnt[s.charAt(right)]--;</span><br><span class="line">    if(cnt[s.charAt(right)]&gt;=0) count++;</span><br><span class="line">    while(count&gt;= t.length())&#123;</span><br><span class="line">      if(right-left+1&lt;min)&#123;</span><br><span class="line">        min= right- left+1;</span><br><span class="line">        res=s.substring(left, right+1);</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[s.charAt(left)]++;</span><br><span class="line">      if(cnt[s.charAt(left)]&gt;0) count--;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-84-Largest-Rectangle-in-Histogram"><a href="#Leetcode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="Leetcode 84. Largest Rectangle in Histogram"></a>Leetcode 84. Largest Rectangle in Histogram</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>这道题目很经典， 在面试的时候stack基本都是这样用， 用来维持一个顺序， 我们在这里维持一个递增的stack， 每次发现数字比栈顶的数字要小的情况时， 对于栈顶而言， 我们找到了以栈顶为最高点的最大的长方形， 因此该长方形面积也能算出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        //maintain a stack which is strictly non-decreasing</span><br><span class="line">        int[] arr= new int[heights.length+1];</span><br><span class="line">        for(int i=0; i&lt;heights.length; i++)&#123;</span><br><span class="line">            arr[i]=heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack= new Stack&lt;&gt;();</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&gt;arr[i])&#123;</span><br><span class="line">                int height= arr[stack.pop()];</span><br><span class="line">                int right=i-1;</span><br><span class="line">                int left=(stack.isEmpty()?-1:stack.peek())+1;</span><br><span class="line">               //System.out.println(&quot;height=&quot;+ height);</span><br><span class="line">               // System.out.println(&quot;width=&quot;+ (right-left+1));</span><br><span class="line">                res= Math.max(res, (right-left+1)* height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-218-the-skyline-problem"><a href="#Leetcode-218-the-skyline-problem" class="headerlink" title="Leetcode 218 the skyline problem"></a>Leetcode 218 the skyline problem</h3><p>在这道题里面， 我们给定了每个建筑的位置以及高度， 要我们输出一系列点（天际线）： A key point is the left endpoint of a horizontal line segment.</p>
<p>想法：</p>
<p>for position in sorted(all start points and all end points)</p>
<p>if this position is a start point:</p>
<p> add its height</p>
<p>if this position is a end point:</p>
<p> delete its height</p>
<p>Compare current max height with previous height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;int[]&gt; getSkyline(int[][] buildings)&#123;</span><br><span class="line">  List&lt;int[]&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;int[]&gt; height= new ArrayList&lt;&gt;();</span><br><span class="line">  for(int[] b: buildings)&#123;</span><br><span class="line">    height.add(new int[]&#123;b[0], -b[2]&#125;);</span><br><span class="line">    height.add(new int[]&#123;b[1], b[2]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(height, (a, b)-&gt;&#123;</span><br><span class="line">    if(a[0]==b[0])&#123;</span><br><span class="line">      return a[1]-b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0]-b[0];</span><br><span class="line">  &#125;);</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq= new PriorityQueue&lt;Integer&gt;((a, b)-&gt;&#123;return b-a;&#125;);</span><br><span class="line">  pq.offer(0);</span><br><span class="line">  int prev_max=0;</span><br><span class="line">  for(int[] h: height)&#123;</span><br><span class="line">    if(h[1]&lt;0)&#123;</span><br><span class="line">      pq.offer(-h[1]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pq.remove(h[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int max= pq.peek();</span><br><span class="line">    if(prev_max!= max)&#123;</span><br><span class="line">      res.add(new int[]&#123;h[0], max&#125;);</span><br><span class="line">      prev_max= max;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-239-Sliding-Window-Maximum"><a href="#Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="Leetcode 239. Sliding Window Maximum"></a>Leetcode 239. Sliding Window Maximum</h3><p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>这道题目还是关于stack的题目， 所不同的是， 由于其特殊性， 这个栈的大小不能大于k， 所以在这里， 我们维持一个不大于k且递减的栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        // maintain a decreasing linkedlist;</span><br><span class="line">        if(nums.length==0) return new int[0];</span><br><span class="line">        Deque&lt;Integer&gt; deque= new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res= new int[nums.length- k+1];</span><br><span class="line">        int index=0;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            while(deque.size()!=0 &amp;&amp; nums[i]&gt;nums[deque.peekLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            if(i-deque.peekFirst()+1&gt;k)&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&gt;=k-1) res[index++]= nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315. Count of Smaller Numbers After Self."></a>Leetcode 315. Count of Smaller Numbers After Self.</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p>这道题可以用不同的方式来做， 比如说建树， merge sort， binarySearch等等， 这里我们使用建树和binarySearch两种方式来做。</p>
<h4 id="buildTree"><a href="#buildTree" class="headerlink" title="buildTree:"></a>buildTree:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        int val;</span><br><span class="line">        int size; // to kept the size node on his left;</span><br><span class="line">        int duplicate;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.size=0;</span><br><span class="line">            this.duplicate=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(nums.length==0) return res;</span><br><span class="line">        TreeNode root= new TreeNode(nums[nums.length-1]);</span><br><span class="line">        res.add(0);</span><br><span class="line">        for(int i=nums.length-2; i&gt;=0; i--)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(nums[i]);</span><br><span class="line">            insert(root, node, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode insert(TreeNode root, TreeNode node, int curr, List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.val&gt;root.val)&#123;</span><br><span class="line">            curr+=root.size+root.duplicate;</span><br><span class="line">            root.right=insert(root.right, node, curr, res);</span><br><span class="line">        &#125;else if(node.val==root.val)&#123;</span><br><span class="line">            root.duplicate++;</span><br><span class="line">            res.add(root.size+curr);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root.size++;</span><br><span class="line">            root.left=insert(root.left, node, curr, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= nums.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">            int index= findIndex(list, nums[i]);</span><br><span class="line">            //System.out.println(index);</span><br><span class="line">            res.add(index);</span><br><span class="line">            if(index==list.size()) list.add(nums[i]);</span><br><span class="line">            else list.add(index, nums[i]);</span><br><span class="line">            //System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findIndex(List&lt;Integer&gt; list, int target)&#123;</span><br><span class="line">        int lo= 0;</span><br><span class="line">        int hi= list.size()-1;</span><br><span class="line">        while(lo&lt;=hi)&#123;</span><br><span class="line">            int mid= lo+(hi- lo)/2;</span><br><span class="line">            if(list.get(mid)&lt;target)&#123;</span><br><span class="line">                lo= mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                hi= mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种做法可以延伸至 reverse pairs 这一道题目。</p>
<h3 id="Leetcode-312-Burst-Balloons"><a href="#Leetcode-312-Burst-Balloons" class="headerlink" title="Leetcode 312. Burst Balloons"></a>Leetcode 312. Burst Balloons</h3><p>注意思维方式： 我们关注的是最后一个爆掉的气球。 关于dp的话， 注意边界和构造就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int[] arr= new int[nums.length+2];</span><br><span class="line">        arr[0]=1;</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            arr[i+1]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[nums.length+1]=1;</span><br><span class="line">        int[][] dp= new int[arr.length][arr.length];</span><br><span class="line">        for(int len=2;  len&lt;=arr.length; len++)&#123;</span><br><span class="line">            for(int i=0; i+len&lt;arr.length; i++)&#123;</span><br><span class="line">                int start= i;</span><br><span class="line">                int end=i+len;</span><br><span class="line">                for(int j= start+1; j&lt;end; j++)&#123;</span><br><span class="line">                    dp[start][end]= Math.max(dp[start][j]+ dp[j][end]+ arr[start]*arr[end]*arr[j], dp[start][end]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set-Intersection-Size-At-least-Two"><a href="#Set-Intersection-Size-At-least-Two" class="headerlink" title="Set Intersection Size At least Two"></a>Set Intersection Size At least Two</h3><p>An integer interval {a, b}( for integers a&lt;b) is a set of all consecutive integers from a to b, including a and b.</p>
<p>Find the minimum size of a set S such that for every integer intervals A in intervals, the intersection of S with A has size at east 2.</p>
<p>Example 1:</p>
<p>Input: intervals[[1, 3], [1, 4], [2, 5], [3,5]]</p>
<p>Output: 3</p>
<p>思路， 在选择区间中的元素时， 我们可以随意选， 但随意选的后果就是不能让set最优， 所以可以从侧面反映出如果有规则的选择， 可能达到全局最优。 一个思路： 对end进行排序， 这样我们就能根据end进行规则的选择了。</p>
<ol>
<li>很明显， 对于待选区间， 如果之前没有元素被选择过， 那么一定选择最后两个元素， 这样能够覆盖的后续区间最多， 不过这个时候需要判断一下， 选择两个元素之后， 后续区间是否都包含该两个元素。 包含一个+1， 包含两个+2， 不包含则跳出。</li>
<li>对于一个元素被选择了， 我们依旧选取当前区间的最后一个元素，不过此时只选择了一个， 所以只需要测试后续区间是否包含该元素即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class P implements Comparable&lt;P&gt;&#123;</span><br><span class="line">  int s;</span><br><span class="line">  int e;</span><br><span class="line">  int c;</span><br><span class="line">  P(int s, int e)&#123;</span><br><span class="line">    this.s= s;</span><br><span class="line">    this.e= e;</span><br><span class="line">    this.c=0;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int compareTo(P o)&#123;</span><br><span class="line">    return this.e- o.e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public int intersectionSizeTwo(int[][] intervals)&#123;</span><br><span class="line">  List&lt;P&gt; ps= new ArrayList&lt;&gt;();</span><br><span class="line">  int n= intervals.length;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    ps.add(new P(intervals[i][0], intervals[i][1]));</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(ps);</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">    P inter= ps.get(i);</span><br><span class="line">    if(inter.c==0)&#123;</span><br><span class="line">      int pos= i+1;</span><br><span class="line">      // the first point we choose the end of curr</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;=inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++; </span><br><span class="line">        if(ps.get(pos).s&lt;=inter.e-1)&#123;</span><br><span class="line">          ps.get(pos).c++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res+=2;</span><br><span class="line">    &#125;else if(inter.c==1)&#123;</span><br><span class="line">      int pos=i+1;</span><br><span class="line">      while(pos&lt;n &amp;&amp; ps.get(pos).s&lt;= inter.e)&#123;</span><br><span class="line">        ps.get(pos).c++;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是之前intervals问题的推广版本， 我们每次选点都要求局部最优， 也就是选择最后两个点， 然后排除之后的点再次进行选择。 还是很具有价值的一道题目。</p>
<h3 id="Leetcode-173-Binary-Search-Tree-Iterator"><a href="#Leetcode-173-Binary-Search-Tree-Iterator" class="headerlink" title="Leetcode 173. Binary Search Tree Iterator"></a>Leetcode 173. Binary Search Tree Iterator</h3><p>Implement an iterator over a binary search tree(BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.</p>
<p>next() and hasNext() should run in average O(1) and uses O(h) memory, where h is the height of the tree.</p>
<h3 id="Leetcode-285-Inorder-Successor-in-BST"><a href="#Leetcode-285-Inorder-Successor-in-BST" class="headerlink" title="Leetcode 285. Inorder Successor in BST"></a>Leetcode 285. Inorder Successor in BST</h3><p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>If the given node has no in-order successor in the tree, return null.</p>
<p>MySolution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;</span><br><span class="line">        if(root==null) return null;</span><br><span class="line">        if(p.right!=null)&#123;</span><br><span class="line">            TreeNode node= p.right;</span><br><span class="line">            while(node.left!= null)&#123;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;       </span><br><span class="line">        TreeNode node= root;</span><br><span class="line">        TreeNode prev= null;</span><br><span class="line">        while(node!= null)&#123;</span><br><span class="line">            if(node.val&lt;=p.val)&#123;</span><br><span class="line">                node=node.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                prev= node;</span><br><span class="line">                node= node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Successor"><a href="#Successor" class="headerlink" title="Successor"></a>Successor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode successor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&lt;=p.val)&#123;</span><br><span class="line">    return successor(root.right, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode left= successor(root.left, p);</span><br><span class="line">    return( left!= null)? left: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Predecessor"><a href="#Predecessor" class="headerlink" title="Predecessor"></a>Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode predecessor(TreeNode root, TreeNode p)&#123;</span><br><span class="line">  if(root==null) return null;</span><br><span class="line">  if(root.val&gt;= p.val)&#123;</span><br><span class="line">    return predecessor(root.left, p);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    TreeNode right= predecessor(root.right, p);</span><br><span class="line">    return (right!= null) ? right: root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/02/03/Java线程简介/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/02/03/Node.js 学习笔记/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Liyan Chen's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        youremail@email.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                Home
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    Archives
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/02/">February 2018<span class="sidebar_archives-count">13</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            Theme - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Sisyphus
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
