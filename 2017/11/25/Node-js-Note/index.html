<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="如何理解node.js 的单线程node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not  a problem.  Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js Note">
<meta property="og:url" content="http://yoursite.com/2017/11/25/Node-js-Note/index.html">
<meta property="og:site_name" content="Rock of SisyPhus">
<meta property="og:description" content="如何理解node.js 的单线程node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not  a problem.  JavaScript的单线程， 与它的用途相关。 作为浏览器脚本语言， JavaScri">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2017-12-04T06:37:25.639Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node.js Note">
<meta name="twitter:description" content="如何理解node.js 的单线程node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not  a problem.  JavaScript的单线程， 与它的用途相关。 作为浏览器脚本语言， JavaScri">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/25/Node-js-Note/"/>





  <title>Node.js Note | Rock of SisyPhus</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock of SisyPhus</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/25/Node-js-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liyan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock of SisyPhus">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Node.js Note</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-25T15:34:19-08:00">
                2017-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="如何理解node-js-的单线程"><a href="#如何理解node-js-的单线程" class="headerlink" title="如何理解node.js 的单线程"></a>如何理解node.js 的单线程</h2><p>node.js is single threaded which means your application runs on one single thread.But since we have non-blocking IO that’s not  a problem. </p>
<p>JavaScript的单线程， 与它的用途相关。 作为浏览器脚本语言， JavaScript的主要用途是与用户互动， 以及操作DOM。 这就决定了它只能是单线程， 否则会带来很复杂的同步问题。</p>
<p>比如， 假设JavaScript同时有两个线程， 一个线程在某个DOM节点上添加内容， 另一个线程删除了这个节点， 那么这时浏览器应该以哪个线程为准？</p>
<p>所以， 为了避免复杂性， 从一诞生， JavaScript就是单线程， 这已经成了这门语言的核心特征， 将来也不会改变。</p>
<p>为了利用多核CPU的计算能力， HTML5提出WEB Worker标准， 允许javaScript脚本创建多个线程， 但是子线程完全受主线程控制， 且不得操作DOM。</p>
<p>所以， 这个新标准并没有改变JavaScript单线程的本质。</p>
<p>单线程就意味着， 所有任务需要排队， 前一个任务结束， 才会执行后一个任务。 如果前一个任务耗时很长， 后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大， CPU忙不过来， 倒也算了， 但是很多时候CPU是闲着的， 因为IO设备很慢（比如Ajax操作从网络读取数据）， 不得不等着结果出来， 再往下执行。</p>
<p>JavaScript语言的设计者意识到， 这时主线程完全可以不管IO设备， 挂起处于等待中的任务， 先运行排在后面的任务。 等到IO设备返回了结果， 再回过头， 把挂起的任务继续执行下去。</p>
<p>于是， 所有任务可以分成两种， 一种是同步任务（synchronous）, 另一种是异步任务（asynchronous）。</p>
<blockquote>
<p>同步任务指的是， 在主线程上排队执行的任务， 只有前一个任务执行完毕， 才能执行后一个任务；</p>
<p>异步任务指的是， 不进入主线程， 而进入任务队列的任务， 只有任务队列通知主线程， 某个异步任务可以执行了， 该任务才会进入主线程执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for函数循环10此， 每循环以下就执行一次setTimeOut， 也就是执行了10次setTimeout， 每次setTimeout执行后， 知识将里面的function放进一个队列里， 也就是往队列里面放了10个function， 把这10个function放进队列， 但都没有直接运行， 等待后面所有的程序执行完之后， 再去询问队列里面有没有东西，如果有再去执行， 所以for循环之后， i值就变成了10， 所以会输出10个10；</p>
<p>综上述， 隐含着一个意思， 即触发的每个事件都会位于堆栈的最底部。</p>
<ol>
<li>所有同步任务都在主线程上执行， 形成一个执行栈（execution context stack）。</li>
<li>主线程之外， 还存在一个任务队列。 只要异步任务有了任务结果， 就在任务队列之中放置一个时间。</li>
<li>一旦执行栈中的所有同步任务执行完毕， 系统就会读取“任务队列”， 看看里面有哪些时间。 哪些对应的异步任务。 于是结束等待状态， 进入执行栈， 开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p>这就是JavaScript运行机制。</p>
<p>主线程从任务队列中读取事件， 这个过程是循环不断的， 所以整个的这种运行机制又称为Event Loop。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="noopener">JavaScript是单线程的深入理解</a></p>
<hr>
<h2 id="Node-js-调试工具"><a href="#Node-js-调试工具" class="headerlink" title="Node.js 调试工具"></a>Node.js 调试工具</h2><h3 id="Node-inspect"><a href="#Node-inspect" class="headerlink" title="Node inspect"></a>Node inspect</h3><h3 id="Node-–inspect-brk-Chrome-Dev-Tools"><a href="#Node-–inspect-brk-Chrome-Dev-Tools" class="headerlink" title="Node –inspect-brk(Chrome Dev Tools)"></a>Node –inspect-brk(Chrome Dev Tools)</h3><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27" target="_blank" rel="noopener">Debugging Node.js with Chrome DevTools</a></p>
<p><a href="http://www.jianshu.com/p/611e7be13655" target="_blank" rel="noopener">Node.js 调试方法</a></p>
<h2 id="Intro-to-ES6"><a href="#Intro-to-ES6" class="headerlink" title="Intro to ES6"></a>Intro to ES6</h2><h2 id="Promise-and-Callback"><a href="#Promise-and-Callback" class="headerlink" title="Promise and Callback"></a>Promise and Callback</h2><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>要理解callback的概念， 我们先要理解同步， 异步， 阻塞， 非阻塞的概念。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://larry850806.github.io/2016/06/16/nodejs-async/" target="_blank" rel="noopener">理解Node.js事件驱动</a></p>
<p><a href="http://larry850806.github.io/2016/05/31/async/" target="_blank" rel="noopener">如何使用async控制流程</a></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在开始谈论正题之前，我们先来看看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">    step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">        step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">            step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Do something with value4</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>是不是感觉很恐怖，随着嵌套的回调函数增加，结尾会有大量的花括号和圆括号 }); 出现。(Callback 地狱)</p>
<p>在javascript中实现异步最简单的方式是Callback。遗憾的是，这种编程方式牺牲了控制流，同时你也不能throw new Error()并在外部捕获异常。 Promise的出现解决了这两个需求，又保持了javascript异步的优势，不同于Fiber这种多线程的实现方式，Promise只是一种编程方式的变化。而无须在底层改变。</p>
<p>CommonJS的规范提到了多种Promise，我们只介绍其中一种的实现q (<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a>)</p>
<p>我们在这里不讲解抽象的Promise规范，这多半是实现者应该关心的，我们直接从示例入手，如果你有兴趣，可以参见<a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a>。</p>
<p>q的核心是一个promise对象的then方法，他接受两个回调方法，一个promise被定义之后有3种状态，pending（过渡状态），fullfilled（完成状态），rejected(错误状态)。一个promise只能是这三种状态种的一种，而无法是他们的混合状态。</p>
<ul>
<li>pending状态可以理解为promise还没有获得确定值，就相当于一个任务还没有完成。</li>
<li>fullfilled状态可以理解为完成并返回结果。这时then(onFullfilled, onRejected)的onFullfilled方法会被调用。</li>
<li>rejected状态可以理解为错误，并结束。返回错误。这时then(onFullfilled, onRejected)的onRejected方法会被调用。</li>
</ul>
<p>了解了核心思想后，我们来看一个例子，在这个例子中我们先读取一个json文本文件，然后将其解析成javascript对象，最后这个对象进行修改再保存回去。 按照传统的callback写法，有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'example.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err):</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">      obj.prop = <span class="string">'something new'</span>;</span><br><span class="line">      fs.writeFile(<span class="string">'example.json'</span>, <span class="built_in">JSON</span>.stringify(obj), <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，控制流被切割成多个部分（每次异步都要处理一次错误），并且 <strong>JSON.parse</strong> 的错误必须在内部捕获，但却不能跑到外部。因为在异步回调中无法抛出异常。 现在当我们使用promise的时候，假设我们有个能够返回一个 <em>promise</em> 对象的 <strong>readFile</strong> 和 <strong>writeFile</strong> 方法。那么上面的代码就可以变成如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = readFile();</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// we don't need to catch error. in other words. we can throw error in this callback.</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">  obj.prop = <span class="string">'something new'</span>;</span><br><span class="line">  <span class="comment">// return a promise. so we can chain the then() method.</span></span><br><span class="line">  <span class="keyword">return</span> writeFile(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// all error will fall down here.</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们首先从 <strong>readFile()</strong> 方法里获得了一个返回的 <em>promise</em> 对象，然后使用这个对象的 <strong>then()</strong> 方法。在这里，我们只传入了一个 <strong>onFullfilled</strong>回调方法，根据Promise/A+的文档。<strong>then()</strong> 一定会返回一个 <em>promise</em> 对象，所以我们又连接了一个 <strong>then()</strong> ，由于这个 <strong>then()</strong> 是最后一个，所以我们需要在这里提供一个 <strong>onRejected()</strong> 回调方法来处理所有的错误。在第一个 <strong>onFullfilled()</strong>回调方法中，我们返回了一个 <em>promise</em> ，这个 <em>promise</em> 的处理结果将会在下一个 <strong>then()</strong> 的 <strong>onFullfilled()</strong> 方法中取得。</p>
<p>这段代码执行的时候，当任意位置抛出异常的时候，最后一个then的 <strong>onRejected</strong> 回调会被执行。否则一切按照从上至下的顺序执行，整个控制流都十分简洁明了。</p>
<p>因为 <strong>then()</strong> 方法必须返回一个promise，实际上我们也可以结合同步方法返回一个已经fullfilled的promise 比如下面这个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = readFile();</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.prop = <span class="string">'something new'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面例子中第二个then会在第一个then返回之后被执行，因为第一个then返回的时候，由于JSON.parse是同步方法，所以返回了一个值，这个值会被包装成一个fullfilled的promise.</p>
<h4 id="制作promise的API"><a href="#制作promise的API" class="headerlink" title="制作promise的API"></a>制作promise的API</h4><p>上面例子中我们知道了如何使用promise提供的核心方法 <strong>then()</strong> 。但是对于平时使用的fs等异步的库我们要怎么才能利用promise呢。 在q的文档中介绍了q-io库，里面将常用的io方法都用promise的模式包装了一遍，在实际使用中，你可以使用那个库的方法。不过我们在这里简单的对fs进行包装，让其支持promise，这样以后遇到任何异步方法，你都可以将其转化。</p>
<p>首先定义改一个readFile方法，返回promise，这里利用了 <strong>Q</strong> 的 <strong>defer()</strong> 方法，创建一个 <em>deferred</em> 对象。这个对象有连个关键的方法 <strong>resolve</strong> 和 <strong>reject()</strong> 。当resolve(value)执行之后，promise变成fullfilled状态，fullfilled的值就是value 当 <strong>reject(reason)</strong> 执行之后，promise变成了rejected状态，reason会被传递到onRejected()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Q = require(&apos;q&apos;);</span><br><span class="line">function readFile(callback)&#123;</span><br><span class="line">  var deferred = Q.defer();</span><br><span class="line">  fs.readFile(&apos;example.json&apos;, function(err, data)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      deferred.reject(err);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      deferred.resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return deferred.promise.nodeify(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里面我们依然提供了一个callback，用于提供一些需要callback的场合的兼容性，我们利用 <em>promise</em> 对象的nodeify方法来调用这个callback，这个callback可以为undefined。</p>
<p>另外一点需要注意的是，一个promise状态改变之后，不能再次改变，所以，你只能调用一次reject或resolve。</p>
<p>有了这个API，我们便可以像前面例子里那样，使用promise来执行读取文件的操作了。其他异步回调转化成返回promise的异步方法基本上都可以参照这个模式来做。</p>
<h4 id="一次处理多个promise的"><a href="#一次处理多个promise的" class="headerlink" title="一次处理多个promise的"></a>一次处理多个promise的</h4><p>如果你有几个异步方法，他们都返回promise，并且当这些方法都处理完之后，你才能进行下一步，Q提供了一个all()方法来帮助你消化多个promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Q.all([</span><br><span class="line">  readFile(&apos;file1.json&apos;),</span><br><span class="line">  readFile(&apos;file2.json&apos;)</span><br><span class="line">  ])</span><br><span class="line">  .then(function(dataArray)&#123;</span><br><span class="line">    for(var i = 0; i &lt; dataArray.length; i++)&#123;</span><br><span class="line">      console.log(dataArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在这里例子里，我们将一个promise数组传给 <strong>all()</strong> all返回一个promise，当数组里面的所有promise都为fullfilled状态时，我们的then()方法才会被调用。这时fullfilled值是一个数组，每个元素对应前面promise的fullfilled值。 当任意一个promise变成rejected状态的时候，all的promise会立即reject而不等其他的完成。</p>
<h4 id="利用promise改写你的项目"><a href="#利用promise改写你的项目" class="headerlink" title="利用promise改写你的项目"></a>利用promise改写你的项目</h4><p>最佳的理解方法便是事件，你可以把一些nodejs的基本异步方法包装成promise，这样你就可以在整个程序的多个地方使用这些方法。并且让你的程序的异步代码看起来更整洁，更容易理解。 阅读 <a href="http://documentup.com/kriskowal/q/" target="_blank" rel="noopener">Q的文档</a> 了解更多的API和方法。并在程序中使用这些方法，使你的代码更优美，逻辑更健壮。 阅读 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promise/A+</a> 。了解promise原理。</p>
<h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn" target="_blank" rel="noopener">JavaScript Promise 简介</a></p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">node.js promise 简介</a></p>
<hr>
<h2 id="Intro-to-axios"><a href="#Intro-to-axios" class="headerlink" title="Intro to axios"></a>Intro to axios</h2><h2 id="Node-如何进行测试—Mocha-简介"><a href="#Node-如何进行测试—Mocha-简介" class="headerlink" title="Node 如何进行测试—Mocha 简介"></a>Node 如何进行测试—Mocha 简介</h2><h2 id="Node-入门"><a href="#Node-入门" class="headerlink" title="Node 入门"></a>Node 入门</h2><p>原文地址：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">戳这里</a></p>
<p>此文仅当作上述文档的笔记使用</p>
<p>JavaScript最早是运行在浏览器中， 然而浏览器只是提供了一个上下文， 它定义了使用JavaScript可以做什么， 但并没有“说”太多关于JavaScript语言本身可以做什么。事实上， JavaScript是一门完整的语言: 它可以使用在不同的额上下文中， 其能力与其他同类语言相比有过之而无不及。</p>
<p>Node.js 事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>
<p>要实现在后台运行JavaScript代码， 代码需要先被解释然后正确的执行。 Node.js 的原理正是如此， 它使用了Google的V8虚拟机来解释和执行JavaScript代码。</p>
<p>除此之外， 伴随着Node.js的还有许多 有用的模块， 他们可以简化很多重复的劳作， 比如向terminal输出字符串。</p>
<p>因此， Node.js事实上既是一个运行时环境， 同时又是一个库。</p>
<h3 id="一个完整的基于Node-js的web应用"><a href="#一个完整的基于Node-js的web应用" class="headerlink" title="一个完整的基于Node.js的web应用"></a>一个完整的基于Node.js的web应用</h3><h4 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h4><ul>
<li>用户可以通过浏览器使用我们的应用。</li>
<li>当用户请求<a href="http://domain.start" target="_blank" rel="noopener">http://domain.start</a> 时， 可以看到一个欢迎界面， 页面上有一个文件上传的表单。</li>
<li>用户可以选择一个图片并提交表单， 随后文件将被上传到<a href="http://domain/ipload，" target="_blank" rel="noopener">http://domain/ipload，</a> 该页面完成上传后会把图片显示在页面上。</li>
</ul>
<h4 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h4><p>为了实现上文的用例， 我们需要实现哪些部分呢？</p>
<ul>
<li>我们需要提供Web页面， 因此需要一个HTTP服务器</li>
<li>对于不同的请求， 根据请求的URL， 我们的服务器需要给予不同的相应， 因此我们需要一个路由， 用于把请求对应到请求处理程序。</li>
<li>当请求被服务器接受并通过路由传递之后， 需要可以对其进行处理， 因此我们需要最终的请求处理程序。</li>
<li>路由还应该能处理POST数据， 并且把数据封装成更友好的格式传递给请求处理的程序， 因此需要请求数据处理功能。</li>
<li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>
<li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>
</ul>
<p>基础服务器的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>由上代码，我们先接受这一点: 在JavaScript中， 一个函数可以作为另一个函数接受的参数。 我们可以先定义一个函数， 然后传递， 也可以在传递参数的地方直接定义函数（匿名函数）。</p>
<p>用下面的代码我们也可以达到同样的目的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>那么我们为什么要使用这种方式呢？</p>
<h4 id="基于事件驱动的回调"><a href="#基于事件驱动的回调" class="headerlink" title="基于事件驱动的回调"></a>基于事件驱动的回调</h4><p>这是Node.js原生的工作方式。 它是事件驱动的， 这也是它为什么这么快的原因。</p>
<p>参考资料：<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="noopener">Understanding node.js</a></p>
<p>当我们使用http.createServer方法的时候， 我们当然不只是想要一个侦听某个端口的服务器， 我们还想它在服务器收到一个HTTP请求的时候做点什么。</p>
<p>问题是， 这是异步的： 请求任何时候都可能到达， 但是我们的服务器却跑在一个单进程中。</p>
<p>我们创建了服务器， 并且向创建它的方法传递了一个函数。 无论何时我们的服务器收到一个请求， 这个函数就会被调用。</p>
<p>我们不知道这件事情什么时候会发生， 但是我们现在有了一个处理请求的地方：它就是我们传递过去的哪个函数。 至于它是被预先定义的函数还是匿名函数， 就无关紧要了。</p>
<p>这个就是传说中的回调。 我们给某个方法传递了一个函数， 这个方法在有相应事件发生时调用这个函数来进行回调。</p>
<p>我们仍然只拥有整个应用的最初部分： 我们可以接受HTTP请求。 但是我们得做点什么–对于不同的URL请求， 服务器应该有不同的反应。</p>
<p>对于一个非常简单的应用来说， 你可以直接在回调函数<code>onRequest()</code>中做这件事情。 不过就像我所说的， 我们应该加入一些抽象的元素， 让我们的例子变得更有趣一些。</p>
<p>处理不同的HTTP请求在我们的代码中是一个不同的部分， 叫做“路由选择”—-那么， 我们接下来就创造一个叫做路由的模块吧。</p>
<h4 id="如何来进行请求的路由"><a href="#如何来进行请求的路由" class="headerlink" title="如何来进行请求的路由"></a>如何来进行请求的路由</h4><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>
<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                               url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http://localhost:8888/start?foo=bar&amp;hello=world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring(string)[&quot;foo&quot;]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring(string)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>
<p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>
<p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
<p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>
<p> 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>
<p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"></span><br><span class="line">    route(pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"></span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<p>在这里，我们传递的函数依旧什么也没做。</p>
<p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash$ node index.js</span><br><span class="line">Request <span class="keyword">for</span> /foo received.</span><br><span class="line">About to route a request <span class="keyword">for</span> /foo</span><br></pre></td></tr></table></figure>
<p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>
<h4 id="路由给真正的请求处理程序"><a href="#路由给真正的请求处理程序" class="headerlink" title="路由给真正的请求处理程序"></a>路由给真正的请求处理程序</h4><p>回到正题，现在我们的 HTTP服务器和请求路由模块已经如我们的期望可以相互交流了，但是这还远远不够—我们的业务逻辑还没有实现。</p>
<p>在现在的实现下， 路由过程会在路由模块中结束， 并且路由模块并不是真正针对请求采取行动的模块，否则当我们的应用程序变得更为复杂时， 将无法很好地扩展。</p>
<p>我们暂时把作为路由目标的函数称为请求处理程序。 现在我们不要急着来开发路由模块， 因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>
<p>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把请求处理程序和路由模块连接起来， 让路由“有路可循”。</p>
<p>在这里我们得做个决定： 是将requestHandlers模块硬编码到路由里来使用， 还是再添加一点依赖注入？ 虽然和其他模式一样， 以来注入不应该仅仅为使用而使用， 但是现在这个情况下， 使用依赖注入可以让路由和请求处理程序之间的耦合更加松散， 也因此能让路由的重用性更高。</p>
<p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>
<p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<em>if request == x then call handler y</em>也使得系统丑陋不堪。</p>
<p>在C++或C#中， 当我们谈到对象， 指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类）， 会拥有不同的属性和方法。 但是在JavaScript里对象不是这个概念。 在JavaScript中， 对象就是一个键/值对的集合–你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>
<p>好了，最后再回到代码上来。 现在我们已经确定将一系列请求处理程序通过一个对象来传递， 并且需要使用松耦合的方式将这个对象注入到route（）函数中。</p>
<p>我们先将这个对象引入到主文件<em>index.js</em>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"><span class="keyword">var</span> requestHandlers = <span class="built_in">require</span>(<span class="string">"./requestHandlers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = &#123;&#125;</span><br><span class="line">handle[<span class="string">"/"</span>] = requestHandlers.start;</span><br><span class="line">handle[<span class="string">"/start"</span>] = requestHandlers.start;</span><br><span class="line">handle[<span class="string">"/upload"</span>] = requestHandlers.upload;</span><br><span class="line"></span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为<em>“/“</em>的属性，对应<em>requestHandlers.start</em>即可，这样我们就可以干净简洁地配置<em>/start</em>和<em>/</em>的请求都交由<em>start</em>这一处理程序处理。</p>
<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将<em>server.js</em>修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"></span><br><span class="line">    route(handle, pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>这样我们就在start（）函数里添加了handle参数， 并且把handle对象作为第一个参数传递给了route（）回调函数。</p>
<p>然后我们相应地在route.js文件中修改route()函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    handle[pathname]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>我们上述程序只是实现了一个基本的框架， 即server-router-handler的模式，但是如果我们要求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”， 那就更好了。</p>
<h5 id="不好的实现方式"><a href="#不好的实现方式" class="headerlink" title="不好的实现方式"></a>不好的实现方式</h5><p>对于我们这样拥有PHP或者Ruby技术背景的开发者来说， 最直截了当的实现方式事实上并不是非常靠谱： 看似有效， 实际上未必如此。</p>
<p>这里我指的“直截了当的实现方式”意思是：让请求处理程序通过<em>onRequest</em>函数直接返回（<em>return()</em>）他们要展示给用户的信息。</p>
<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>
<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将<em>requestHandler.js</em>修改为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Start"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将<em>router.js</em>修改为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handle[pathname]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"404 Not found"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>
<p>最后，我们需要对我们的<em>server.js</em>进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> content = route(handle, pathname)</span><br><span class="line">    response.write(content);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>如果我们运行重构后的应用，一切都会工作的很好：请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>,浏览器会输出“Hello Start”，请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>会输出“Hello Upload”,而请求<a href="http://localhost:8888/foo" target="_blank" rel="noopener">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>
<p>好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。</p>
<p>没理解？没关系，下面就来详细解释下。</p>
<h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</p>
<p>我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</p>
<p>这里，我们来修改下<em>start</em>请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似<em>sleep()</em>这样的操作，所以这里只能够来点小Hack来模拟实现。</p>
<p>让我们将<em>requestHandlers.js</em>修改成如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">milliSeconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &lt; startTime + milliSeconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">10000</span>);<span class="comment">//here we add the blocking event here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Start"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>上述代码中，当函数<em>start()</em>被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用<em>upload()</em>的时候，会和此前一样立即返回。</p>
<p>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>
<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>
<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>， 但是先不要打开它！</p>
<p>在第二个浏览器窗口的地址栏中输入<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>， 同样的，先不要打开它！</p>
<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>
<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然<em>也</em>花了10秒，而它在对应的请求处理程序中并没有类似于<em>sleep()</em>这样的操作！</p>
<p>这到底是为什么呢？原因就是<em>start()</em>包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<p>这显然是个问题，因为Node一向是这样来标榜自己的：<em>“在node中除了代码，所有一切都是并行执行的”</em>。</p>
<p>这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>
<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>
<p>对于Node.js来说，它是这样处理的：<em>“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</em></p>
<p>（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="noopener">理解node.js的事件轮询</a>。）</p>
<p>接下来，我们会介绍一种错误的使用非阻塞操作的方式。</p>
<p>和上次一样，我们通过修改我们的应用来暴露问题。</p>
<p>这次我们还是拿<em>start</em>请求处理程序来“开刀”。将其修改成如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line">  <span class="keyword">var</span> content = <span class="string">"empty"</span>;</span><br><span class="line"></span><br><span class="line">  exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    content = stdout;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们引入了一个新的Node.js模块，<em>child_process</em>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<em>exec()</em>。</p>
<p><em>exec()</em>做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当<em>/start</em>URL请求的时候将文件信息输出到浏览器中。</p>
<p>上述代码是非常直观的： 创建了一个新的变量<em>content</em>（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>
<p>和往常一样，我们启动服务器，然后访问“<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>” 。</p>
<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>
<p>这个时候，你可能大致已经猜到了，<em>exec()</em>在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>
<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>
<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>
<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>
<p>问题就在于，为了进行非阻塞工作，<em>exec()</em>使用了回调函数。</p>
<p>在我们的例子中，该回调函数就是作为第二个参数传递给<em>exec()</em>的匿名函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  content = stdout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用<em>exec()</em>之后，Node.js会立即执行 <em>return content</em> ；在这个时候，<em>content</em>仍然是“empty”，因为传递给<em>exec()</em>的回调函数还未执行到——因为<em>exec()</em>的操作是异步的。</p>
<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>
<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当<em>exec()</em>在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给<em>exec()</em>的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>
<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>
<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>
<h5 id="以非阻塞操作进行请求请求响应"><a href="#以非阻塞操作进行请求请求响应" class="headerlink" title="以非阻塞操作进行请求请求响应"></a>以非阻塞操作进行请求请求响应</h5><p>我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>
<p>不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。</p>
<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>现在我们采用如下这种新的实现方式： 相对采用将内容传递给服务器的方式， 我们这次采用将服务器传递给内容的方式。 从实践角度来说， 就是将response对象（从服务器的回调函数onRequest（）获取）通过请求路由传递给请求处理程序， 随后， 处理程序就可以采用该对象上的函数来对请求做出响应。</p>
<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>
<p>先从<em>server.js</em>开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"></span><br><span class="line">    route(handle, pathname, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>相对此前从<em>route()</em>函数获取返回值的做法，这次我们将response对象作为第三个参数传递给<em>route()</em>函数，并且，我们将<em>onRequest()</em>处理程序中所有有关<em>response</em>的函数调都移除，因为我们希望这部分工作让<em>route()</em>函数来完成。</p>
<p>下面就来看看我们的<em>router.js</em>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    handle[pathname](response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</span><br><span class="line">    response.writeHead(<span class="number">404</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"404 Not found"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递<em>response</em>对象。</p>
<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>
<p>最后，我们将<em>requestHandler.js</em>修改为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line"></span><br><span class="line">  exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(stdout);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello Upload"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>
<p><em>start</em>处理程序在<em>exec()</em>的匿名回调函数中做请求响应的操作，而<em>upload</em>处理程序仍然是简单的回复“Hello World”，只是这次是使用<em>response</em>对象而已。</p>
<p>这时再次我们启动应用（<em>node index.js</em>），一切都会工作的很好。</p>
<p>如果想要证明<em>/start</em>处理程序中耗时的操作不会阻塞对<em>/upload</em>请求作出立即响应的话，可以将<em>requestHandlers.js</em>修改为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</span><br><span class="line"></span><br><span class="line">  exec(<span class="string">"find /"</span>,</span><br><span class="line">    &#123; <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="attr">maxBuffer</span>: <span class="number">20000</span>*<span class="number">1024</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">      response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">      response.write(stdout);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello Upload"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>这样一来，当请求<a href="http://localhost:8888/start" target="_blank" rel="noopener">http://localhost:8888/start</a>的时候，会花10秒钟的时间才载入，而当请求<a href="http://localhost:8888/upload" target="_blank" rel="noopener">http://localhost:8888/upload</a>的时候，会立即响应，纵然这个时候/start响应还在处理中。</p>
<h3 id="添加upload等功能。"><a href="#添加upload等功能。" class="headerlink" title="添加upload等功能。"></a>添加upload等功能。</h3><p>具体见：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">node.js入门</a></p>
<h2 id="常见middleware简介"><a href="#常见middleware简介" class="headerlink" title="常见middleware简介"></a>常见middleware简介</h2><h3 id="为什么使用method-override"><a href="#为什么使用method-override" class="headerlink" title="为什么使用method-override"></a>为什么使用method-override</h3><p>这个需求主要来自前端的form， 比如我们在后端提供一个针对HTTP PUT的API， 前端的数据提交时， 我们自然希望FORM能够产生一个PUT请求。 然而， 浏览器的FORM只能GET或者POST。 这个时候， 我们就需要使用method-override来帮助我们。</p>
<h3 id="Express模板传值对象-app-locals-res-locals"><a href="#Express模板传值对象-app-locals-res-locals" class="headerlink" title="Express模板传值对象 app.locals, res.locals"></a>Express模板传值对象 app.locals, res.locals</h3><p>locals是Express应用中 Application(app)对象和Response(res)对象中的属性， 该属性是一个对象。该对象的主要作用是， 将值传递到所传递的模板中。</p>
<p>locals对象会被传递到页面， 在模板中可以直接引用该对象的属性， 也可以通过该对象引用。如：<code>&lt;%= name %&gt;</code>属性同样可以通过<code>&lt;%= locals.name %&gt;</code>来引用。</p>
<h4 id="app-locals与-res-locals"><a href="#app-locals与-res-locals" class="headerlink" title="app.locals与 res.locals"></a>app.locals与 res.locals</h4><p>locals可能存在于app对象中， 即： app.locals； 也可能存在于res对象中， 即： res.locals。 两者都会将对象传递至所渲染的页面中。 不同的是， app.locals会在整个生命周期中起作用； 而res.locals只会有当前请求中起作用。 由于app.locals 在当前应用所有的渲染模中访问， 这样我们就可以在对象中定义一些顶级/全局的数据， 并在渲染模板中使用。</p>
<h2 id="Node-Express获取参数的几种方式"><a href="#Node-Express获取参数的几种方式" class="headerlink" title="Node Express获取参数的几种方式"></a>Node Express获取参数的几种方式</h2><p>Node 配合Express框架获取参数主要有以下四种反射方式：</p>
<ul>
<li>req.body</li>
<li>req.params</li>
<li>req.param()</li>
<li>req.query</li>
</ul>
<h3 id="使用场景案例"><a href="#使用场景案例" class="headerlink" title="使用场景案例"></a>使用场景案例</h3><h4 id="req-body"><a href="#req-body" class="headerlink" title="req. body"></a>req. body</h4><p><code>req.body</code>在<a href="http://expressjs.com/4x/api.html#request" target="_blank" rel="noopener">官方文档</a>是没有提供的，但是它也是很好用的获取表单参数的方法。<code>req.body</code>是<strong>配合Express中间件bodyParser()中间件</strong>提供的。当<code>bodyParser()</code>中间件使用后，这个对象默认为 <code>{}</code>,<code>req.body</code>可以获取到post到body中的内容。<br>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/user/signup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _user = req.body.user;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// POST user[name]=tobi&amp;user[email]=tobi@learnboost.com</span></span><br><span class="line">req.body.user.name</span><br><span class="line"><span class="comment">// =&gt; "tobi"</span></span><br><span class="line"></span><br><span class="line">req.body.user.email</span><br><span class="line"><span class="comment">// =&gt; "tobi@learnboost.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POST &#123; "name": "tobi" &#125;</span></span><br><span class="line">req.body.name</span><br><span class="line"><span class="comment">// =&gt; "tobi"</span></span><br></pre></td></tr></table></figure>
<h4 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h4><p>这是一个数组对象， 命名过的参数会以键值对的形式存放。 比如你有一个路由<code>/user/:name</code>， name属性会存放在req.params.name. 这个对象默认为{}， 比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/user/signup/:userid'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	req.params.userid;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="req-param-name"><a href="#req-param-name" class="headerlink" title="req.param(name)"></a>req.param(name)</h4><p>req.param() 是req.query, req.body 以及 req.params 获取参数的三种方式的封装。 req.param(name)返回name参数的值。</p>
<h4 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h4><p>这是一个解析过的请求参数对象，默认为<code>{}</code>.<br>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /search?q=tobi+ferret</span></span><br><span class="line">req.query.q</span><br><span class="line"><span class="comment">// =&gt; "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order</span><br><span class="line"><span class="comment">// =&gt; "desc"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.color</span><br><span class="line"><span class="comment">// =&gt; "blue"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.type</span><br><span class="line"><span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>总结出以下四点：</p>
<ol>
<li>对于path中的变量， 均可以使用 req.params.XXXXX方法</li>
<li>于get请求的<code>?xxxx=</code>,使用<code>req.query.xxxxx</code>方法</li>
<li>对于post请求中的变量，使用<code>req.body.xxxxx</code>方法</li>
<li>以上三种情形，均可以使用<code>req.param()</code>方法，所以说<code>req.param()</code>是<code>req.query</code>、<code>req.body</code>、以及<code>req.params</code>获取参数的三种方式的封装。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/23/Common-Random-Algorithm/" rel="next" title="Common Random Algorithm">
                <i class="fa fa-chevron-left"></i> Common Random Algorithm
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/26/Intro-to-yargs/" rel="prev" title="Intro to yargs">
                Intro to yargs <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Liyan Chen" />
            
              <p class="site-author-name" itemprop="name">Liyan Chen</p>
              <p class="site-description motion-element" itemprop="description">千江有水千江月， 万里无云万里天</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Lic128" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:lic128@eng.ucsd.edu" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何理解node-js-的单线程"><span class="nav-number">1.</span> <span class="nav-text">如何理解node.js 的单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">1.1.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-调试工具"><span class="nav-number">2.</span> <span class="nav-text">Node.js 调试工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-inspect"><span class="nav-number">2.1.</span> <span class="nav-text">Node inspect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-–inspect-brk-Chrome-Dev-Tools"><span class="nav-number">2.2.</span> <span class="nav-text">Node –inspect-brk(Chrome Dev Tools)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料-1"><span class="nav-number">2.3.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intro-to-ES6"><span class="nav-number">3.</span> <span class="nav-text">Intro to ES6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-and-Callback"><span class="nav-number">4.</span> <span class="nav-text">Promise and Callback</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Callback"><span class="nav-number">4.1.</span> <span class="nav-text">Callback</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料："><span class="nav-number">4.1.1.</span> <span class="nav-text">参考资料：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">4.2.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#制作promise的API"><span class="nav-number">4.2.1.</span> <span class="nav-text">制作promise的API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一次处理多个promise的"><span class="nav-number">4.2.2.</span> <span class="nav-text">一次处理多个promise的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用promise改写你的项目"><span class="nav-number">4.2.3.</span> <span class="nav-text">利用promise改写你的项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料-2"><span class="nav-number">4.2.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intro-to-axios"><span class="nav-number">5.</span> <span class="nav-text">Intro to axios</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-如何进行测试—Mocha-简介"><span class="nav-number">6.</span> <span class="nav-text">Node 如何进行测试—Mocha 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-入门"><span class="nav-number">7.</span> <span class="nav-text">Node 入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个完整的基于Node-js的web应用"><span class="nav-number">7.1.</span> <span class="nav-text">一个完整的基于Node.js的web应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现功能："><span class="nav-number">7.1.1.</span> <span class="nav-text">实现功能：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用不同模块分析"><span class="nav-number">7.1.2.</span> <span class="nav-text">应用不同模块分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于事件驱动的回调"><span class="nav-number">7.1.3.</span> <span class="nav-text">基于事件驱动的回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何来进行请求的路由"><span class="nav-number">7.1.4.</span> <span class="nav-text">如何来进行请求的路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由给真正的请求处理程序"><span class="nav-number">7.1.5.</span> <span class="nav-text">路由给真正的请求处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不好的实现方式"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">不好的实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞与非阻塞"><span class="nav-number">7.1.5.2.</span> <span class="nav-text">阻塞与非阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#以非阻塞操作进行请求请求响应"><span class="nav-number">7.1.5.3.</span> <span class="nav-text">以非阻塞操作进行请求请求响应</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加upload等功能。"><span class="nav-number">7.2.</span> <span class="nav-text">添加upload等功能。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见middleware简介"><span class="nav-number">8.</span> <span class="nav-text">常见middleware简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用method-override"><span class="nav-number">8.1.</span> <span class="nav-text">为什么使用method-override</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Express模板传值对象-app-locals-res-locals"><span class="nav-number">8.2.</span> <span class="nav-text">Express模板传值对象 app.locals, res.locals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#app-locals与-res-locals"><span class="nav-number">8.2.1.</span> <span class="nav-text">app.locals与 res.locals</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-Express获取参数的几种方式"><span class="nav-number">9.</span> <span class="nav-text">Node Express获取参数的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景案例"><span class="nav-number">9.1.</span> <span class="nav-text">使用场景案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#req-body"><span class="nav-number">9.1.1.</span> <span class="nav-text">req. body</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#req-params"><span class="nav-number">9.1.2.</span> <span class="nav-text">req.params</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#req-param-name"><span class="nav-number">9.1.3.</span> <span class="nav-text">req.param(name)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#req-query"><span class="nav-number">9.1.4.</span> <span class="nav-text">req.query</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别与联系"><span class="nav-number">9.2.</span> <span class="nav-text">区别与联系</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyan Chen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
